skip to content you signed in with another tab or window. reload to refresh your session. you signed out in another tab or window. reload to refresh your session. you switched accounts on another tab or window. reload to refresh your session. dismiss alert ros2 / rcl public notifications you must be signed in to change notification settings fork 162 star 128 files 657d9e8 / context.h blame blame latest commit history history 261 lines (243 loc)  9.9 kb 657d9e8 / context.h top file metadata and controls code blame 261 lines (243 loc)  9.9 kb raw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 //  2018 open source robotics foundation, inc. // // licensed under the apache license, version 2.0 (the "license"); // you may not use this file except in compliance with the license. // you may obtain a copy of the license at // // http://www.apache.org/licenses/license-2.0 // // unless required by applicable law or agreed to in writing, software // distributed under the license is distributed on an "as is" basis, // without warranties or conditions of any kind, either express or implied. // see the license for the specific language governing permissions and // limitations under the license. #ifndef rcl__context_h_ #define rcl__context_h_ #ifdef __cplusplus extern "c" { #endif #include "rmw/init.h" #include "rcl/allocator.h" #include "rcl/arguments.h" #include "rcl/init_options.h" #include "rcl/macros.h" #include "rcl/types.h" #include "rcl/visibility_control.h" typedef uint64_t rcl_context_instance_id_t ; struct rcl_context_impl_t ; /// encapsulates the non-global state of an init/shutdown cycle. /** * the context is used in the creation of top level entities like nodes and * guard conditions, as well as to shutdown a specific instance of init. * * here is a diagram of a typical context's lifecycle: * * ``` * +---------------+ * | | * +--> uninitialized +---> rcl_get_zero_initialized_context() + * | | | | * | +---------------+ | * | | * | +-----------------------------------------------+ * | | * | +--------v---------+ +-----------------------+ * | | | | | * | | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() + * | | | | | | * | +------------------+ +-----------------------+ | * | | * | +-----------------------------------------------------------------+ * | | * | +------------v------------+ * | | | * | | initialized but invalid +---> finalize all entities, then rcl_context_fini() + * | | | | * | +-------------------------+ | * | | * +---------------------------------------------------------------------------------+ * ``` * * a declared but not defined `rcl_context_t` instance is considered to be * "uninitialized", and passing an uninitialized context to any functions will * result in undefined behavior. * some functions, like `rcl_init()` require the context instance to be * zero initialized (all members set to "zero" state) before use. * * zero initialization of an `rcl_context_t` should be done with * `rcl_get_zero_initialized_context()`, which ensures the context is in a safe * state for initialization with `rcl_init()`. * * initialization of an `rcl_context_t` should be done with `rcl_init()`, after * which the context is considered both initialized and valid. * after initialization it can be used in the creation of other entities like * nodes and guard conditions. * * at any time the context can be invalidated by calling `rcl_shutdown()` on * the `rcl_context_t`, after which the context is still initialized but now * invalid. * * invalidation indicates to other entities that the context was shutdown, but * is still accessible for use during cleanup of themselves. * * after being invalidated, and after all of the entities which used it have * been finalized, the context should be finalized with `rcl_context_fini()`. * * finalizing the context while entities which have copies of it have not yet * been finalized is undefined behavior. * therefore, the context's lifetime (between calls to `rcl_init()` and * `rcl_context_fini()`) should exceed the lifetime of all entities which use * it directly (e.g. nodes and guard conditions) or indirectly (e.g. * s and topics). */ typedef struct rcl_context_t { /// global arguments for all nodes which share this context. /** typically generated by the parsing of argc/argv in `rcl_init()`. */ rcl_arguments_t global_arguments ; /// implementation specific pointer. struct rcl_context_impl_t * impl ; // the assumption that this is big enough for an atomic_uint_least64_t is // ensured with a static_assert in the context.c file. // in most cases it should just be a plain uint64_t. #if !defined( rcl_context_atomic_instance_id_storage_size ) #define rcl_context_atomic_instance_id_storage_size sizeof(uint_least64_t) #endif /// private storage for instance id atomic. /** * accessing the instance id should be done using the function * `rcl_context_get_instance_id()` because the instance id's type is an * atomic and needs to be accessed properly to ensure safety. * * the instance id should not be changed manually - doing so is undefined * behavior. * * the instance id cannot be protected within the `impl` pointer's type * because it needs to be accessible even when the context is zero * initialized and therefore `impl` is `null`. * specifically, storing the instance id in the `impl` would introduce a * race condition between accessing it and finalizing the context. * additionally, c11 atomics (i.e. "stdatomic.h") cannot be used directly * here in the case that this header is included into a c++ program. * see this paper for an effort to make this possible in the future: * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html */ uint8_t instance_id_storage [ rcl_context_atomic_instance_id_storage_size ]; } rcl_context_t ; /// return a zero initialization context object. rcl_public rcl_warn_unused rcl_context_t rcl_get_zero_initialized_context ( void ); // see `rcl_init()` for initialization of the context. /// finalize a context. /** * the context to be finalized must have been previously initialized with * `rcl_init()`, and then later invalidated with `rcl_shutdown()`. * if context is `null`, then `rcl_ret_invalid_argument` is returned. * if context is zero-initialized, then `rcl_ret_invalid_argument` is returned. * if context is initialized and valid (`rcl_shutdown()` was not called on it), * then `rcl_ret_invalid_argument` is returned. * * <hr> * attribute | adherence * ------------------ | ------------- * allocates memory | yes * thread-safe | no * uses atomics | yes * lock-free | yes [1] * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i> * * \return `rcl_ret_ok` if the shutdown was completed successfully, or * \return `rcl_ret_invalid_argument` if any arguments are invalid, or * \return `rcl_ret_error` if an unspecified error occur. */ rcl_public rcl_warn_unused rcl_ret_t rcl_context_fini ( rcl_context_t * context ); // see `rcl_shutdown()` for invalidation of the context. /// return the init options used during initialization for this context. /** * this function can fail and return `null` if: * - context is null * - context is zero-initialized, e.g. context->impl is `null` * * if context is uninitialized then that is undefined behavior. * * if `null` is returned an error message will have been set. * * the options are for reference only, and therefore the returned pointer is * const. * changing the values in the options is undefined behavior but will likely * have no effect. * * <hr> * attribute | adherence * ------------------ | ------------- * allocates memory | no * thread-safe | yes * uses atomics | yes * lock-free | yes * * \param[in] context object from which the init options should be retrieved * \return pointer to the the init options, or * \return `null` if there was an error */ rcl_public rcl_warn_unused const rcl_init_options_t * rcl_context_get_init_options ( rcl_context_t * context ); /// returns an unsigned integer that is unique to the given context, or `0` if invalid. /** * the given context must be non-`null`, but does not need to be initialized or valid. * if context is `null`, then `0` will be returned. * if context is uninitialized, then it is undefined behavior. * * the instance id may be `0` if the context is zero-initialized or if the * context has been invalidated by `rcl_shutdown()`. * * <hr> * attribute | adherence * ------------------ | ------------- * allocates memory | no * thread-safe | yes * uses atomics | yes * lock-free | yes [1] * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i> * * \param[in] context object from which the instance id should be retrieved * \return a unique id specific to this context instance, or * \return `0` if invalid, or * \return `0` if context is `null` */ rcl_public rcl_warn_unused rcl_context_instance_id_t rcl_context_get_instance_id ( rcl_context_t * context ); /// return `true` if the given context is currently valid, otherwise `false`. /** * if context is `null`, then `false` is returned. * if context is zero-initialized, then `false` is returned. * if context is uninitialized, then it is undefined behavior. * * attribute | adherence * ------------------ | ------------- * allocates memory | no * thread-safe | yes * uses atomics | yes * lock-free | yes [1] * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i> * * \param[in] context object which should be checked for validity * \return `true` if valid, otherwise `false` */ rcl_public rcl_warn_unused bool rcl_context_is_valid ( rcl_context_t * context ); #ifdef __cplusplus } #endif #endif // rcl__context_h_ you cant perform that action at this time.