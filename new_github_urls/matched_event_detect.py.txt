skip to content you signed in with another tab or window. reload to refresh your session. you signed out in another tab or window. reload to refresh your session. you switched accounts on another tab or window. reload to refresh your session. dismiss alert ros2 / demos public notifications you must be signed in to change notification settings fork 330 star 493 files iron / matched_event_detect.py blame blame latest commit history history 205 lines (162 loc)  8.19 kb iron / matched_event_detect.py top file metadata and controls code blame 205 lines (162 loc)  8.19 kb raw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #  2023 sony group corporation. # # licensed under the apache license, version 2.0 (the "license"); # you may not use this file except in compliance with the license. # you may obtain a copy of the license at # # http://www.apache.org/licenses/license-2.0 # # unless required by applicable law or agreed to in writing, software # distributed under the license is distributed on an "as is" basis, # without warranties or conditions of any kind, either express or implied. # see the license for the specific language governing permissions and # limitations under the license. import rclpy from rclpy . event_handler import publishereventcallbacks from rclpy . event_handler import qospublishermatchedinfo from rclpy . event_handler import qosmatchedinfo from rclpy . event_handler import eventcallbacks from rclpy . executors import singlethreadedexecutor from rclpy . node import node from rclpy . publisher import publisher from rclpy .  import  from rclpy . task import future from std_msgs . msg import string """ this demo program shows detected matched event. matched event occurs when publisher and  establishes the connection. class matchedeventdetectnode output connection information of publisher and . class multisubnode is used to create/destroy  to connect/disconnect the publisher of matchedeventdetectnode. class multipubnode is used to created/destroy publisher to connect/disconnect the  of matchedeventdetectnode. """ class matchedeventdetectnode ( node ): def __init__ ( self , pub_topic_name : string , sub_topic_name : string ): super (). __init__ ( 'matched_event_detection_node' ) self . __any__connected = false # used for publisher event self . __any_publisher_connected = false # used for  event pub_event_callback = publishereventcallbacks ( matched = self . __pub_matched_event_callback ) self . pub = self . create_publisher ( string , pub_topic_name , 10 , event_callbacks = pub_event_callback ) sub_event_callback = eventcallbacks ( matched = self . __sub_matched_event_callback ) self . sub = self . create_ ( string , sub_topic_name , lambda msg : ..., 10 , event_callbacks = sub_event_callback ) def __pub_matched_event_callback ( self , info : qospublishermatchedinfo ): if self . __any__connected : if info . current_count == 0 : self . get_logger (). info ( 'last  is disconnected.' ) self . __any__connected = false else : self . get_logger (). info ( 'the changed number of connected  is ' + str ( info . current_count_change ) + ' and ' 'current number of connected  is ' + str ( info . current_count )) else : if info . current_count != 0 : self . get_logger (). info ( 'first  is connected.' ) self . __any__connected = true self . future . set_result ( true ) def __sub_matched_event_callback ( self , info : qosmatchedinfo ): if self . __any_publisher_connected : if info . current_count == 0 : self . get_logger (). info ( 'last publisher is disconnected.' ) self . __any_publisher_connected = false else : self . get_logger (). info ( 'the changed number of connected publisher is ' + str ( info . current_count_change ) + ' and current ' 'number of connected publisher is ' + str ( info . current_count )) else : if info . current_count != 0 : self . get_logger (). info ( 'first publisher is connected.' ) self . __any_publisher_connected = true self . future . set_result ( true ) def get_future ( self ): self . future = future () return self . future class multisubnode ( node ): def __init__ ( self , topic_name : string ): super (). __init__ ( 'multi_sub_node' ) self . __subs = [] self . __topic_name = topic_name def create_one_sub ( self ) ->  : self . get_logger (). info ( 'create a new .' ) sub = self . create_ ( string , self . __topic_name , lambda msg : ..., 10 ) self . __subs . append ( sub ) return sub def destroy_one_sub ( self , sub :  ): if sub in self . __subs : self . get_logger (). info ( 'destroy a .' ) self . __subs . remove ( sub ) self . destroy_ ( sub ) class multipubnode ( node ): def __init__ ( self , topic_name : string ): super (). __init__ ( 'multi_pub_node' ) self . __pubs = [] self . __topic_name = topic_name def create_one_pub ( self ) -> publisher : self . get_logger (). info ( 'create a new publisher.' ) pub = self . create_publisher ( string , self . __topic_name , 10 ) self . __pubs . append ( pub ) return pub def destroy_one_pub ( self , pub : publisher ): if pub in self . __pubs : self . get_logger (). info ( 'destroy a publisher.' ) self . __pubs . remove ( pub ) self . destroy_publisher ( pub ) def main ( args = none ): rclpy . init ( args = args ) topic_name_for_detect_pub_matched_event = 'pub_topic_matched_event_detect' topic_name_for_detect_sub_matched_event = 'sub_topic_matched_event_detect' matched_event_detect_node = matchedeventdetectnode ( topic_name_for_detect_pub_matched_event , topic_name_for_detect_sub_matched_event ) multi_subs_node = multisubnode ( topic_name_for_detect_pub_matched_event ) multi_pubs_node = multipubnode ( topic_name_for_detect_sub_matched_event ) maximum_wait_time = 10 # 10s executor = singlethreadedexecutor () executor . add_node ( matched_event_detect_node ) executor . add_node ( multi_subs_node ) executor . add_node ( multi_pubs_node ) # matchedeventdetectnode will output: # first  is connected. sub1 = multi_subs_node . create_one_sub () executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # the changed number of connected  is 1 and current number of connected #  is 2. sub2 = multi_subs_node . create_one_sub () executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # the changed number of connected  is -1 and current number of connected #  is 1. multi_subs_node . destroy_one_sub ( sub1 ) executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # last  is disconnected. multi_subs_node . destroy_one_sub ( sub2 ) executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # first publisher is connected. pub1 = multi_pubs_node . create_one_pub () executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # the changed number of connected publisher is 1 and current number of connected publisher # is 2. pub2 = multi_pubs_node . create_one_pub () executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # the changed number of connected publisher is -1 and current number of connected publisher # is 1. multi_pubs_node . destroy_one_pub ( pub1 ) executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) # matchedeventdetectnode will output: # last publisher is disconnected. multi_pubs_node . destroy_one_pub ( pub2 ) executor . spin_until_future_complete ( matched_event_detect_node . get_future (), maximum_wait_time ) multi_pubs_node . destroy_node () multi_subs_node . destroy_node () matched_event_detect_node . destroy_node () rclpy . try_shutdown () if __name__ == '__main__' : main () you cant perform that action at this time.