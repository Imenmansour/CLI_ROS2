cppreference.com create account log in namespaces page discussion variants views view edit history actions std:: expected from cppreference.com < cpp  | utility c++ compiler support freestanding and hosted language standard library standard library headers named requirements feature test macros (c++20) language support library concepts library (c++20) metaprogramming library (c++11) diagnostics library general utilities library strings library containers library iterators library ranges library (c++20) algorithms library numerics library localizations library input/output library filesystem library (c++17) regular expressions library (c++11) concurrency support library (c++11) technical specifications symbols index external libraries [edit] utilities library language support type support (basic types, rtti) library feature-test macros (c++20) dynamic memory management program utilities coroutine support (c++20) variadic functions is_constant_evaluated (c++20) is_within_lifetime (c++26) initializer_list (c++11) source_location (c++20) debugging support is_debugger_present (c++26) breakpoint_if_debugging (c++26) breakpoint (c++26) three-way comparison three_way_comparable three_way_comparable_with (c++20) (c++20) strong_ordering (c++20) weak_ordering (c++20) partial_ordering (c++20) common_comparison_category (c++20) compare_three_way_result (c++20) compare_three_way (c++20) strong_order (c++20) weak_order (c++20) partial_order (c++20) compare_strong_order_fallback (c++20) compare_weak_order_fallback (c++20) compare_partial_order_fallback (c++20) is_eq is_lt is_lteq (c++20) (c++20) (c++20) is_neq is_gt is_gteq (c++20) (c++20) (c++20) general utilities date and time function objects formatting library (c++20) bitset hash (c++11) relational operators (deprecated in c++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= integer comparison functions cmp_equal cmp_less cmp_less_than (c++20) (c++20) (c++20) cmp_not_equal cmp_greater cmp_greater_than (c++20) (c++20) (c++20) in_range (c++20) swap and type operations swap ranges::swap (c++20) exchange (c++14) declval (c++11) to_underlying (c++23) forward (c++11) forward_like (c++23) move (c++11) move_if_noexcept (c++11) as_const (c++17) common vocabulary types pair tuple (c++11) optional (c++17) any (c++17) variant (c++17) tuple_size (c++11) tuple_element (c++11) apply (c++17) make_from_tuple (c++17) expected (c++23) elementary string conversions to_chars (c++17) from_chars (c++17) chars_format (c++17) to_chars_result (c++17) from_chars_result (c++17) [edit] std::expected member functions expected::expected expected::~expected expected::operator= observers expected::operator-> expected::operator* expected::operator bool expected::has_value expected::value expected::error expected::value_or expected::error_or monadic operations expected::and_then expected::or_else expected::transform expected::transform_error modifiers expected::emplace expected::swap non-member functions operator== (std::expected) swap (std::expected) helper classes unexpected bad_expected_access unexpect_t unexpect [edit] defined in header <expected> template < class t, class e > class expected ; (1) (since c++23) template < class t, class e > requires std:: is_void_v < t > class expected < t, e > ; (2) (since c++23) the class template std::expected provides a way to represent either of two values: an expected value of type t , or an unexpected value of type e . std::expected is never valueless. 1) the main template. contains the expected or unexpected value within its own storage. no dynamic memory allocation takes place. 2) the void partial specialization. represents an expected void value or contains the unexpected value within its own storage. no dynamic memory allocation takes place. a program is ill-formed if it instantiates an expected with a reference type, a function type, or a specialization of std::unexpected . in addition, t must not be std::in_place_t or std::unexpect_t . contents 1 template parameters 2 member types 3 member alias templates 4 data members 5 member functions 5.1 observers 5.2 monadic operations 5.3 modifiers 6 non-member functions 7 helper classes 8 notes 9 example 10 references 11 see also [ edit ] template parameters t - the type of the expected value. the type must either be (possibly cv-qualified) void , or meet the destructible requirements (in particular, array and reference types are not allowed). e - the type of the unexpected value. the type must meet the destructible requirements, and must be a valid template argument for std::unexpected (in particular, arrays, non-object types, and cv-qualified types are not allowed). [ edit ] member types member type definition value_type t error_type e unexpected_type std::unexpected<e> [ edit ] member alias templates type definition rebind < u > std :: expected < u, error_type > [ edit ] data members member definition bool has_val whether the expected object currently represents the expected value ( exposition-only member object* ) t val (main template only) the expected value ( exposition-only variant member object* ) e unex the unexpected value ( exposition-only variant member object* ) [ edit ] member functions (constructor) constructs the expected object (public member function) [edit] (destructor) destroys the expected object, along with its contained value (public member function) [edit] operator= assigns contents (public member function) [edit] observers operator-> operator* accesses the expected value (public member function) [edit] operator bool has_value checks whether the object contains an expected value (public member function) [edit] value returns the expected value (public member function) [edit] error returns the unexpected value (public member function) [edit] value_or returns the expected value if present, another value otherwise (public member function) [edit] error_or returns the unexpected value if present, another value otherwise (public member function) [edit] monadic operations and_then returns the result of the given function on the expected value if it exists; otherwise, returns the expected itself (public member function) [edit] transform returns an expected containing the transformed expected value if it exists; otherwise, returns the expected itself (public member function) [edit] or_else returns the expected itself if it contains an expected value; otherwise, returns the result of the given function on the unexpected value (public member function) [edit] transform_error returns the expected itself if it contains an expected value; otherwise, returns an expected containing the transformed unexpected value (public member function) [edit] modifiers emplace constructs the expected value in-place (public member function) [edit] swap exchanges the contents (public member function) [edit] [ edit ] non-member functions operator== (c++23) compares expected objects (function template) [edit] swap (std::expected) (c++23) specializes the std::swap algorithm (function) [edit] [ edit ] helper classes unexpected (c++23) represented as an unexpected value (class template) [edit] bad_expected_access (c++23) exception indicating checked access to an expected that contains an unexpected value (class template) [edit] unexpect unexpect_t (c++23) in-place construction tag for unexpected value in expected (tag) [edit] [ edit ] notes types with the same functionality are called result in rust and either in haskell. feature-test macro value std feature __cpp_lib_expected 202202l (c++23) class template std::expected and associated helper classes 202211l (c++23) monadic functions for std::expected [ edit ] example run this code #include <cmath> #include <expected> #include <iomanip> #include <iostream> #include <string_view> enum class parse_error { invalid_input, overflow } ; auto parse_number ( std:: string_view & str ) - > std :: expected < double , parse_error > { const char * begin = str. data ( ) ; char * end ; double retval = std:: strtod ( begin, & end ) ; if ( begin == end ) return std:: unexpected ( parse_error :: invalid_input ) ; else if ( std:: isinf ( retval ) ) return std:: unexpected ( parse_error :: overflow ) ; str. remove_prefix ( end - begin ) ; return retval ; } int main ( ) { auto process = [ ] ( std:: string_view str ) { std:: cout << "str: " << std:: quoted ( str ) << ", " ; if ( const auto num = parse_number ( str ) ; num. has_value ( ) ) std:: cout << "value: " << * num << ' \n ' ; // if num did not have a value, dereferencing num // would cause an undefined behavior, and // num.value() would throw std::bad_expected_access. // num.value_or(123) uses specified default value 123. else if ( num. error ( ) == parse_error :: invalid_input ) std:: cout << "error: invalid input \n " ; else if ( num. error ( ) == parse_error :: overflow ) std:: cout << "error: overflow \n " ; else std:: cout << "unexpected! \n " ; // or invoke std::unreachable(); } ; for ( auto src : { "42" , "42abc" , "meow" , "inf" } ) process ( src ) ; } output: str: "42", value: 42 str: "42abc", value: 42 str: "meow", error: invalid input str: "inf", error: overflow [ edit ] references c++23 standard (iso/iec 14882:2024): 22.8 expected objects [expected] [ edit ] see also variant (c++17) a type-safe discriminated union (class template) [edit] optional (c++17) a wrapper that may or may not hold an object (class template) [edit] retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/expected&oldid=173498 " navigation support us recent changes faq offline version toolbox what links here related changes upload file special pages printable version permanent link page information in other languages deutsch español français italiano 日本語 português русский 中文 this page was last modified on 12 july 2024, at 05:23.  policy  cppreference.com disclaimers