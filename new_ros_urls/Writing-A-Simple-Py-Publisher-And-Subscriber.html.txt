tutorials beginner: client libraries writing a simple publisher and subscriber (python) edit on github writing a simple publisher and subscriber (python) ï goal: create and run a publisher and subscriber node using python. tutorial level: beginner time: 20 minutes background ï in this tutorial, you will create nodes that pass information in the form of string messages to each other over a topic . the example used here is a simple âtalkerâ and âlistenerâ system; one node publishes data and the other subscribes to the topic so it can receive that data. the code used in these examples can be found here . prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . a basic understanding of python is recommended, but not entirely necessary. tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate into the ros2_ws directory created in a previous tutorial . recall that packages should be created in the src directory, not the root of the workspace. so, navigate into ros2_ws/src , and run the package creation command: ros2 pkg create --build-type ament_python --license apache-2.0 py_pubsub your terminal will return a message verifying the creation of your package py_pubsub and all its necessary files and folders. 2 write the publisher node ï navigate into ros2_ws/src/py_pubsub/py_pubsub . recall that this directory is a python package with the same name as the ros 2 package itâs nested in. download the example talker code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py wget https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py -o publisher_member_function.py or in powershell: curl https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py -o publisher_member_function.py now there will be a new file named publisher_member_function.py adjacent to __init__.py . open the file using your preferred text editor. import rclpy from rclpy.node import node from std_msgs.msg import string class minimalpublisher ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_publisher' ) self . publisher_ = self . create_publisher ( string , 'topic' , 10 ) timer_period = 0.5 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 def timer_callback ( self ): msg = string () msg . data = 'hello world: %d ' % self . i self . publisher_ . publish ( msg ) self . get_logger () . info ( 'publishing: " %s "' % msg . data ) self . i += 1 def main ( args = none ): rclpy . init ( args = args ) minimal_publisher = minimalpublisher () rclpy . spin ( minimal_publisher ) # destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () 2.1 examine the code ï the first lines of code after the comments import rclpy so its node class can be used. import rclpy from rclpy.node import node the next statement imports the built-in string message type that the node uses to structure the data that it passes on the topic. from std_msgs.msg import string these lines represent the nodeâs dependencies. recall that dependencies have to be added to package.xml , which youâll do in the next section. next, the minimalpublisher class is created, which inherits from (or is a subclass of) node . class minimalpublisher ( node ): following is the definition of the classâs constructor. super().__init__ calls the node classâs constructor and gives it your node name, in this case minimal_publisher . create_publisher declares that the node publishes messages of type string (imported from the std_msgs.msg module), over a topic named topic , and that the âqueue sizeâ is 10. queue size is a required qos (quality of service) setting that limits the amount of queued messages if a subscriber is not receiving them fast enough. next, a timer is created with a callback to execute every 0.5 seconds. self.i is a counter used in the callback. def __init__ ( self ): super () . __init__ ( 'minimal_publisher' ) self . publisher_ = self . create_publisher ( string , 'topic' , 10 ) timer_period = 0.5 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 timer_callback creates a message with the counter value appended, and publishes it to the console with get_logger().info . def timer_callback ( self ): msg = string () msg . data = 'hello world: %d ' % self . i self . publisher_ . publish ( msg ) self . get_logger () . info ( 'publishing: " %s "' % msg . data ) self . i += 1 lastly, the main function is defined. def main ( args = none ): rclpy . init ( args = args ) minimal_publisher = minimalpublisher () rclpy . spin ( minimal_publisher ) # destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_publisher . destroy_node () rclpy . shutdown () first the rclpy library is initialized, then the node is created, and then it âspinsâ the node so its callbacks are called. 2.2 add dependencies ï navigate one level back to the ros2_ws/src/py_pubsub directory, where the setup.py , setup.cfg , and package.xml files have been created for you. open package.xml with your text editor. as mentioned in the previous tutorial , make sure to fill in the <description> , <maintainer> and <license> tags: <description> examples of minimal publisher/subscriber using rclpy </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> after the lines above, add the following dependencies corresponding to your nodeâs import statements: <exec_depend> rclpy </exec_depend> <exec_depend> std_msgs </exec_depend> this declares the package needs rclpy and std_msgs when its code is executed. make sure to save the file. 2.3 add an entry point ï open the setup.py file. again, match the maintainer , maintainer_ , description and license fields to your package.xml : maintainer = 'yourname' , maintainer_ = 'you@.com' , description = 'examples of minimal publisher/subscriber using rclpy' , license = 'apache-2.0' , add the following line within the console_scripts brackets of the entry_points field: entry_points = { 'console_scripts' : [ 'talker = py_pubsub.publisher_member_function:main' , ], }, donât forget to save. 2.4 check setup.cfg ï the contents of the setup.cfg file should be correctly populated automatically, like so: [develop] script_dir=base/lib/py_pubsub [install] install_scripts=base/lib/py_pubsub this is simply telling setuptools to put your executables in lib , because ros2 run will look for them there. you could build your package now, source the local setup files, and run it, but letâs create the subscriber node first so you can see the full system at work. 3 write the subscriber node ï return to ros2_ws/src/py_pubsub/py_pubsub to create the next node. enter the following code in your terminal: linux macos windows wget https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py wget https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py -o subscriber_member_function.py or in powershell: curl https://raw.githubusercontent.com/ros2/examples/jazzy/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py -o subscriber_member_function.py now the directory should have these files: __init__.py publisher_member_function.py subscriber_member_function.py 3.1 examine the code ï open the subscriber_member_function.py with your text editor. import rclpy from rclpy.node import node from std_msgs.msg import string class minimalsubscriber ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_subscriber' ) self .  = self . create_ ( string , 'topic' , self . listener_callback , 10 ) self .  # prevent unused variable warning def listener_callback ( self , msg ): self . get_logger () . info ( 'i heard: " %s "' % msg . data ) def main ( args = none ): rclpy . init ( args = args ) minimal_subscriber = minimalsubscriber () rclpy . spin ( minimal_subscriber ) # destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () the subscriber nodeâs code is nearly identical to the publisherâs. the constructor creates a subscriber with the same arguments as the publisher. recall from the topics tutorial that the topic name and message type used by the publisher and subscriber must match to allow them to communicate. self .  = self . create_ ( string , 'topic' , self . listener_callback , 10 ) the subscriberâs constructor and callback donât include any timer definition, because it doesnât need one. its callback gets called as soon as it receives a message. the callback definition simply prints an info message to the console, along with the data it received. recall that the publisher defines msg.data = 'hello world: %d' % self.i def listener_callback ( self , msg ): self . get_logger () . info ( 'i heard: " %s "' % msg . data ) the main definition is almost exactly the same, replacing the creation and spinning of the publisher with the subscriber. minimal_subscriber = minimalsubscriber () rclpy . spin ( minimal_subscriber ) since this node has the same dependencies as the publisher, thereâs nothing new to add to package.xml . the setup.cfg file can also remain untouched. 3.2 add an entry point ï reopen setup.py and add the entry point for the subscriber node below the publisherâs entry point. the entry_points field should now look like this: entry_points = { 'console_scripts' : [ 'talker = py_pubsub.publisher_member_function:main' , 'listener = py_pubsub.subscriber_member_function:main' , ], }, make sure to save the file, and then your pub/sub system should be ready. 4 build and run ï you likely already have the rclpy and std_msgs packages installed as part of your ros 2 system. itâs good practice to run rosdep in the root of your workspace ( ros2_ws ) to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you can skip ahead to next step. rosdep only runs on linux, so you can skip ahead to next step. still in the root of your workspace, ros2_ws , build your new package: linux macos windows colcon build --packages-select py_pubsub colcon build --packages-select py_pubsub colcon build --merge-install --packages-select py_pubsub open a new terminal, navigate to ros2_ws , and source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the talker node: ros2 run py_pubsub talker the terminal should start publishing info messages every 0.5 seconds, like so: [info] [minimal_publisher]: publishing: "hello world: 0" [info] [minimal_publisher]: publishing: "hello world: 1" [info] [minimal_publisher]: publishing: "hello world: 2" [info] [minimal_publisher]: publishing: "hello world: 3" [info] [minimal_publisher]: publishing: "hello world: 4" ... open another terminal, source the setup files from inside ros2_ws again, and then start the listener node: ros2 run py_pubsub listener the listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [info] [minimal_subscriber]: i heard: "hello world: 10" [info] [minimal_subscriber]: i heard: "hello world: 11" [info] [minimal_subscriber]: i heard: "hello world: 12" [info] [minimal_subscriber]: i heard: "hello world: 13" [info] [minimal_subscriber]: i heard: "hello world: 14" enter ctrl+c in each terminal to stop the nodes from spinning. summary ï you created two nodes to publish and subscribe to data over a topic. before running them, you added their dependencies and entry points to the package configuration files. next steps ï next youâll create another simple ros 2 package using the service/client model. again, you can choose to write it in either c++ or python . related content ï there are several ways you could write a publisher and subscriber in python; check out the minimal_publisher and minimal_subscriber packages in the ros2/examples repo. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling