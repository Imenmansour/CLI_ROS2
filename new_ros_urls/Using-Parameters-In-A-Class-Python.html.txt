tutorials beginner: client libraries using parameters in a class (python) edit on github using parameters in a class (python) ï goal: create and run a class with ros parameters using python. tutorial level: beginner time: 20 minutes background ï when making your own nodes you will sometimes need to add parameters that can be set from the launch file. this tutorial will show you how to create those parameters in a python class, and how to set them in a launch file. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . you have also learned  parameters and their function in a ros 2 system. tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. follow these instructions to create a new workspace named ros2_ws . recall that packages should be created in the src directory, not the root of the workspace. navigate into ros2_ws/src and create a new package: ros2 pkg create --build-type ament_python --license apache-2.0 python_parameters --dependencies rclpy your terminal will return a message verifying the creation of your package python_parameters and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml and cmakelists.txt . 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml or cmakelists.txt . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> python parameter tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 2 write the python node ï inside the ros2_ws/src/python_parameters/python_parameters directory, create a new file called python_parameters_node.py and paste the following code within: import rclpy import rclpy.node class minimalparam ( rclpy . node . node ): def __init__ ( self ): super () . __init__ ( 'minimal_param_node' ) self . declare_parameter ( 'my_parameter' , 'world' ) self . timer = self . create_timer ( 1 , self . timer_callback ) def timer_callback ( self ): my_param = self . get_parameter ( 'my_parameter' ) . get_parameter_value () . string_value self . get_logger () . info ( 'hello %s !' % my_param ) my_new_param = rclpy . parameter . parameter ( 'my_parameter' , rclpy . parameter . type . string , 'world' ) all_new_parameters = [ my_new_param ] self . set_parameters ( all_new_parameters ) def main (): rclpy . init () node = minimalparam () rclpy . spin ( node ) if __name__ == '__main__' : main () 2.1 examine the code ï the import statements at the top are used to import the package dependencies. the next piece of code creates the class and the constructor. the line self.declare_parameter('my_parameter', 'world') of the constructor creates a parameter with the name my_parameter and a default value of world . the parameter type is inferred from the default value, so in this case it would be set to a string type. next the timer is initialized with a period of 1, which causes the timer_callback function to be executed once a second. class minimalparam ( rclpy . node . node ): def __init__ ( self ): super () . __init__ ( 'minimal_param_node' ) self . declare_parameter ( 'my_parameter' , 'world' ) self . timer = self . create_timer ( 1 , self . timer_callback ) the first line of our timer_callback function gets the parameter my_parameter from the node, and stores it in my_param . next the get_logger function ensures the event is logged. the set_parameters function then sets the parameter my_parameter back to the default string value world . in the case that the user changed the parameter externally, this ensures it is always reset back to the original. def timer_callback ( self ): my_param = self . get_parameter ( 'my_parameter' ) . get_parameter_value () . string_value self . get_logger () . info ( 'hello %s !' % my_param ) my_new_param = rclpy . parameter . parameter ( 'my_parameter' , rclpy . parameter . type . string , 'world' ) all_new_parameters = [ my_new_param ] self . set_parameters ( all_new_parameters ) following the timer_callback is our main . here ros 2 is initialized, an instance of the minimalparam class is constructed, and rclpy.spin starts processing data from the node. def main (): rclpy . init () node = minimalparam () rclpy . spin ( node ) if __name__ == '__main__' : main () 2.1.1 (optional) add parameterdescriptor ï optionally, you can set a descriptor for the parameter. descriptors allow you to specify a text description of the parameter and its constraints, like making it read-only, specifying a range, etc. for that to work, the __init__ code has to be changed to: # ... class minimalparam ( rclpy . node . node ): def __init__ ( self ): super () . __init__ ( 'minimal_param_node' ) from rcl_interfaces.msg import parameterdescriptor my_parameter_descriptor = parameterdescriptor ( description = 'this parameter is mine!' ) self . declare_parameter ( 'my_parameter' , 'world' , my_parameter_descriptor ) self . timer = self . create_timer ( 1 , self . timer_callback ) the rest of the code remains the same. once you run the node, you can then run ros2 param describe /minimal_param_node my_parameter to see the type and description. 2.2 add an entry point ï open the setup.py file. again, match the maintainer , maintainer_ , description and license fields to your package.xml : maintainer = 'yourname' , maintainer_ = 'you@.com' , description = 'python parameter tutorial' , license = 'apache-2.0' , add the following line within the console_scripts brackets of the entry_points field: entry_points = { 'console_scripts' : [ 'minimal_param_node = python_parameters.python_parameters_node:main' , ], }, donât forget to save. 3 build and run ï itâs good practice to run rosdep in the root of your workspace ( ros2_ws ) to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you can skip ahead to next step. rosdep only runs on linux, so you can skip ahead to next step. navigate back to the root of your workspace, ros2_ws , and build your new package: linux macos windows colcon build --packages-select python_parameters colcon build --packages-select python_parameters colcon build --merge-install --packages-select python_parameters open a new terminal, navigate to ros2_ws , and source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the node: ros2 run python_parameters minimal_param_node the terminal should return the following message every second: [info] [parameter_node]: hello world! now you can see the default value of your parameter, but you want to be able to set it yourself. there are two ways to accomplish this. 3.1 change via the console ï this part will use the knowledge you have gained from the tutoral  parameters and apply it to the node you have just created. make sure the node is running: ros2 run python_parameters minimal_param_node open another terminal, source the setup files from inside ros2_ws again, and enter the following line: ros2 param list there you will see the custom parameter my_parameter . to change it, simply run the following line in the console: ros2 param set /minimal_param_node my_parameter earth you know it went well if you get the output set parameter successful . if you look at the other terminal, you should see the output change to [info] [minimal_param_node]: hello earth! since the node afterwards set the parameter back to world , further outputs show [info] [minimal_param_node]: hello world! 3.2 change via a launch file ï you can also set parameters in a launch file, but first you will need to add a launch directory. inside the ros2_ws/src/python_parameters/ directory, create a new directory called launch . in there, create a new file called python_parameters_launch.py from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'python_parameters' , executable = 'minimal_param_node' , name = 'custom_minimal_param_node' , output = 'screen' , emulate_tty = true , parameters = [ { 'my_parameter' : 'earth' } ] ) ]) here you can see that we set my_parameter to earth when we launch our node parameter_node . by adding the two lines below, we ensure our output is printed in our console. output="screen", emulate_tty=true, now open the setup.py file. add the import statements to the top of the file, and the other new statement to the data_files parameter to include all launch files: import os from glob import glob # ... setup ( # ... data_files = [ # ... ( os . path . join ( 'share' , package_name ), glob ( 'launch/*launch.[pxy][yma]*' )), ] ) open a console and navigate to the root of your workspace, ros2_ws , and build your new package: linux macos windows colcon build --packages-select python_parameters colcon build --packages-select python_parameters colcon build --merge-install --packages-select python_parameters then source the setup files in a new terminal: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the node using the launch file we have just created: ros2 launch python_parameters python_parameters_launch.py the terminal should return the following message the first time: [info] [custom_minimal_param_node]: hello earth! further outputs should show [info] [minimal_param_node]: hello world! every second. summary ï you created a node with a custom parameter that can be set either from a launch file or the command line. you added the dependencies, executables, and a launch file to the package configuration files so that you could build and run them, and see the parameter in action. next steps ï now that you have some packages and ros 2 systems of your own, the next tutorial will show you how to examine issues in your environment and systems in case you have problems. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling