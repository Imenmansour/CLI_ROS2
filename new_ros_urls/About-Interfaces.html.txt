concepts basic concepts interfaces edit on github interfaces ï background ï ros applications typically communicate through interfaces of one of three types: topics , services , or actions . ros 2 uses a simplified description language, the interface definition language (idl), to describe these interfaces. this description makes it easy for ros tools to automatically generate source code for the interface type in several target languages. in this document we will describe the supported types: msg: .msg files are simple text files that describe the fields of a ros message. they are used to generate source code for messages in different languages. srv: .srv files describe a service. they are composed of two parts: a request and a response. the request and response are message declarations. action: .action files describe actions. they are composed of three parts: a goal, a result, and feedback. each part is a message declaration itself. messages ï messages are a way for a ros 2 node to send data on the network to other ros nodes, with no response expected. for instance, if a ros 2 node reads temperature data from a sensor, it can then publish that data on the ros 2 network using a temperature message. other nodes on the ros 2 network can subscribe to that data and receive the temperature message. messages are described and defined in .msg files in the msg/ directory of a ros package. .msg files are composed of two parts: fields and constants. fields ï each field consists of a type and a name, separated by a space, i.e: fieldtype1 fieldname1 fieldtype2 fieldname2 fieldtype3 fieldname3 for example: int32 my_int string my_string field types ï field types can be: a built-in-type names of message descriptions defined on their own, such as âgeometry_msgs/posestampedâ built-in-types currently supported: type name c++ python dds type bool bool builtins.bool boolean byte uint8_t builtins.bytes* octet char char builtins.int* char float32 float builtins.float* float float64 double builtins.float* double int8 int8_t builtins.int* octet uint8 uint8_t builtins.int* octet int16 int16_t builtins.int* short uint16 uint16_t builtins.int* unsigned short int32 int32_t builtins.int* long uint32 uint32_t builtins.int* unsigned long int64 int64_t builtins.int* long long uint64 uint64_t builtins.int* unsigned long long string std::string builtins.str string wstring std::u16string builtins.str wstring every built-in-type can be used to define arrays: type name c++ python dds type static array std::array<t, n> builtins.list* t[n] unbounded dynamic array std::vector builtins.list sequence bounded dynamic array custom_class<t, n> builtins.list* sequence<t, n> bounded string std::string builtins.str* string all types that are more permissive than their ros definition enforce the ros constraints in range and length by software. example of message definition using arrays and bounded types: int32 [] unbounded_integer_array int32 [ 5 ] five_integers_array int32 [ < = 5 ] up_to_five_integers_array string string_of_unbounded_size string< = 10 up_to_ten_characters_string string [ < = 5 ] up_to_five_unbounded_strings string< = 10 [] unbounded_array_of_strings_up_to_ten_characters_each string< = 10 [ < = 5 ] up_to_five_strings_up_to_ten_characters_each field names ï field names must be lowercase alphanumeric characters with underscores for separating words. they must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores. field default value ï default values can be set to any field in the message type. currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages). defining a default value is done by adding a third element to the field definition line, i.e: fieldtype fieldname fielddefaultvalue for example: uint8 x 42 int16 y -2000 string full_name "john doe" int32 [] samples [ -200, -100, 0 , 100 , 200 ] note string values must be defined in single ' or double " quotes currently string values are not escaped constants ï each constant definition is like a field description with a default value, except that this value can never be changed programatically. this value assignment is indicated by use of an equal â=â sign, e.g. constanttype constantname = constantvalue for example: int32 x = 123 int32 y = -123 string foo = "foo" string example = 'bar' note constants names have to be uppercase services ï services are a request/response communication, where the client (requester) is waiting for the server (responder) to make a short computation and return a result. services are described and defined in .srv files in the srv/ directory of a ros package. a service description file consists of a request and a response msg type, separated by --- . any two .msg files concatenated with a --- are a legal service description. here is a very simple example of a service that takes in a string and returns a string: string str --- string str we can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name): # request constants int8 foo = 1 int8 bar = 2 # request fields int8 foobar another_pkg/anothermessage msg --- # response constants uint32 secret = 123456 # response fields another_pkg/yetanothermessage val custommessagedefinedinthispackage value uint32 an_integer you cannot embed another service inside of a service. actions ï actions are a long-running request/response communication, where the action client (requester) is waiting for the action server (the responder) to take some action and return a result. in contrast to services, actions can be long-running (many seconds or minutes), provide feedback while they are happening, and can be interrupted. action definitions have the following form: < request_type > < request_fieldname > --- < response_type > < response_fieldname > --- < feedback_type > < feedback_fieldname > like services, the request fields are before and the response fields are after the first triple-dash ( --- ), respectively. there is also a third set of fields after the second triple-dash, which is the fields to be sent when sending feedback. there can be arbitrary numbers of request fields (including zero), arbitrary numbers of response fields (including zero), and arbitrary numbers of feedback fields (including zero). the <request_type> , <response_type> , and <feedback_type> follow all of the same rules as the <type> for a message. the <request_fieldname> , <response_fieldname> , and <feedback_fieldname> follow all of the same rules as the <fieldname> for a message. for instance, the fibonacci action definition contains the following: int32 order --- int32 [] sequence --- int32 [] sequence this is an action definition where the action client is sending a single int32 field representing the number of fibonacci steps to take, and expecting the action server to produce an array of int32 containing the complete steps. along the way, the action server may also provide an intermediate array of int32 containing the steps accomplished up until a certain point. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling