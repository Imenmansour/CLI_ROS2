tutorials intermediate writing a composable node (c++) edit on github writing a composable node (c++) ï starting place ï letâs assume that you have a regular rclcpp::node executable that you want to run in the same process as other nodes to enable more efficient communication. weâll start from having a class that directly inherits from node , and that also has a main method defined. namespace palomino { class vincentdriver : public rclcpp :: node { // ... }; } int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < palomino :: vincentdriver > ()); rclcpp :: shutdown (); return 0 ; } this will typically be compiled as an executable in your cmake. # ... add_executable ( vincent_driver src/vincent_driver.cpp ) # ... install ( targets vincent_driver destination lib/ { project_name } ) code updates ï add the package dependency ï your package.xml should have a dependency on rclcpp_components , a la <depend> rclcpp_components </depend> alternatively, you can independently add a build_depend/exec_depend . class definition ï the only change to your class definition that you may have to do is ensure that the constructor for the class takes a nodeoptions argument. vincentdriver ( const rclcpp :: nodeoptions & options ) : node ( "vincent_driver" , options ) { // ... } no more main method ï replace your main method with a pluginlib -style macro invocation. #include <rclcpp_components/register_node_macro.hpp> rclcpp_components_register_node ( palomino :: vincentdriver ) caution if the main method you are replacing contains a multithreadedexecutor , be sure to make note and ensure that your container node is multithreaded. see section below. cmake changes ï first, add rclcpp_components as a dependency in your cmakelists.txt with: find_package ( rclcpp_components required ) second, weâre going to replace our add_executable with a add_library with a new target name. add_library ( vincent_driver_component src/vincent_driver.cpp ) third, replace other build commands that used the old target to act on the new target. i.e. ament_target_dependencies(vincent_driver ...) becomes ament_target_dependencies(vincent_driver_component ...) fourth, add a new command to declare your component. rclcpp_components_register_node ( vincent_driver_component plugin "palomino::vincentdriver" executable vincent_driver ) fifth and finally, change any installation commands in the cmake that operated on the old target to install the library version instead. for instance, do not install either target into lib/{project_name} . replace with the library installation. ament_export_targets ( export_vincent_driver_component ) install ( targets vincent_driver_component export export_vincent_driver_component archive destination lib library destination lib runtime destination bin ) running your node ï see the composition tutorial for an in-depth look at composing nodes. the quick and dirty version is that if you had the following in your python launch file, from launch_ros.actions import node # .. ld . add_action ( node ( package = 'palomino' , executable = 'vincent_driver' , # .. )) you can replace it with from launch_ros.actions import composablenodecontainer from launch_ros.descriptions import composablenode # .. ld . add_action ( composablenodecontainer ( name = 'a_buncha_nodes' , namespace = '' , package = 'rclcpp_components' , executable = 'component_container' , composable_node_descriptions = [ composablenode ( package = 'palomino' , plugin = 'palomino::vincentdriver' , name = 'vincent_driver' , # .. extra_arguments = [{ 'use_intra_process_comms' : true }], ), ] )) caution if you need multi-threading, instead of setting your executable to component_container , set it to component_container_mt other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling