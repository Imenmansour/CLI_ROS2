tutorials advanced simulators webots setting up a robot simulation (basic) edit on github setting up a robot simulation (basic) ï goal: setup a robot simulation and control it from ros 2. tutorial level: advanced time: 30 minutes background ï in this tutorial, you are going to use the webots robot simulator to set-up and run a very simple ros 2 simulation scenario. the webots_ros2 package provides an interface between ros 2 and webots. it includes several sub-packages, but in this tutorial, you are going to use only the webots_ros2_driver sub-package to implement a python or c++ plugin controlling a simulated robot. some other sub-packages contain demos with different robots such as the turtlebot3. they are documented in the webots ros 2 examples page. prerequisites ï it is recommended to understand basic ros principles covered in the beginner tutorials . in particular, using turtlesim, ros2, and rqt , understanding topics , creating a workspace , creating a package and creating a launch file are useful prerequisites. linux windows macos the linux and ros commands of this tutorial can be run in a standard linux terminal. the following page installation (ubuntu) explains how to install the webots_ros2 package on linux. the linux and ros commands of this tutorial must be run in a wsl (windows subsystem for linux) environment. the following page installation (windows) explains how to install the webots_ros2 package on windows. the linux and ros commands of this tutorial must be run in a pre-configured linux virtual machine (vm). the following page installation (macos) explains how to install the webots_ros2 package on macos. this tutorial is compatible with version 2023.1.0 of webots_ros2 and webots r2023b, as well as upcoming versions. tasks ï 1 create the package structure ï letâs organize the code in a custom ros 2 package. create a new package named my_package from the src folder of your ros 2 workspace. change the current directory of your terminal to ros2_ws/src and run: python c++ ros2 pkg create --build-type ament_python --license apache-2.0 --node-name my_robot_driver my_package --dependencies rclpy geometry_msgs webots_ros2_driver the --node-name my_robot_driver option will create a my_robot_driver.py template python plugin in the my_package subfolder that you will modify later. the --dependencies rclpy geometry_msgs webots_ros2_driver option specifies the packages needed by the my_robot_driver.py plugin in the package.xml file. letâs add a launch and a worlds folder inside the my_package folder. cd my_package mkdir launch mkdir worlds you should end up with the following folder structure: src/ âââ my_package/ âââ launch/ âââ my_package/ â âââ __init__.py â âââ my_robot_driver.py âââ resource/ â âââ my_package âââ test/ â âââ test_.py â âââ test_flake8.py â âââ test_pep257.py âââ worlds/ âââ package.xml âââ setup.cfg âââ setup.py ros2 pkg create --build-type ament_cmake --license apache-2.0 --node-name myrobotdriver my_package --dependencies rclcpp geometry_msgs webots_ros2_driver pluginlib the --node-name myrobotdriver option will create a myrobotdriver.cpp template c++ plugin in the my_package/src subfolder that you will modify later. the --dependencies rclcpp geometry_msgs webots_ros2_driver pluginlib option specifies the packages needed by the myrobotdriver plugin in the package.xml file. letâs add a launch , a worlds and a resource folder inside the my_package folder. cd my_package mkdir launch mkdir worlds mkdir resource two additional files must be created: the header file for myrobotdriver and the my_robot_driver.xml pluginlib description file. touch my_robot_driver.xml touch include/my_package/myrobotdriver.hpp you should end up with the following folder structure: src/ âââ my_package/ âââ include/ â âââ my_package/ â âââ myrobotdriver.hpp âââ launch/ âââ resource/ âââ src/ â âââ myrobotdriver.cpp âââ worlds/ âââ cmakelist.txt âââ my_robot_driver.xml âââ package.xml 2 setup the simulation world ï you will need a world file containing a robot to launch your simulation. download this world file and move it inside my_package/worlds/ . this is actually a fairly simple text file you can visualize in a text editor. a simple robot is already included in this my_world.wbt world file. note in case you want to learn how to create your own robot model in webots, you can check this tutorial . 3 edit the my_robot_driver plugin ï the webots_ros2_driver sub-package automatically creates a ros 2 interface for most sensors. more details on existing device interfaces and how to configure them is given in the second part of the tutorial: setting up a robot simulation (advanced) . in this task, you will extend this interface by creating your own custom plugin. this custom plugin is a ros node equivalent to a robot controller. you can use it to access the webots robot api and create your own topics and services to control your robot. note the purpose of this tutorial is to show a basic example with a minimum number of dependencies. however, you could avoid the use of this plugin by using another webots_ros2 sub-package named webots_ros2_control , introducing a new dependency. this other sub-package creates an interface with the ros2_control package that facilitates the control of a differential wheeled robot. python c++ open my_package/my_package/my_robot_driver.py in your favorite editor and replace its contents with the following: import rclpy from geometry_msgs.msg import twist half_distance_between_wheels = 0.045 wheel_radius = 0.025 class myrobotdriver : def init ( self , webots_node , properties ): self . __robot = webots_node . robot self . __left_motor = self . __robot . getdevice ( 'left wheel motor' ) self . __right_motor = self . __robot . getdevice ( 'right wheel motor' ) self . __left_motor . setposition ( float ( 'inf' )) self . __left_motor . setvelocity ( 0 ) self . __right_motor . setposition ( float ( 'inf' )) self . __right_motor . setvelocity ( 0 ) self . __target_twist = twist () rclpy . init ( args = none ) self . __node = rclpy . create_node ( 'my_robot_driver' ) self . __node . create_ ( twist , 'cmd_vel' , self . __cmd_vel_callback , 1 ) def __cmd_vel_callback ( self , twist ): self . __target_twist = twist def step ( self ): rclpy . spin_once ( self . __node , timeout_sec = 0 ) forward_speed = self . __target_twist . linear . x angular_speed = self . __target_twist . angular . z command_motor_left = ( forward_speed - angular_speed * half_distance_between_wheels ) / wheel_radius command_motor_right = ( forward_speed + angular_speed * half_distance_between_wheels ) / wheel_radius self . __left_motor . setvelocity ( command_motor_left ) self . __right_motor . setvelocity ( command_motor_right ) as you can see, the myrobotdriver class implements three methods. the first method, named init(self, ...) , is actually the ros node counterpart of the python __init__(self, ...) constructor. the init method always takes two arguments: the webots_node argument contains a reference on the webots instance. the properties argument is a dictionary created from the xml tags given in the urdf files ( 4 create the my_robot.urdf file ) and allows you to pass parameters to the controller. the robot instance from the simulation self.__robot can be used to access the webots robot api . then, it gets the two motor instances and initializes them with a target position and a target velocity. finally a ros node is created and a callback method is registered for a ros topic named /cmd_vel that will handle twist messages. def init ( self , webots_node , properties ): self . __robot = webots_node . robot self . __left_motor = self . __robot . getdevice ( 'left wheel motor' ) self . __right_motor = self . __robot . getdevice ( 'right wheel motor' ) self . __left_motor . setposition ( float ( 'inf' )) self . __left_motor . setvelocity ( 0 ) self . __right_motor . setposition ( float ( 'inf' )) self . __right_motor . setvelocity ( 0 ) self . __target_twist = twist () rclpy . init ( args = none ) self . __node = rclpy . create_node ( 'my_robot_driver' ) self . __node . create_ ( twist , 'cmd_vel' , self . __cmd_vel_callback , 1 ) then comes the implementation of the __cmd_vel_callback(self, twist) callback private method that will be called for each twist message received on the /cmd_vel topic and will save it in the self.__target_twist member variable. def __cmd_vel_callback ( self , twist ): self . __target_twist = twist finally, the step(self) method is called at every time step of the simulation. the call to rclpy.spin_once() is needed to keep the ros node running smoothly. at each time step, the method will retrieve the desired forward_speed and angular_speed from self.__target_twist . as the motors are controlled with angular velocities, the method will then convert the forward_speed and angular_speed into individual commands for each wheel. this conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them. def step ( self ): rclpy . spin_once ( self . __node , timeout_sec = 0 ) forward_speed = self . __target_twist . linear . x angular_speed = self . __target_twist . angular . z command_motor_left = ( forward_speed - angular_speed * half_distance_between_wheels ) / wheel_radius command_motor_right = ( forward_speed + angular_speed * half_distance_between_wheels ) / wheel_radius self . __left_motor . setvelocity ( command_motor_left ) self . __right_motor . setvelocity ( command_motor_right ) open my_package/include/my_package/myrobotdriver.hpp in your favorite editor and replace its contents with the following: #ifndef webots_ros2_plugin_example_hpp #define webots_ros2_plugin_example_hpp #include "rclcpp/macros.hpp" #include "webots_ros2_driver/plugininterface.hpp" #include "webots_ros2_driver/webotsnode.hpp" #include "geometry_msgs/msg/twist.hpp" #include "rclcpp/rclcpp.hpp" namespace my_robot_driver { class myrobotdriver : public webots_ros2_driver :: plugininterface { public : void step () override ; void init ( webots_ros2_driver :: webotsnode * node , std :: unordered_map < std :: string , std :: string > & parameters ) override ; private : rclcpp ::  < geometry_msgs :: msg :: twist >:: sharedptr cmd_vel__ ; geometry_msgs :: msg :: twist cmd_vel_msg ; wbdevicetag right_motor ; wbdevicetag left_motor ; }; } // namespace my_robot_driver #endif the class myrobotdriver is defined, which inherits from the webots_ros2_driver::plugininterface class. the plugin has to override step(...) and init(...) functions. more details are given in the myrobotdriver.cpp file. several helper methods, callbacks and member variables that will be used internally by the plugin are declared privately. then, open my_package/src/myrobotdriver.cpp in your favorite editor and replace its contents with the following: #include "my_package/myrobotdriver.hpp" #include "rclcpp/rclcpp.hpp" #include <cstdio> #include <functional> #include <webots/motor.h> #include <webots/robot.h> #define half_distance_between_wheels 0.045 #define wheel_radius 0.025 namespace my_robot_driver { void myrobotdriver::init ( webots_ros2_driver :: webotsnode * node , std :: unordered_map < std :: string , std :: string > & parameters ) { right_motor = wb_robot_get_device ( "right wheel motor" ); left_motor = wb_robot_get_device ( "left wheel motor" ); wb_motor_set_position ( left_motor , infinity ); wb_motor_set_velocity ( left_motor , 0.0 ); wb_motor_set_position ( right_motor , infinity ); wb_motor_set_velocity ( right_motor , 0.0 ); cmd_vel__ = node -> create_ < geometry_msgs :: msg :: twist > ( "/cmd_vel" , rclcpp :: sensordataqos (). reliable (), [ this ]( const geometry_msgs :: msg :: twist :: sharedptr msg ){ this -> cmd_vel_msg . linear = msg -> linear ; this -> cmd_vel_msg . angular = msg -> angular ; } ); } void myrobotdriver::step () { auto forward_speed = cmd_vel_msg . linear . x ; auto angular_speed = cmd_vel_msg . angular . z ; auto command_motor_left = ( forward_speed - angular_speed * half_distance_between_wheels ) / wheel_radius ; auto command_motor_right = ( forward_speed + angular_speed * half_distance_between_wheels ) / wheel_radius ; wb_motor_set_velocity ( left_motor , command_motor_left ); wb_motor_set_velocity ( right_motor , command_motor_right ); } } // namespace my_robot_driver #include "pluginlib/class_list_macros.hpp" pluginlib_export_class ( my_robot_driver :: myrobotdriver , webots_ros2_driver :: plugininterface ) the myrobotdriver::init method is executed once the plugin is loaded by the webots_ros2_driver package. it takes two arguments: a pointer to the webotsnode defined by webots_ros2_driver , which allows to access the ros 2 node functions. the parameters argument is an unordered map of strings, created from the xml tags given in the urdf files ( 4 create the my_robot.urdf file ) and allows to pass parameters to the controller. it is not used in this example. it initializes the plugin by setting up the robot motors, setting their positions and velocities, and subscribing to the /cmd_vel topic. void myrobotdriver::init ( webots_ros2_driver :: webotsnode * node , std :: unordered_map < std :: string , std :: string > & parameters ) { right_motor = wb_robot_get_device ( "right wheel motor" ); left_motor = wb_robot_get_device ( "left wheel motor" ); wb_motor_set_position ( left_motor , infinity ); wb_motor_set_velocity ( left_motor , 0.0 ); wb_motor_set_position ( right_motor , infinity ); wb_motor_set_velocity ( right_motor , 0.0 ); cmd_vel__ = node -> create_ < geometry_msgs :: msg :: twist > ( "/cmd_vel" , rclcpp :: sensordataqos (). reliable (), [ this ]( const geometry_msgs :: msg :: twist :: sharedptr msg ){ this -> cmd_vel_msg . linear = msg -> linear ; this -> cmd_vel_msg . angular = msg -> angular ; } ); } the  callback is declared as a lambda function, that will be called for each twist message received on the /cmd_vel topic and will save it in the cmd_vel_msg member variable. [ this ]( const geometry_msgs :: msg :: twist :: sharedptr msg ){ this -> cmd_vel_msg . linear = msg -> linear ; this -> cmd_vel_msg . angular = msg -> angular ; } the step() method is called at every time step of the simulation. at each time step, the method will retrieve the desired forward_speed and angular_speed from cmd_vel_msg . as the motors are controlled with angular velocities, the method will then convert the forward_speed and angular_speed into individual commands for each wheel. this conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them. void myrobotdriver::step () { auto forward_speed = cmd_vel_msg . linear . x ; auto angular_speed = cmd_vel_msg . angular . z ; auto command_motor_left = ( forward_speed - angular_speed * half_distance_between_wheels ) / wheel_radius ; auto command_motor_right = ( forward_speed + angular_speed * half_distance_between_wheels ) / wheel_radius ; wb_motor_set_velocity ( left_motor , command_motor_left ); wb_motor_set_velocity ( right_motor , command_motor_right ); } the final lines of the file define the end of the my_robot_driver namespace and include a macro to export the myrobotdriver class as a plugin using the pluginlib_export_class macro. this allows the plugin to be loaded by the webots ros2 driver at runtime. #include "pluginlib/class_list_macros.hpp" pluginlib_export_class ( my_robot_driver :: myrobotdriver , webots_ros2_driver :: plugininterface ) note while the plugin is implemented in c++, the c api must be used to interact with the webots controller library. 4 create the my_robot.urdf file ï you now have to create a urdf file to declare the myrobotdriver plugin. this will allow the webots_ros2_driver ros node to launch the plugin and connect it to the target robot. in the my_package/resource folder create a text file named my_robot.urdf with this content: python c++ <?xml version="1.0" ?> <robot name= "my robot" > <webots> <plugin type= "my_package.my_robot_driver.myrobotdriver" /> </webots> </robot> the type attribute specifies the path to the class given by the hierarchical structure of files. webots_ros2_driver is responsible for loading the class based on the specified package and modules. <?xml version="1.0" ?> <robot name= "my robot" > <webots> <plugin type= "my_robot_driver::myrobotdriver" /> </webots> </robot> the type attribute specifies the namespace and class name to load. pluginlib is responsible for loading the class based on the specified information. note this simple urdf file doesnât contain any link or joint information  the robot as it is not needed in this tutorial. however, urdf files usually contain much more information as explained in the urdf tutorial. note here the plugin does not take any input parameter, but this can be achieved with a tag containing the parameter name. python c++ <plugin type= "my_package.my_robot_driver.myrobotdriver" > <parametername> somevalue </parametername> </plugin> <plugin type= "my_robot_driver::myrobotdriver" > <parametername> somevalue </parametername> </plugin> this is namely used to pass parameters to existing webots device plugins (see setting up a robot simulation (advanced) ). 5 create the launch file ï letâs create the launch file to easily launch the simulation and the ros controller with a single command. in the my_package/launch folder create a new text file named robot_launch.py with this code: import os import launch from launch import launchdescription from ament_index_python.packages import get_package_share_directory from webots_ros2_driver.webots_launcher import webotslauncher from webots_ros2_driver.webots_controller import webotscontroller def generate_launch_description (): package_dir = get_package_share_directory ( 'my_package' ) robot_description_path = os . path . join ( package_dir , 'resource' , 'my_robot.urdf' ) webots = webotslauncher ( world = os . path . join ( package_dir , 'worlds' , 'my_world.wbt' ) ) my_robot_driver = webotscontroller ( robot_name = 'my_robot' , parameters = [ { 'robot_description' : robot_description_path }, ] ) return launchdescription ([ webots , my_robot_driver , launch . actions . registereventhandler ( event_handler = launch . event_handlers . onprocessexit ( target_action = webots , on_exit = [ launch . actions . emitevent ( event = launch . events . shutdown ())], ) ) ]) the webotslauncher object is a custom action that allows you to start a webots simulation instance. you have to specify in the constructor which world file the simulator will open. webots = webotslauncher ( world = os . path . join ( package_dir , 'worlds' , 'my_world.wbt' ) ) then, the ros node interacting with the simulated robot is created. this node, named webotscontroller , is located in the webots_ros2_driver package. linux windows macos the node will be able to communicate with the simulated robot by using a custom protocol based on ipc and shared memory. the node (in wsl) will be able to communicate with the simulated robot (in webots on native windows) through a tcp connection. the node (in the docker container) will be able to communicate with the simulated robot (in webots on native macos) through a tcp connection. in your case, you need to run a single instance of this node, because you have a single robot in the simulation. but if you had more robots in the simulation, you would have to run one instance of this node per robot. the robot_name parameter is used to define the name of the robot the driver should connect to. the robot_description parameter holds the path to the urdf file which refers to the myrobotdriver plugin. you can see the webotscontroller node as the interface that connects your controller plugin to the target robot. my_robot_driver = webotscontroller ( robot_name = 'my_robot' , parameters = [ { 'robot_description' : robot_description_path }, ] ) after that, the two nodes are set to be launched in the launchdescription constructor: return launchdescription ([ webots , my_robot_driver , finally, an optional part is added in order to shutdown all the nodes once webots terminates (e.g., when it gets closed from the graphical user interface). launch . actions . registereventhandler ( event_handler = launch . event_handlers . onprocessexit ( target_action = webots , on_exit = [ launch . actions . emitevent ( event = launch . events . shutdown ())], ) ) note more details on webotscontroller and webotslauncher arguments can be found on the nodes reference page . 6 edit additional files ï python c++ before you can start the launch file, you have to modify the setup.py file to include the extra files you added. open my_package/setup.py and replace its contents with: from setuptools import find_packages , setup package_name = 'my_package' data_files = [] data_files . append (( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ])) data_files . append (( 'share/' + package_name + '/launch' , [ 'launch/robot_launch.py' ])) data_files . append (( 'share/' + package_name + '/worlds' , [ 'worlds/my_world.wbt' ])) data_files . append (( 'share/' + package_name + '/resource' , [ 'resource/my_robot.urdf' ])) data_files . append (( 'share/' + package_name , [ 'package.xml' ])) setup ( name = package_name , version = '0.0.0' , packages = find_packages ( exclude = [ 'test' ]), data_files = data_files , install_requires = [ 'setuptools' ], zip_safe = true , maintainer = 'user' , maintainer_ = 'user.name@mail.com' , description = 'todo: package description' , license = 'todo: license declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'my_robot_driver = my_package.my_robot_driver:main' , ], }, ) this sets-up the package and adds in the data_files variable the newly added files: my_world.wbt , my_robot.urdf and robot_launch.py . before you can start the launch file, you have to modify cmakelists.txt and my_robot_driver.xml files: cmakelists.txt defines the compilation rules of your plugin. my_robot_driver.xml is necessary for the pluginlib to find your webots ros 2 plugin. open my_package/my_robot_driver.xml and replace its contents with: <library path= "my_package" > <!-- the `type` attribute is a reference to the plugin class. --> <!-- the `base_class_type` attribute is always `webots_ros2_driver::plugininterface`. --> <class type= "my_robot_driver::myrobotdriver" base_class_type= "webots_ros2_driver::plugininterface" > <description> this is a webots ros 2 plugin example </description> </class> </library> open my_package/cmakelists.txt and replace its contents with: cmake_minimum_required ( version 3.5 ) project ( my_package ) if ( not cmake_cxx_standard ) set ( cmake_cxx_standard 14 ) endif () # besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver` find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( std_msgs required ) find_package ( geometry_msgs required ) find_package ( pluginlib required ) find_package ( webots_ros2_driver required ) # export the plugin configuration file pluginlib_export_plugin_description_file ( webots_ros2_driver my_robot_driver.xml ) # myrobotdriver library add_library ( { project_name } shared src/myrobotdriver.cpp ) target_include_directories ( { project_name } private include ) ament_target_dependencies ( { project_name } pluginlib rclcpp webots_ros2_driver ) install ( targets { project_name } archive destination lib library destination lib runtime destination bin ) # install additional directories. install ( directory launch resource worlds destination share/ { project_name } / ) ament_export_include_directories ( include ) ament_export_libraries ( { project_name } ) ament_package () the cmakelists.txt exports the plugin configuration file with the pluginlib_export_plugin_description_file() , defines a shared library of the c++ plugin src/myrobotdriver.cpp , and sets the include and library dependencies using ament_target_dependencies() . the file then installs the library, the directories launch , resource , and worlds to the share/my_package directory. finally, it exports the include directories and libraries using ament_export_include_directories() and ament_export_libraries() , respectively, and declares the package using ament_package() . 7 test the code ï linux windows macos from a terminal in your ros 2 workspace run: colcon build source install/local_setup.bash ros2 launch my_package robot_launch.py this will launch the simulation. webots will be automatically installed on the first run in case it was not already installed. from a terminal in your wsl ros 2 workspace run: colcon build export webots_home=/mnt/c/program\ files/webots source install/local_setup.bash ros2 launch my_package robot_launch.py be sure to use the /mnt prefix in front of your path to the webots installation folder to access the windows file system from wsl. this will launch the simulation. webots will be automatically installed on the first run in case it was not already installed. on macos, a local server must be started on the host to start webots from the vm. the local server can be downloaded on the webots-server repository . in a terminal of the host machine (not in the vm), specify the webots installation folder (e.g. /applications/webots.app ) and start the server using the following commands: export webots_home=/applications/webots.app python3 local_simulation_server.py from a terminal in the linux vm in your ros 2 workspace, build and launch your custom package with: colcon build source install/local_setup.bash ros2 launch my_package robot_launch.py note if you want to install webots manually, you can download it here . then, open a second terminal and send a command with: ros2 topic pub /cmd_vel geometry_msgs/twist "linear: { x: 0.1 }" the robot is now moving forward. at this point, the robot is able to blindly follow your motor commands. but it will eventually bump into the wall as you order it to move forwards. close the webots window, this should also shutdown your ros nodes started from the launcher. close also the topic command with ctrl+c in the second terminal. summary ï in this tutorial, you set-up a realistic robot simulation with webots and implemented a custom plugin to control the motors of the robot. next steps ï to improve the simulation, the robotâs sensors can be used to detect obstacles and avoid them. the second part of the tutorial shows how to implement such behaviour: setting up a robot simulation (advanced) . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling