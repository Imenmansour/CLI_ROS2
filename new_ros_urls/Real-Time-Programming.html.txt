tutorials demos understanding real-time programming edit on github understanding real-time programming ï background ï real-time computing is a key feature of many robotics systems, particularly safety- and mission-critical applications such as autonomous vehicles, spacecrafts, and industrial manufacturing. we are deg and prototyping ros 2 with real-time performance constraints in mind, since this is a requirement that was not considered in the early stages of ros 1 and it is now intractable to refactor ros 1 to be real-time friendly. this document outlines the requirements of real-time computing and best practices for software engineers. in short: to make a real-time computer system, our real-time loop must update periodically to meet deadlines. we can only tolerate a small margin of error on these deadlines (our maximum allowable jitter). to do this, we must avoid nondeterministic operations in the execution path, things like: pagefault events, dynamic memory allocation/deallocation, and synchronization primitives that block indefinitely. a classic example of a controls problem commonly solved by real-time computing is balancing an inverted pendulum . if the controller blocked for an unexpectedly long amount of time, the pendulum would fall down or go unstable. but if the controller reliably updates at a rate faster than the motor controlling the pendulum can operate, the pendulum will successfully adapt react to sensor data to balance the pendulum. now that you know everything  real-time computing, letâs try a demo! install and run the demo ï the real-time demo was written with linux operating systems in mind, since many members of the ros community doing real-time computing use xenomai or rt_preempt as their real-time solutions. since many of the operations done in the demo to optimize performance are os-specific, the demo only builds and runs on linux systems. so, if you are an osx or windows user, donât try this part! also this must be built from source using a static dds api. currently the only supported implementation is connext . first, follow the instructions to build ros 2 from source using connext dds as the middleware. run the tests ï before you run make sure you have at least 8gb of ram free. with the memory locking, swap will not work anymore. source your ros 2 setup.bash. run the demo binary, and redirect the output. you may want to use sudo in case you get permission error: pendulum_demo > output.txt what the heck just happened? ï first, even though you redirected stdout, you will see some output to the console (from stderr): mlockall failed : cannot allocate memory couldn 't lock all cached virtual memory. pagefaults from reading pages not yet mapped into ram will be recorded . after the initialization stage of the demo program, it will attempt to lock all cached memory into ram and prevent future dynamic memory allocations using mlockall . this is to prevent pagefaults from loading lots of new memory into ram. (see the realtime design article for more information.) the demo will continue on as usual when this occurs. at the bottom of the output.txt file generated by the demo, youâll see the number of pagefaults encountered during execution: rttest statistics : - minor pagefaults : 20 - major pagefaults : 0 if we want those pagefaults to go away, weâll have toâ adjust permissions for memory locking ï add to /etc/security/limits.conf (as sudo): < your username > - memlock < limit in kb > a limit of -1 is unlimited. if you choose this, you may need to accompany it with ulimit -l unlimited (as root) after editing the file. after saving the file, log out and log back in. then rerun the pendulum_demo invocation. youâll either see zero pagefaults in your output file, or an error saying that a bad_alloc exception was caught. if this happened, you didnât have enough free memory available to lock the memory allocated for the process into ram. youâll need to install more ram in your computer to see zero pagefaults! output overview ï to see more output, we have to run the pendulum_logger node. in one shell with your install/setup.bash sourced, invoke: pendulum_logger you should see the output message: logger node initialized . in another shell with setup.bash sourced, invoke pendulum_demo again. as soon as this executable starts, you should see the other shell constantly printing output: commanded motor angle : 1.570796 actual motor angle : 1.570796 mean latency : 210144.000000 ns min latency : 4805 ns max latency : 578137 ns minor pagefaults during execution : 0 major pagefaults during execution : 0 the demo is controlling a very simple inverted pendulum simulation. the pendulum simulation calculates its position in its own thread. a ros node simulates a motor encoder sensor for the pendulum and publishes its position. another ros node acts as a simple pid controller and calculates the next command message. the logger node periodically prints out the pendulumâs state and the runtime performance statistics of the demo during its execution phase. after the pendulum_demo is finished, youâll have to ctrl-c out of the logger node to exit. latency ï at the pendulum_demo execution, youâll see the final statistics collected for the demo: rttest statistics : - minor pagefaults : 0 - major pagefaults : 0 latency ( time after deadline was missed ): - min : 3354 ns - max : 2752187 ns - mean : 19871.8 ns - standard deviation : 1.35819e+08 pendulummotor received 985 messages pendulumcontroller received 987 messages the latency fields show you the minimum, maximum, and average latency of the update loop in nanoseconds. here, latency means the amount of time after the update was expected to occur. the requirements of a real-time system depend on the application, but letâs say in this demo we have a 1khz (1 millisecond) update loop, and weâre aiming for a maximum allowable latency of 5% of our update period. so, our average latency was really good in this run, but the maximum latency was unacceptable because it actually exceeded our update loop! what happened? we may be suffering from a non-deterministic scheduler. if youâre running a vanilla linux system and you donât have the rt_preempt kernel installed, you probably wonât be able to meet the real-time goal we set for ourselves, because the linux scheduler wonât allow you to arbitrarily pre-empt threads at the user level. see the realtime design article for more information. the demo attempts to set the scheduler and thread priority of the demo to be suitable for real-time performance. if this operation failed, youâll see an error message: âcouldnât set scheduling priority and policy: operation not permittedâ. you can get slightly better performance by following the instructions in the next section: setting permissions for the scheduler ï add to /etc/security/limits.conf (as sudo): < your username > - rtprio 98 the range of the rtprio (real-time priority) field is 0-99. however, do not set the limit to 99 because then your processes could interfere with important system processes that run at the top priority (e.g. watchdog). this demo will attempt to run the control loop at priority 98. plotting results ï you can plot the latency and pagefault statistics that are collected in this demo after the demo runs. because the code has been instrumented with rttest , there are useful command line arguments available: command description default value -i specify how many iterations to run the real-time loop 1000 -u specify the update period with the default unit being microseconds. use the suffix âsâ for seconds, âmsâ for milliseconds, âusâ for microseconds, and ânsâ for nanoseconds. 1ms -f specify the name of the file for writing the collected data. run the demo again with a filename to save results: pendulum_demo -f pendulum_demo_results then run the rttest_plot script on the resulting file: ros2 run rttest rttest_plot pendulum_demo_results this script will produce a number of files: pendulum_demo_results_plot_latency . svg pendulum_demo_results_plot_latency_hist . svg pendulum_demo_results_plot_majflts . svg pendulum_demo_results_plot_minflts . svg you can view these plots in an image viewer of your choice. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling