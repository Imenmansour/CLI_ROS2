tutorials intermediate urdf building a visual robot model from scratch edit on github building a visual robot model from scratch ï goal: learn how to build a visual model of a robot that you can view in rviz tutorial level: intermediate time: 20 minutes note this tutorial assumes you know how to write well-formatted xml code in this tutorial, weâre going to build a visual model of a robot that vaguely looks like r2d2. in later tutorials, youâll learn how to articulate the model , add in some physical properties , and generate neater code with xacro , but for now, weâre going to focus on getting the visual geometry correct. before continuing, make sure you have the joint_state_publisher package installed. if you installed urdf_tutorial binaries, this should already be the case. if not,  update your installation to include that package (use rosdep to check). all of the robot models mentioned in this tutorial (and the source files) can be found in the urdf_tutorial package. one shape ï first, weâre just going to explore one simple shape. hereâs  as simple as a urdf as you can make. [source: 01-myfirst.urdf] <?xml version="1.0"?> <robot name= "myfirst" > <link name= "base_link" > <visual> <geometry> <cylinder length= "0.6" radius= "0.2" /> </geometry> </visual> </link> </robot> to translate the xml into english, this is a robot with the name myfirst , that contains only one link (a.k.a. part), whose visual component is just a cylinder 0.6 meters long with a 0.2 meter radius. this may seem like a lot of enclosing tags for a simple âhello worldâ type example, but it will get more complicated, trust me. to examine the model, launch the display.launch.py file: ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf this does three things: loads the specified model and saves it as a parameter for the robot_state_publisher node. runs nodes to publish sensor_msgs/msg/jointstate and transforms (more on these later) starts rviz with a configuration file after launching display.launch.py , you should end up with rviz showing you the following: things to note: the fixed frame is the transform frame where the center of the grid is located. here, itâs a frame defined by our one link, base_link. the visual element (the cylinder) has its origin at the center of its geometry as a default. hence, half the cylinder is below the grid. multiple shapes ï now letâs look at how to add multiple shapes/links. if we just add more link elements to the urdf, the parser wonât know where to put them. so, we have to add joints. joint elements can refer to both flexible and inflexible joints. weâll start with inflexible, or fixed joints. [source: 02-multipleshapes.urdf] <?xml version="1.0"?> <robot name= "multipleshapes" > <link name= "base_link" > <visual> <geometry> <cylinder length= "0.6" radius= "0.2" /> </geometry> </visual> </link> <link name= "right_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> </visual> </link> <joint name= "base_to_right_leg" type= "fixed" > <parent link= "base_link" /> <child link= "right_leg" /> </joint> </robot> note how we defined a 0.6m x 0.1m x 0.2m box the joint is defined in  of a parent and a child. urdf is ultimately a tree structure with one root link. this means that the legâs position is dependent on the base_linkâs position. ros2 launch urdf_tutorial display.launch.py model:=urdf/02-multipleshapes.urdf both of the shapes overlap with each other, because they share the same origin. if we want them not to overlap we must define more origins. origins ï r2d2âs leg attaches to the top half of his torso, on the side. so thatâs where we specify the origin of the joint to be. also, it doesnât attach to the middle of the leg, it attaches to the upper part, so we must offset the origin for the leg as well. we also rotate the leg so it is upright. [source: 03-origins.urdf] <?xml version="1.0"?> <robot name= "origins" > <link name= "base_link" > <visual> <geometry> <cylinder length= "0.6" radius= "0.2" /> </geometry> </visual> </link> <link name= "right_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> <origin rpy= "0 1.57075 0" xyz= "0 0 -0.3" /> </visual> </link> <joint name= "base_to_right_leg" type= "fixed" > <parent link= "base_link" /> <child link= "right_leg" /> <origin xyz= "0 -0.22 0.25" /> </joint> </robot> letâs start by examining the jointâs origin. it is defined in  of the parentâs reference frame. so we are -0.22 meters in the y direction (to our left, but to the right relative to the axes) and 0.25 meters in the z direction (up). this means that the origin for the child link will be up and to the right, regardless of the child linkâs visual origin tag. since we didnât specify a rpy (roll pitch yaw) attribute, the child frame will be default have the same orientation as the parent frame. now, looking at the legâs visual origin, it has both a xyz and rpy offset. this defines where the center of the visual element should be, relative to its origin. since we want the leg to attach at the top, we offset the origin down by setting the z offset to be -0.3 meters. and since we want the long part of the leg to be parallel to the z axis, we rotate the visual part pi/2 around the y axis. ros2 launch urdf_tutorial display.launch.py model:=urdf/03-origins.urdf the launch file runs packages that will create tf frames for each link in your model based on your urdf. rviz uses this information to figure out where to display each shape. if a tf frame does not exist for a given urdf link, then it will be placed at the origin in white (ref. related question ). material girl ï âalright,â i hear you say. âthatâs very cute, but not everyone owns a b21. my robot and r2d2 are not red!â thatâs a good point. letâs take a look at the material tag. [source: 04-materials.urdf] <?xml version="1.0"?> <robot name= "materials" > <material name= "blue" > <color rgba= "0 0 0.8 1" /> </material> <material name= "white" > <color rgba= "1 1 1 1" /> </material> <link name= "base_link" > <visual> <geometry> <cylinder length= "0.6" radius= "0.2" /> </geometry> <material name= "blue" /> </visual> </link> <link name= "right_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> <origin rpy= "0 1.57075 0" xyz= "0 0 -0.3" /> <material name= "white" /> </visual> </link> <joint name= "base_to_right_leg" type= "fixed" > <parent link= "base_link" /> <child link= "right_leg" /> <origin xyz= "0 -0.22 0.25" /> </joint> <link name= "left_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> <origin rpy= "0 1.57075 0" xyz= "0 0 -0.3" /> <material name= "white" /> </visual> </link> <joint name= "base_to_left_leg" type= "fixed" > <parent link= "base_link" /> <child link= "left_leg" /> <origin xyz= "0 0.22 0.25" /> </joint> </robot> the body is now blue. weâve defined a new material called âblueâ, with the red, green, blue and alpha channels defined as 0,0,0.8 and 1 respectively. all of the values can be in the range [0,1]. this material is then referenced by the base_linkâs visual element. the white material is defined similarly. you could also define the material tag from within the visual element, and even reference it in other links. no one will even complain if you redefine it though. you can also use a texture to specify an image file to be used for coloring the object ros2 launch urdf_tutorial display.launch.py model:=urdf/04-materials.urdf finishing the model ï now we finish the model off with a few more shapes: feet, wheels, and head. most notably, we add a sphere and a some meshes. weâll also add few other pieces that weâll use later. [source: 05-visual.urdf] <?xml version="1.0"?> <robot name= "visual" > <material name= "blue" > <color rgba= "0 0 0.8 1" /> </material> <material name= "black" > <color rgba= "0 0 0 1" /> </material> <material name= "white" > <color rgba= "1 1 1 1" /> </material> <link name= "base_link" > <visual> <geometry> <cylinder length= "0.6" radius= "0.2" /> </geometry> <material name= "blue" /> </visual> </link> <link name= "right_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> <origin rpy= "0 1.57075 0" xyz= "0 0 -0.3" /> <material name= "white" /> </visual> </link> <joint name= "base_to_right_leg" type= "fixed" > <parent link= "base_link" /> <child link= "right_leg" /> <origin xyz= "0 -0.22 0.25" /> </joint> <link name= "right_base" > <visual> <geometry> <box size= "0.4 0.1 0.1" /> </geometry> <material name= "white" /> </visual> </link> <joint name= "right_base_joint" type= "fixed" > <parent link= "right_leg" /> <child link= "right_base" /> <origin xyz= "0 0 -0.6" /> </joint> <link name= "right_front_wheel" > <visual> <origin rpy= "1.57075 0 0" xyz= "0 0 0" /> <geometry> <cylinder length= "0.1" radius= "0.035" /> </geometry> <material name= "black" /> </visual> </link> <joint name= "right_front_wheel_joint" type= "fixed" > <parent link= "right_base" /> <child link= "right_front_wheel" /> <origin rpy= "0 0 0" xyz= "0.133333333333 0 -0.085" /> </joint> <link name= "right_back_wheel" > <visual> <origin rpy= "1.57075 0 0" xyz= "0 0 0" /> <geometry> <cylinder length= "0.1" radius= "0.035" /> </geometry> <material name= "black" /> </visual> </link> <joint name= "right_back_wheel_joint" type= "fixed" > <parent link= "right_base" /> <child link= "right_back_wheel" /> <origin rpy= "0 0 0" xyz= "-0.133333333333 0 -0.085" /> </joint> <link name= "left_leg" > <visual> <geometry> <box size= "0.6 0.1 0.2" /> </geometry> <origin rpy= "0 1.57075 0" xyz= "0 0 -0.3" /> <material name= "white" /> </visual> </link> <joint name= "base_to_left_leg" type= "fixed" > <parent link= "base_link" /> <child link= "left_leg" /> <origin xyz= "0 0.22 0.25" /> </joint> <link name= "left_base" > <visual> <geometry> <box size= "0.4 0.1 0.1" /> </geometry> <material name= "white" /> </visual> </link> <joint name= "left_base_joint" type= "fixed" > <parent link= "left_leg" /> <child link= "left_base" /> <origin xyz= "0 0 -0.6" /> </joint> <link name= "left_front_wheel" > <visual> <origin rpy= "1.57075 0 0" xyz= "0 0 0" /> <geometry> <cylinder length= "0.1" radius= "0.035" /> </geometry> <material name= "black" /> </visual> </link> <joint name= "left_front_wheel_joint" type= "fixed" > <parent link= "left_base" /> <child link= "left_front_wheel" /> <origin rpy= "0 0 0" xyz= "0.133333333333 0 -0.085" /> </joint> <link name= "left_back_wheel" > <visual> <origin rpy= "1.57075 0 0" xyz= "0 0 0" /> <geometry> <cylinder length= "0.1" radius= "0.035" /> </geometry> <material name= "black" /> </visual> </link> <joint name= "left_back_wheel_joint" type= "fixed" > <parent link= "left_base" /> <child link= "left_back_wheel" /> <origin rpy= "0 0 0" xyz= "-0.133333333333 0 -0.085" /> </joint> <joint name= "gripper_extension" type= "fixed" > <parent link= "base_link" /> <child link= "gripper_pole" /> <origin rpy= "0 0 0" xyz= "0.19 0 0.2" /> </joint> <link name= "gripper_pole" > <visual> <geometry> <cylinder length= "0.2" radius= "0.01" /> </geometry> <origin rpy= "0 1.57075 0 " xyz= "0.1 0 0" /> </visual> </link> <joint name= "left_gripper_joint" type= "fixed" > <origin rpy= "0 0 0" xyz= "0.2 0.01 0" /> <parent link= "gripper_pole" /> <child link= "left_gripper" /> </joint> <link name= "left_gripper" > <visual> <origin rpy= "0.0 0 0" xyz= "0 0 0" /> <geometry> <mesh filename= "package://urdf_tutorial/meshes/l_finger.dae" /> </geometry> </visual> </link> <joint name= "left_tip_joint" type= "fixed" > <parent link= "left_gripper" /> <child link= "left_tip" /> </joint> <link name= "left_tip" > <visual> <origin rpy= "0.0 0 0" xyz= "0.09137 0.00495 0" /> <geometry> <mesh filename= "package://urdf_tutorial/meshes/l_finger_tip.dae" /> </geometry> </visual> </link> <joint name= "right_gripper_joint" type= "fixed" > <origin rpy= "0 0 0" xyz= "0.2 -0.01 0" /> <parent link= "gripper_pole" /> <child link= "right_gripper" /> </joint> <link name= "right_gripper" > <visual> <origin rpy= "-3.1415 0 0" xyz= "0 0 0" /> <geometry> <mesh filename= "package://urdf_tutorial/meshes/l_finger.dae" /> </geometry> </visual> </link> <joint name= "right_tip_joint" type= "fixed" > <parent link= "right_gripper" /> <child link= "right_tip" /> </joint> <link name= "right_tip" > <visual> <origin rpy= "-3.1415 0 0" xyz= "0.09137 0.00495 0" /> <geometry> <mesh filename= "package://urdf_tutorial/meshes/l_finger_tip.dae" /> </geometry> </visual> </link> <link name= "head" > <visual> <geometry> <sphere radius= "0.2" /> </geometry> <material name= "white" /> </visual> </link> <joint name= "head_swivel" type= "fixed" > <parent link= "base_link" /> <child link= "head" /> <origin xyz= "0 0 0.3" /> </joint> <link name= "box" > <visual> <geometry> <box size= "0.08 0.08 0.08" /> </geometry> <material name= "blue" /> </visual> </link> <joint name= "tobox" type= "fixed" > <parent link= "head" /> <child link= "box" /> <origin xyz= "0.1814 0 0.1414" /> </joint> </robot> ros2 launch urdf_tutorial display.launch.py model:=urdf/05-visual.urdf how to add the sphere should be fairly self explanatory: <link name= "head" > <visual> <geometry> <sphere radius= "0.2" /> </geometry> <material name= "white" /> </visual> </link> the meshes here were borrowed from the pr2. they are separate files which you have to specify the path for. you should use the package://name_of_package/path notation. the meshes for this tutorial are located within the urdf_tutorial package, in a folder called meshes. <link name= "left_gripper" > <visual> <origin rpy= "0.0 0 0" xyz= "0 0 0" /> <geometry> <mesh filename= "package://urdf_tutorial/meshes/l_finger.dae" /> </geometry> </visual> </link> the meshes can be imported in a number of different formats. stl is fairly common, but the engine also supports dae, which can have its own color data, meaning you donât have to specify the color/material. often these are in separate files. these meshes reference the .tif files also in the meshes folder. meshes can also be sized using relative scaling parameters or a bounding box size. we could have also referred to meshes in a completely different package. there you have it. a r2d2-like urdf model. now you can continue on to the next step, making it move . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling