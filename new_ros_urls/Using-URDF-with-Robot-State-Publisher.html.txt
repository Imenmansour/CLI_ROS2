tutorials intermediate urdf using urdf with robot_state_publisher edit on github using urdf with robot_state_publisher ï goal: simulate a walking robot modeled in urdf and view it in rviz. tutorial level: intermediate time: 15 minutes background ï this tutorial will show you how to model a walking robot, publish the state as a tf2 message and view the simulation in rviz. first, we create the urdf model describing the robot assembly. next we write a node which simulates the motion and publishes the jointstate and transforms. we then use robot_state_publisher to publish the entire robot state to /tf2 . prerequisites ï rviz2 as always, donât forget to source ros 2 in every new terminal you open . tasks ï 1 create a package ï create the directory: linux macos windows mkdir -p second_ros2_ws/src mkdir -p second_ros2_ws/src md second_ros2_ws/src then create the package: cd second_ros2_ws/src ros2 pkg create --build-type ament_python --license apache-2.0 urdf_tutorial_r2d2 --dependencies rclpy cd urdf_tutorial_r2d2 you should now see a urdf_tutorial_r2d2 folder. next you will make several changes to it. 2 create the urdf file ï create the directory where we will store some assets: linux macos windows mkdir -p urdf mkdir -p urdf md urdf download the urdf file and save it as second_ros2_ws/src/urdf_tutorial_r2d2/urdf/r2d2.urdf.xml . download the rviz configuration file and save it as second_ros2_ws/src/urdf_tutorial_r2d2/urdf/r2d2.rviz . 3 publish the state ï now we need a method for specifying what state the robot is in. to do this, we must specify all three joints and the overall odometry. fire up your favorite editor and paste the following code into second_ros2_ws/src/urdf_tutorial_r2d2/urdf_tutorial_r2d2/state_publisher.py from math import sin , cos , pi import rclpy from rclpy.node import node from rclpy.qos import qosprofile from geometry_msgs.msg import quaternion from sensor_msgs.msg import jointstate from tf2_ros import transformbroadcaster , transformstamped class statepublisher ( node ): def __init__ ( self ): rclpy . init () super () . __init__ ( 'state_publisher' ) qos_profile = qosprofile ( depth = 10 ) self . joint_pub = self . create_publisher ( jointstate , 'joint_states' , qos_profile ) self . broadcaster = transformbroadcaster ( self , qos = qos_profile ) self . nodename = self . get_name () self . get_logger () . info ( " {0} started" . format ( self . nodename )) degree = pi / 180.0 loop_rate = self . create_rate ( 30 ) # robot state tilt = 0. tinc = degree swivel = 0. angle = 0. height = 0. hinc = 0.005 # message declarations odom_trans = transformstamped () odom_trans . header . frame_id = 'odom' odom_trans . child_frame_id = 'axis' joint_state = jointstate () try : while rclpy . ok (): rclpy . spin_once ( self ) # update joint_state now = self . get_clock () . now () joint_state . header . stamp = now . to_msg () joint_state . name = [ 'swivel' , 'tilt' , 'periscope' ] joint_state . position = [ swivel , tilt , height ] # update transform # (moving in a circle with radius=2) odom_trans . header . stamp = now . to_msg () odom_trans . transform . translation . x = cos ( angle ) * 2 odom_trans . transform . translation . y = sin ( angle ) * 2 odom_trans . transform . translation . z = 0.7 odom_trans . transform . rotation = \ euler_to_quaternion ( 0 , 0 , angle + pi / 2 ) # roll,pitch,yaw # send the joint state and transform self . joint_pub . publish ( joint_state ) self . broadcaster . sendtransform ( odom_trans ) # create new robot state tilt += tinc if tilt < - 0.5 or tilt > 0.0 : tinc *= - 1 height += hinc if height > 0.2 or height < 0.0 : hinc *= - 1 swivel += degree angle += degree / 4 # this will adjust as needed per iteration loop_rate . sleep () except keyboardinterrupt : pass def euler_to_quaternion ( roll , pitch , yaw ): qx = sin ( roll / 2 ) * cos ( pitch / 2 ) * cos ( yaw / 2 ) - cos ( roll / 2 ) * sin ( pitch / 2 ) * sin ( yaw / 2 ) qy = cos ( roll / 2 ) * sin ( pitch / 2 ) * cos ( yaw / 2 ) + sin ( roll / 2 ) * cos ( pitch / 2 ) * sin ( yaw / 2 ) qz = cos ( roll / 2 ) * cos ( pitch / 2 ) * sin ( yaw / 2 ) - sin ( roll / 2 ) * sin ( pitch / 2 ) * cos ( yaw / 2 ) qw = cos ( roll / 2 ) * cos ( pitch / 2 ) * cos ( yaw / 2 ) + sin ( roll / 2 ) * sin ( pitch / 2 ) * sin ( yaw / 2 ) return quaternion ( x = qx , y = qy , z = qz , w = qw ) def main (): node = statepublisher () if __name__ == '__main__' : main () 4 create a launch file ï create a new second_ros2_ws/src/urdf_tutorial_r2d2/launch folder. open your editor and paste the following code, saving it as second_ros2_ws/src/urdf_tutorial_r2d2/launch/demo_launch.py import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import launchconfiguration from launch_ros.actions import node def generate_launch_description (): use_sim_time = launchconfiguration ( 'use_sim_time' , default = 'false' ) urdf_file_name = 'r2d2.urdf.xml' urdf = os . path . join ( get_package_share_directory ( 'urdf_tutorial_r2d2' ), urdf_file_name ) with open ( urdf , 'r' ) as infp : robot_desc = infp . read () return launchdescription ([ declarelaunchargument ( 'use_sim_time' , default_value = 'false' , description = 'use simulation (gazebo) clock if true' ), node ( package = 'robot_state_publisher' , executable = 'robot_state_publisher' , name = 'robot_state_publisher' , output = 'screen' , parameters = [{ 'use_sim_time' : use_sim_time , 'robot_description' : robot_desc }], arguments = [ urdf ]), node ( package = 'urdf_tutorial_r2d2' , executable = 'state_publisher' , name = 'state_publisher' , output = 'screen' ), ]) 5 edit the setup.py file ï you must tell the colcon build tool how to install your python package. edit the second_ros2_ws/src/urdf_tutorial_r2d2/setup.py file as follows: include these import statements import os from glob import glob from setuptools import setup from setuptools import find_packages append these 2 lines inside data_files data_files = [ ... ( os . path . join ( 'share' , package_name , 'launch' ), glob ( os . path . join ( 'launch' , '*launch.[pxy][yma]*' ))), ( os . path . join ( 'share' , package_name ), glob ( 'urdf/*' )), ], modify the entry_points table so you can later run âstate_publisherâ from a console 'console_scripts' : [ 'state_publisher = urdf_tutorial_r2d2.state_publisher:main' ], save the setup.py file with your changes. 6 install the package ï cd second_ros2_ws colcon build --symlink-install --packages-select urdf_tutorial_r2d2 source the setup files: linux macos windows source install/setup.bash source install/setup.bash call install/setup.bat 7 view the results ï launch the package ros2 launch urdf_tutorial_r2d2 demo_launch.py open a new terminal, the run rviz using rviz2 -d second_ros2_ws/install/urdf_tutorial_r2d2/share/urdf_tutorial_r2d2/r2d2.rviz see the user guide for details on how to use rviz. summary ï you created a jointstate publisher node and coupled it with robot_state_publisher to simulate a walking robot. the code used in these examples is originally from here . credit is given to the authors of this ros 1 tutorial from which some content was reused. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling