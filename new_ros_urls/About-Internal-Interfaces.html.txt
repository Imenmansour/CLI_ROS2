concepts advanced concepts internal ros 2 interfaces edit on github internal ros 2 interfaces ï the internal ros interfaces are public c apis that are intended for use by developers who are creating client libraries or adding a new underlying middleware, but are not intended for use by typical ros users. the ros client libraries provide the user facing apis that most ros users are familiar with, and may come in a variety of programming languages. internal api architecture overview ï there are two main internal interfaces: the ros middleware interface ( rmw api ) the ros client library interface ( rcl api ) the rmw api is the interface between the ros 2 software stack and the underlying middleware implementation. the underlying middleware used for ros 2 is either a dds or rtps implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types. the rcl api is a slightly higher level api which is used to implement the client libraries and does not touch the middleware implementation directly, but rather does so through the ros middleware interface ( rmw api ) abstraction. as the diagram shows, these apis are stacked such that the typical ros user will use the client library api , e.g. rclcpp , to implement their code (executable or library). the implementation of the client libraries , e.g. rclcpp , use the rcl interface which provides access to the ros graph and graph events. the rcl implementation in turn uses the rmw api to access the ros graph. the purpose of the rcl implementation is to provide a common implementation for more complex ros concepts and utilities that may be used by various client libraries , while remaining agnostic to the underlying middleware being used. the purpose of the rmw interface is to capture the absolute minimum middleware functionality needed to support rosâs client libraries. finally, the implementation of the rmw api is provided by a middleware implementation specific package , e.g. rmw_fastrtps_cpp , the library of which is compiled against vendor specific dds interfaces and types. in the diagram above there is also a box labeled ros_to_dds , and the purpose of this box is to represent a category of possible packages which allow the user to access dds vendor specific objects and settings using the ros equivalents. one of the goals of this abstraction interface is to completely insulate the ros user space code from the middleware being used, so that changing dds vendors or even middleware technology has a minimal impact on the users code. however, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have. by requiring the use of one of these packages in order to access the underlying dds vendorâs objects, we can avoid exposing vendor specific symbols and headers in the normal interface. it also makes it easy to see what code is potentially violating the vendor portability by inspecting the packageâs dependencies to see if one of these ros_to_dds packages are being used. type specific interfaces ï all along the way there are some parts of the apis that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type. the following diagram layouts the path from user defined rosidl files, e.g. .msg files, to the type specific code used by the user and system to perform type specific functions: figure: flow chart of âstaticâ type support generation, from rosidl files to user facing code. ï the right hand side of the diagram shows how the .msg files are passed directly to language specific code generators, e.g. rosidl_generator_cpp or rosidl_generator_py . these generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the .msg files. for example, consider the message std_msgs/string , a user might use this file in c++ with the statement #include <std_msgs/msg/string.hpp> , or they might use the statement from std_msgs.msg import string in python. these statements work because of the files generated by these language specific (but middleware agnostic) generator packages. separately, the .msg files are used to generate type support code for each type. in this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. the type support for a given message might include things like a list of the names and types for each field in the message. it might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message. static type support ï when the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. for example, consider the type specific publish function, when using âvendor aâ the function will need to call some of âvendor aââs api , but when using âvendor bâ it will need to call âvendor bââs api . to allow for middleware vendor specific code, the user defined .msg files may result in the generation of vendor specific code. this vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the âprivate implementationâ (or pimpl) pattern works. static type support with dds ï for middleware vendors based on dds, and specifically those which generate code based on the omg idl files ( .idl files), the user defined rosidl files ( .msg files) are converted into equivalent omg idl files ( .idl files). from these omg idl files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. the above diagram shows this on the left hand side, where the .msg files are consumed by the rosidl_dds package to produce .idl files, and then those .idl files are given to language specific and dds vendor specific type support generation packages. for example, consider the fast dds implementation, which has a package called rosidl_typesupport_fastrtps_cpp . this package is responsible for generating code to handle things like converting a c++ message object into a serialized octet buffer to be written over the network. this code, while specific to fast dds, is still not exposed to the user because of the abstraction in the type support code. dynamic type support ï another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. in order to accomplish this, this generic function needs some meta information  the message type being published, things like a list of field names and types in the order in which they appear in the message type. then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data  the message type. this is referred to as âdynamicâ type support, as opposed to âstaticâ type support which requires generated versions of a function for each type. figure: flow chart of âdynamicâ type support generation, from rosidl files to user facing code. ï the above diagram shows the flow from user defined rosidl files to generated user facing code. it is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram. in dynamic type support the .msg files are converted directly into user facing code. this code is also middleware agnostic, because it only contains meta information  the messages. the function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific apis . note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. rosidl_typesupport_introspection_c and rosidl_typesupport_introspection_cpp . the introspection part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. this is the fundamental capability that allows for generic implementations of functions like âpublish to a topicâ. this approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support. it also results in less generated code, which reduces compile time and code size. however, dynamic type support requires that the underlying middleware support a similar form of dynamic type support. in the case of dds the dds-xtypes standard allows for publishing of messages using meta information rather than generated code. dds-xtypes, or something like it, is required in the underlying middleware in order to support dynamic type support. also, this approach to type support is normally slower than the static type support alternative. the type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message typeâs meta data to perform things like serialization. the rcl repository ï the ros client library interface ( rcl api ) can be used by client libraries (e.g. rclc , rclcpp , rclpy , etc.) in order to avoid duplicating logic and features. by reusing the rcl api , client libraries can be smaller and more consistent with each other. some parts of the client library are intentionally left out of the rcl api because the language idiomatic method should be used to implement those parts of the system. a good example of this is the execution model, which rcl does not address at all. instead the client library should provide a language idiomatic solution like pthreads in c, std::thread in c++11, and threading.thread in python. generally the rcl interface provides functions that are not specific to a language pattern and are not specific to a particular message type. the rcl api is located in the ros2/rcl repository on github and contains the interface as c headers. the rcl c implementation is provided by the rcl package in the same repository. this implementation avoids direct  with the middleware by instead using the rmw and rosidl apis . for a complete definition of the rcl api , see the rcl docs . the rmw repository ï the ros middleware interface ( rmw api ) is the minimal set of primitive middleware capabilities needed to build ros on top. providers of different middleware implementations must implement this interface in order to support the entire ros stack on top. currently all of the middleware implementations are for different dds vendors. the rmw api is located in the ros2/rmw repository. the rmw package contains the c headers which define the interface, the implementation of which is provided by the various packages of rmw implementations for different dds vendors. for a definition of the rmw api , see the rmw docs . the rosidl repository ï the rosidl api consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages. the generated message code specified in the api will be language specific, but may or may not reuse generated code for other languages. the generated message code specified in the api contains things like the message data structure, functions for construction, destruction, etc. the api will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type. there are several repositories that play a role in the rosidl api and implementation. the rosidl repository, located on github at ros2/rosidl , defines the message idl syntax, i.e. syntax of .msg files, .srv files, etc., and contains packages for parsing the files, for providing cmake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators. the repository contains these packages : rosidl_cmake : provides cmake functions and modules for generating code from rosidl files, e.g. .msg files, .srv files, etc. rosidl_default_generators : defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used. rosidl_generator_c : provides tools to generate c header files ( .h ) for rosidl files. rosidl_generator_cpp : provides tools to generate c++ header files ( .hpp ) for rosidl files. rosidl_generator_py : provides tools to generate python modules for rosidl files. rosidl_parser : provides python api for parsing rosidl files. generators for other languages, e.g. rosidl_generator_java , are hosted externally (in different repositories) but would use the same mechanism that the above generators use to âregisterâ themselves as a rosidl generator. in addition to the aforementioned packages for parsing and generating headers for the rosidl files, the rosidl repository also contains packages concerned with âtype supportâ for the message types defined in the files. type support refers to the ability to interpret and manipulate the information represented by ros message instances of particular types (publishing the messages, for example). type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the rosidl file, e.g. the .msg or .srv file, and the data received, by introspecting the data. in the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ros 2 can be agnostic to the rmw implementation. the packages that provide this type support through introspection of the data are: rosidl_typesupport_introspection_c : provides tools for generating c code for supporting rosidl message data types. rosidl_typesupport_introspection_cpp : provides tools for generating c++ code for supporting rosidl message data types. in the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used. this is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the dds vendor in order for the dds implementation to make use of it. see the type specific interfaces section above for more details. for more information on what exactly is in the rosidl api (static and generated) see this page: the rcutils repository ï ros 2 c utilities ( rcutils ) is a c api composed of macros, functions, and data structures used throughout the ros 2 codebase. these are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both. the rcutils api and implementation are located in the ros2/rcutils repository on github which contains the interface as c headers. for a complete definition of the rcutils api , see the rcutils docs . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling