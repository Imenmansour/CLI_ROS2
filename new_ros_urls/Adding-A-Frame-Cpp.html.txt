tutorials intermediate tf2 adding a frame (c++) edit on github adding a frame (c++) ï goal: learn how to to add an extra frame to tf2. tutorial level: intermediate time: 15 minutes background ï in previous tutorials, we recreated the turtle demo by writing a tf2 broadcaster and a tf2 listener . this tutorial will teach you how to add extra fixed and dynamic frames to the transformation tree. in fact, adding a frame in tf2 is very similar to creating the tf2 broadcaster, but this example will show you some additional features of tf2. for many tasks related to transformations, it is easier to think inside a local frame. for example, it is easiest to reason  laser scan measurements in a frame at the center of the laser scanner. tf2 allows you to define a local frame for each sensor, link, or joint in your system. when transforming from one frame to another, tf2 will take care of all the hidden intermediate frame transformations that are introduced. tf2 tree ï tf2 builds up a tree structure of frames and, thus, does not allow a closed loop in the frame structure. this means that a frame only has one single parent, but it can have multiple children. currently, our tf2 tree contains three frames: world , turtle1 and turtle2 . the two turtle frames are children of the world frame. if we want to add a new frame to tf2, one of the three existing frames needs to be the parent frame, and the new one will become its child frame. tasks ï 1 write the fixed frame broadcaster ï in our turtle example, weâll add a new frame carrot1 , which will be the child of the turtle1 . this frame will serve as the goal for the second turtle. letâs first create the source files. go to the learning_tf2_cpp package we created in the previous tutorials. inside the src directory download the fixed frame broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp -o fixed_frame_tf2_broadcaster.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp -o fixed_frame_tf2_broadcaster.cpp now open the file called fixed_frame_tf2_broadcaster.cpp . #include <chrono> #include <functional> #include <memory> #include "geometry_msgs/msg/transform_stamped.hpp" #include "rclcpp/rclcpp.hpp" #include "tf2_ros/transform_broadcaster.h" using namespace std :: chrono_literals ; class fixedframebroadcaster : public rclcpp :: node { public : fixedframebroadcaster () : node ( "fixed_frame_tf2_broadcaster" ) { tf_broadcaster_ = std :: make_shared < tf2_ros :: transformbroadcaster > ( this ); auto broadcast_timer_callback = [ this ](){ geometry_msgs :: msg :: transformstamped t ; t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "turtle1" ; t . child_frame_id = "carrot1" ; t . transform . translation . x = 0.0 ; t . transform . translation . y = 2.0 ; t . transform . translation . z = 0.0 ; t . transform . rotation . x = 0.0 ; t . transform . rotation . y = 0.0 ; t . transform . rotation . z = 0.0 ; t . transform . rotation . w = 1.0 ; tf_broadcaster_ -> sendtransform ( t ); }; timer_ = this -> create_wall_timer ( 100 ms , broadcast_timer_callback ); } private : rclcpp :: timerbase :: sharedptr timer_ ; std :: shared_ptr < tf2_ros :: transformbroadcaster > tf_broadcaster_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < fixedframebroadcaster > ()); rclcpp :: shutdown (); return 0 ; } the code is very similar to the tf2 broadcaster tutorial example and the only difference is that the transform here does not change over time. 1.1 examine the code ï letâs take a look at the key lines in this piece of code. here we create a new transform, from the parent turtle1 to the new child carrot1 . the carrot1 frame is 2 meters offset in y axis in  of the turtle1 frame. geometry_msgs :: msg :: transformstamped t ; t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "turtle1" ; t . child_frame_id = "carrot1" ; t . transform . translation . x = 0.0 ; t . transform . translation . y = 2.0 ; t . transform . translation . z = 0.0 ; 1.2 cmakelists.txt ï navigate one level back to the learning_tf2_cpp directory, where the cmakelists.txt and package.xml files are located. now open the cmakelists.txt add the executable and name it fixed_frame_tf2_broadcaster . add_executable(fixed_frame_tf2_broadcaster src/fixed_frame_tf2_broadcaster.cpp) ament_target_dependencies( fixed_frame_tf2_broadcaster geometry_msgs rclcpp tf2_ros ) finally, add the install(targetsâ) section so ros2 run can find your executable: install(targets fixed_frame_tf2_broadcaster destination lib/{project_name}) 1.3 write the launch file ï now letâs create a launch file for this example. with your text editor, create a new file called turtle_tf2_fixed_frame_demo_launch.py in the src/learning_tf2_cpp/launch directory, and add the following lines: import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch.actions import includelaunchdescription from launch.launch_description_sources import pythonlaunchdescriptionsource from launch_ros.actions import node def generate_launch_description (): demo_nodes = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'learning_tf2_cpp' ), 'launch' ), '/turtle_tf2_demo_launch.py' ]), ) return launchdescription ([ demo_nodes , node ( package = 'learning_tf2_cpp' , executable = 'fixed_frame_tf2_broadcaster' , name = 'fixed_broadcaster' , ), ]) this launch file imports the required packages and then creates a demo_nodes variable that will store nodes that we created in the previous tutorialâs launch file. the last part of the code will add our fixed carrot1 frame to the turtlesim world using our fixed_frame_tf2_broadcaster node. node ( package = 'learning_tf2_cpp' , executable = 'fixed_frame_tf2_broadcaster' , name = 'fixed_broadcaster' , ), 1.4 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your package: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 1.5 run ï now you can start the turtle broadcaster demo: ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py you should notice that the new carrot1 frame appeared in the transformation tree. if you drive the first turtle around, you should notice that the behavior didnât change from the previous tutorial, even though we added a new frame. thatâs because adding an extra frame does not affect the other frames and our listener is still using the previously defined frames. therefore if we want our second turtle to follow the carrot instead of the first turtle, we need to change value of the target_frame . this can be done two ways. one way is to pass the target_frame argument to the launch file directly from the console: ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py target_frame:=carrot1 the second way is to update the launch file. to do so, open the turtle_tf2_fixed_frame_demo_launch.py file, and add the 'target_frame': 'carrot1' parameter via launch_arguments argument. def generate_launch_description (): demo_nodes = includelaunchdescription ( ... , launch_arguments = { 'target_frame' : 'carrot1' } . items (), ) now rebuild the package, restart the turtle_tf2_fixed_frame_demo_launch.py , and youâll see the second turtle following the carrot instead of the first turtle! 2 write the dynamic frame broadcaster ï the extra frame we published in this tutorial is a fixed frame that doesnât change over time in relation to the parent frame. however, if you want to publish a moving frame you can code the broadcaster to change the frame over time. letâs change our carrot1 frame so that it changes relative to turtle1 frame over time. go to the learning_tf2_cpp package we created in the previous tutorial. inside the src directory download the dynamic frame broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp -o dynamic_frame_tf2_broadcaster.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp -o dynamic_frame_tf2_broadcaster.cpp now open the file called dynamic_frame_tf2_broadcaster.cpp : #include <chrono> #include <functional> #include <memory> #include "geometry_msgs/msg/transform_stamped.hpp" #include "rclcpp/rclcpp.hpp" #include "tf2_ros/transform_broadcaster.h" using namespace std :: chrono_literals ; const double pi = 3.141592653589793238463 ; class dynamicframebroadcaster : public rclcpp :: node { public : dynamicframebroadcaster () : node ( "dynamic_frame_tf2_broadcaster" ) { tf_broadcaster_ = std :: make_shared < tf2_ros :: transformbroadcaster > ( this ); auto broadcast_timer_callback = [ this ](){ rclcpp :: time now = this -> get_clock () -> now (); double x = now . seconds () * pi ; geometry_msgs :: msg :: transformstamped t ; t . header . stamp = now ; t . header . frame_id = "turtle1" ; t . child_frame_id = "carrot1" ; t . transform . translation . x = 10 * sin ( x ); t . transform . translation . y = 10 * cos ( x ); t . transform . translation . z = 0.0 ; t . transform . rotation . x = 0.0 ; t . transform . rotation . y = 0.0 ; t . transform . rotation . z = 0.0 ; t . transform . rotation . w = 1.0 ; tf_broadcaster_ -> sendtransform ( t ); }; timer_ = this -> create_wall_timer ( 100 ms , broadcast_timer_callback ); } private : rclcpp :: timerbase :: sharedptr timer_ ; std :: shared_ptr < tf2_ros :: transformbroadcaster > tf_broadcaster_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < dynamicframebroadcaster > ()); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï instead of a fixed definition of our x and y offsets, we are using the sin() and cos() functions on the current time so that the offset of carrot1 is constantly changing. double x = now . seconds () * pi ; ... t . transform . translation . x = 10 * sin ( x ); t . transform . translation . y = 10 * cos ( x ); 2.2 cmakelists.txt ï navigate one level back to the learning_tf2_cpp directory, where the cmakelists.txt and package.xml files are located. now open the cmakelists.txt add the executable and name it dynamic_frame_tf2_broadcaster . add_executable(dynamic_frame_tf2_broadcaster src/dynamic_frame_tf2_broadcaster.cpp) ament_target_dependencies( dynamic_frame_tf2_broadcaster geometry_msgs rclcpp tf2_ros ) finally, add the install(targetsâ) section so ros2 run can find your executable: install(targets dynamic_frame_tf2_broadcaster destination lib/{project_name}) 2.3 write the launch file ï to test this code, create a new launch file turtle_tf2_dynamic_frame_demo_launch.py in the src/learning_tf2_cpp/launch directory and paste the following code: import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch.actions import includelaunchdescription from launch.launch_description_sources import pythonlaunchdescriptionsource from launch_ros.actions import node def generate_launch_description (): demo_nodes = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'learning_tf2_cpp' ), 'launch' ), '/turtle_tf2_demo_launch.py' ]), launch_arguments = { 'target_frame' : 'carrot1' } . items (), ) return launchdescription ([ demo_nodes , node ( package = 'learning_tf2_cpp' , executable = 'dynamic_frame_tf2_broadcaster' , name = 'dynamic_broadcaster' , ), ]) 2.4 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your package: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 2.5 run ï now you can start the dynamic frame demo: ros2 launch learning_tf2_cpp turtle_tf2_dynamic_frame_demo_launch.py you should see that the second turtle is following the carrotâs position that is constantly changing. summary ï in this tutorial, you learned  the tf2 transformation tree, its structure, and its features. you also learned that it is easiest to think inside a local frame, and learned to add extra fixed and dynamic frames for that local frame. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling