tutorials beginner: client libraries creating custom msg and srv files edit on github creating custom msg and srv files ï goal: define custom interface files ( .msg and .srv ) and use them with python and c++ nodes. tutorial level: beginner time: 20 minutes background ï in previous tutorials you utilized message and service interfaces to learn  topics , services , and simple publisher/subscriber ( c++ / python ) and service/client ( c++ / python ) nodes. the interfaces you used were predefined in those cases. while itâs good practice to use predefined interface definitions, you will probably need to define your own messages and services sometimes as well. this tutorial will introduce you to the simplest method of creating custom interface definitions. prerequisites ï you should have a ros 2 workspace . this tutorial also uses the packages created in the publisher/subscriber ( c++ and python ) and service/client ( c++ and python ) tutorials to try out the new custom messages. tasks ï 1 create a new package ï for this tutorial you will be creating custom .msg and .srv files in their own package, and then utilizing them in a separate package. both packages should be in the same workspace. since we will use the pub/sub and service/client packages created in earlier tutorials, make sure you are in the same workspace as those packages ( ros2_ws/src ), and then run the following command to create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 tutorial_interfaces tutorial_interfaces is the name of the new package. note that it is, and can only be, a cmake package, but this doesnât restrict in which type of packages you can use your messages and services. you can create your own custom interfaces in a cmake package, and then use it in a c++ or python node, which will be covered in the last section. the .msg and .srv files are required to be placed in directories called msg and srv respectively. create the directories in ros2_ws/src/tutorial_interfaces : mkdir msg srv 2 create custom definitions ï 2.1 msg definition ï in the tutorial_interfaces/msg directory you just created, make a new file called num.msg with one line of code declaring its data structure: int64 num this is a custom message that transfers a single 64-bit integer called num . also in the tutorial_interfaces/msg directory you just created, make a new file called sphere.msg with the following content: geometry_msgs/point center float64 radius this custom message uses a message from another message package ( geometry_msgs/point in this case). 2.2 srv definition ï back in the tutorial_interfaces/srv directory you just created, make a new file called addthreeints.srv with the following request and response structure: int64 a int64 b int64 c --- int64 sum this is your custom service that requests three integers named a , b , and c , and responds with an integer called sum . 3 cmakelists.txt ï to convert the interfaces you defined into language-specific code (like c++ and python) so that they can be used in those languages, add the following lines to cmakelists.txt : find_package ( geometry_msgs required ) find_package ( rosidl_default_generators required ) rosidl_generate_interfaces ( { project_name } "msg/num.msg" "msg/sphere.msg" "srv/addthreeints.srv" dependencies geometry_msgs # add packages that above messages depend on, in this case geometry_msgs for sphere.msg ) note the first argument (library name) in the rosidl_generate_interfaces must match {project_name} (see https://github.com/ros2/rosidl/issues/441#issuecomment-591025515 ). 4 package.xml ï because the interfaces rely on rosidl_default_generators for generating language-specific code, you need to declare a build tool dependency on it. rosidl_default_runtime is a runtime or execution-stage dependency, needed to be able to use the interfaces later. the rosidl_interface_packages is the name of the dependency group that your package, tutorial_interfaces , should be associated with, declared using the <member_of_group> tag. add the following lines within the <package> element of package.xml : <depend> geometry_msgs </depend> <buildtool_depend> rosidl_default_generators </buildtool_depend> <exec_depend> rosidl_default_runtime </exec_depend> <member_of_group> rosidl_interface_packages </member_of_group> 5 build the tutorial_interfaces package ï now that all the parts of your custom interfaces package are in place, you can build the package. in the root of your workspace ( ~/ros2_ws ), run the following command: linux macos windows colcon build --packages-select tutorial_interfaces colcon build --packages-select tutorial_interfaces colcon build --merge-install --packages-select tutorial_interfaces now the interfaces will be discoverable by other ros 2 packages. 6 confirm msg and srv creation ï in a new terminal, run the following command from within your workspace ( ros2_ws ) to source it: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now you can confirm that your interface creation worked by using the ros2 interface show command: ros2 interface show tutorial_interfaces/msg/num should return: int64 num and ros2 interface show tutorial_interfaces/msg/sphere should return: geometry_msgs/point center float64 x float64 y float64 z float64 radius and ros2 interface show tutorial_interfaces/srv/addthreeints should return: int64 a int64 b int64 c --- int64 sum 7 test the new interfaces ï for this step you can use the packages you created in previous tutorials. a few simple modifications to the nodes, cmakelists.txt and package.xml files will allow you to use your new interfaces. 7.1 testing num.msg with pub/sub ï with a few modifications to the publisher/subscriber package created in a previous tutorial ( c++ or python ), you can see num.msg in action. since youâll be changing the standard string msg to a numerical one, the output will be slightly different. publisher c++ python #include <chrono> #include <memory> #include "rclcpp/rclcpp.hpp" #include "tutorial_interfaces/msg/num.hpp" // change using namespace std :: chrono_literals ; class minimalpublisher : public rclcpp :: node { public : minimalpublisher () : node ( "minimal_publisher" ), count_ ( 0 ) { publisher_ = this -> create_publisher < tutorial_interfaces :: msg :: num > ( "topic" , 10 ); // change auto timer_callback = [ this ](){ auto message = tutorial_interfaces :: msg :: num (); // change message . num = this -> count_ ++ ; // change rclcpp_info_stream ( this -> get_logger (), "publishing: '" << message . num << "'" ); // change publisher_ -> publish ( message ); }; timer_ = this -> create_wall_timer ( 500 ms , timer_callback ); } private : rclcpp :: timerbase :: sharedptr timer_ ; rclcpp :: publisher < tutorial_interfaces :: msg :: num >:: sharedptr publisher_ ; // change size_t count_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < minimalpublisher > ()); rclcpp :: shutdown (); return 0 ; } import rclpy from rclpy.node import node from tutorial_interfaces.msg import num # change class minimalpublisher ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_publisher' ) self . publisher_ = self . create_publisher ( num , 'topic' , 10 ) # change timer_period = 0.5 self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 def timer_callback ( self ): msg = num () # change msg . num = self . i # change self . publisher_ . publish ( msg ) self . get_logger () . info ( 'publishing: " %d "' % msg . num ) # change self . i += 1 def main ( args = none ): rclpy . init ( args = args ) minimal_publisher = minimalpublisher () rclpy . spin ( minimal_publisher ) minimal_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () subscriber c++ python #include <functional> #include <memory> #include "rclcpp/rclcpp.hpp" #include "tutorial_interfaces/msg/num.hpp" // change using std :: placeholders :: _1 ; class minimalsubscriber : public rclcpp :: node { public : minimalsubscriber () : node ( "minimal_subscriber" ) { auto topic_callback = [ this ]( const tutorial_interfaces :: msg :: num & msg ){ // change rclcpp_info_stream ( this -> get_logger (), "i heard: '" << msg . num << "'" ); // change }; _ = this -> create_ < tutorial_interfaces :: msg :: num > ( // change "topic" , 10 , topic_callback ); } private : rclcpp ::  < tutorial_interfaces :: msg :: num >:: sharedptr _ ; // change }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < minimalsubscriber > ()); rclcpp :: shutdown (); return 0 ; } import rclpy from rclpy.node import node from tutorial_interfaces.msg import num # change class minimalsubscriber ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_subscriber' ) self .  = self . create_ ( num , # change 'topic' , self . listener_callback , 10 ) self .  def listener_callback ( self , msg ): self . get_logger () . info ( 'i heard: " %d "' % msg . num ) # change def main ( args = none ): rclpy . init ( args = args ) minimal_subscriber = minimalsubscriber () rclpy . spin ( minimal_subscriber ) minimal_subscriber . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () cmakelists.txt add the following lines (c++ only): #... find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( tutorial_interfaces required ) # change add_executable ( talker src/publisher_member_function.cpp ) ament_target_dependencies ( talker rclcpp tutorial_interfaces ) # change add_executable ( listener src/subscriber_member_function.cpp ) ament_target_dependencies ( listener rclcpp tutorial_interfaces ) # change install ( targets talker listener destination lib/ { project_name } ) ament_package () package.xml add the following line: c++ python < depend > tutorial_interfaces </ depend > < exec_depend > tutorial_interfaces </ exec_depend > after making the above edits and saving all the changes, build the package: c++ python on linux/macos: colcon build --packages-select cpp_pubsub on windows: colcon build --merge-install --packages-select cpp_pubsub on linux/macos: colcon build --packages-select py_pubsub on windows: colcon build --merge-install --packages-select py_pubsub then open two new terminals, source ros2_ws in each, and run: c++ python ros2 run cpp_pubsub talker ros2 run cpp_pubsub listener ros2 run py_pubsub talker ros2 run py_pubsub listener since num.msg relays only an integer, the talker should only be publishing integer values, as opposed to the string it published previously: [info] [minimal_publisher]: publishing: '0' [info] [minimal_publisher]: publishing: '1' [info] [minimal_publisher]: publishing: '2' 7.2 testing addthreeints.srv with service/client ï with a few modifications to the service/client package created in a previous tutorial ( c++ or python ), you can see addthreeints.srv in action. since youâll be changing the original two integer request srv to a three integer request srv, the output will be slightly different. service c++ python #include "rclcpp/rclcpp.hpp" #include "tutorial_interfaces/srv/add_three_ints.hpp" // change #include <memory> void add ( const std :: shared_ptr < tutorial_interfaces :: srv :: addthreeints :: request > request , // change std :: shared_ptr < tutorial_interfaces :: srv :: addthreeints :: response > response ) // change { response -> sum = request -> a + request -> b + request -> c ; // change rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "incoming request \n a: %ld" " b: %ld" " c: %ld" , // change request -> a , request -> b , request -> c ); // change rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "sending back response: [%ld]" , ( long int ) response -> sum ); } int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_three_ints_server" ); // change rclcpp :: service < tutorial_interfaces :: srv :: addthreeints >:: sharedptr service = // change node -> create_service < tutorial_interfaces :: srv :: addthreeints > ( "add_three_ints" , & add ); // change rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "ready to add three ints." ); // change rclcpp :: spin ( node ); rclcpp :: shutdown (); } from tutorial_interfaces.srv import addthreeints # change import rclpy from rclpy.node import node class minimalservice ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_service' ) self . srv = self . create_service ( addthreeints , 'add_three_ints' , self . add_three_ints_callback ) # change def add_three_ints_callback ( self , request , response ): response . sum = request . a + request . b + request . c # change self . get_logger () . info ( 'incoming request \n a: %d b: %d c: %d ' % ( request . a , request . b , request . c )) # change return response def main ( args = none ): rclpy . init ( args = args ) minimal_service = minimalservice () rclpy . spin ( minimal_service ) rclpy . shutdown () if __name__ == '__main__' : main () client c++ python #include "rclcpp/rclcpp.hpp" #include "tutorial_interfaces/srv/add_three_ints.hpp" // change #include <chrono> #include <cstdlib> #include <memory> using namespace std :: chrono_literals ; int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); if ( argc != 4 ) { // change rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "usage: add_three_ints_client x y z" ); // change return 1 ; } std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_three_ints_client" ); // change rclcpp :: client < tutorial_interfaces :: srv :: addthreeints >:: sharedptr client = // change node -> create_client < tutorial_interfaces :: srv :: addthreeints > ( "add_three_ints" ); // change auto request = std :: make_shared < tutorial_interfaces :: srv :: addthreeints :: request > (); // change request -> a = atoll ( argv [ 1 ]); request -> b = atoll ( argv [ 2 ]); request -> c = atoll ( argv [ 3 ]); // change while ( ! client -> wait_for_service ( 1 s )) { if ( ! rclcpp :: ok ()) { rclcpp_error ( rclcpp :: get_logger ( "rclcpp" ), "interrupted while waiting for the service. exiting." ); return 0 ; } rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "service not available, waiting again..." ); } auto result = client -> async_send_request ( request ); // wait for the result. if ( rclcpp :: spin_until_future_complete ( node , result ) == rclcpp :: futurereturncode :: success ) { rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "sum: %ld" , result . get () -> sum ); } else { rclcpp_error ( rclcpp :: get_logger ( "rclcpp" ), "failed to call service add_three_ints" ); // change } rclcpp :: shutdown (); return 0 ; } from tutorial_interfaces.srv import addthreeints # change import sys import rclpy from rclpy.node import node class minimalclientasync ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_client_async' ) self . cli = self . create_client ( addthreeints , 'add_three_ints' ) # change while not self . cli . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . req = addthreeints . request () # change def send_request ( self ): self . req . a = int ( sys . argv [ 1 ]) self . req . b = int ( sys . argv [ 2 ]) self . req . c = int ( sys . argv [ 3 ]) # change self . future = self . cli . call_async ( self . req ) def main ( args = none ): rclpy . init ( args = args ) minimal_client = minimalclientasync () minimal_client . send_request () while rclpy . ok (): rclpy . spin_once ( minimal_client ) if minimal_client . future . done (): try : response = minimal_client . future . result () except exception as e : minimal_client . get_logger () . info ( 'service call failed %r ' % ( e ,)) else : minimal_client . get_logger () . info ( 'result of add_three_ints: for %d + %d + %d = %d ' % # change ( minimal_client . req . a , minimal_client . req . b , minimal_client . req . c , response . sum )) # change break minimal_client . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () cmakelists.txt add the following lines (c++ only): #... find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( tutorial_interfaces required ) # change add_executable ( server src/add_two_ints_server.cpp ) ament_target_dependencies ( server rclcpp tutorial_interfaces ) # change add_executable ( client src/add_two_ints_client.cpp ) ament_target_dependencies ( client rclcpp tutorial_interfaces ) # change install ( targets server client destination lib/ { project_name } ) ament_package () package.xml add the following line: c++ python < depend > tutorial_interfaces </ depend > < exec_depend > tutorial_interfaces </ exec_depend > after making the above edits and saving all the changes, build the package: c++ python on linux/macos: colcon build --packages-select cpp_srvcli on windows: colcon build --merge-install --packages-select cpp_srvcli on linux/macos: colcon build --packages-select py_srvcli on windows: colcon build --merge-install --packages-select py_srvcli then open two new terminals, source ros2_ws in each, and run: c++ python ros2 run cpp_srvcli server ros2 run cpp_srvcli client 2 3 1 ros2 run py_srvcli service ros2 run py_srvcli client 2 3 1 summary ï in this tutorial, you learned how to create custom interfaces in their own package and how to utilize those interfaces in other packages. this tutorial only scratches the surface  defining custom interfaces. you can learn more  it in  ros 2 interfaces . next steps ï the next tutorial covers more ways to use interfaces in ros 2. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling