tutorials intermediate tf2 writing a broadcaster (python) edit on github writing a broadcaster (python) ï goal: learn how to broadcast the state of a robot to tf2. tutorial level: intermediate time: 15 minutes background ï in the next two tutorials we will write the code to reproduce the demo from the introduction to tf2 tutorial. after that, the following tutorials focus on extending the demo with more advanced tf2 features, including the usage of timeouts in transformation lookups and time travel. prerequisites ï this tutorial assumes you have a working knowledge of ros 2 and you have completed the introduction to tf2 tutorial and tf2 static broadcaster tutorial (python) . weâll be reusing the learning_tf2_py package from that last tutorial. in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 write the broadcaster node ï letâs first create the source files. go to the learning_tf2_py package we created in the previous tutorial. inside the src/learning_tf2_py/learning_tf2_py directory download the example broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py -o turtle_tf2_broadcaster.py or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py -o turtle_tf2_broadcaster.py now open the file called turtle_tf2_broadcaster.py using your preferred text editor. import math from geometry_msgs.msg import transformstamped import numpy as np import rclpy from rclpy.node import node from tf2_ros import transformbroadcaster from turtlesim.msg import pose def quaternion_from_euler ( ai , aj , ak ): ai /= 2.0 aj /= 2.0 ak /= 2.0 ci = math . cos ( ai ) si = math . sin ( ai ) cj = math . cos ( aj ) sj = math . sin ( aj ) ck = math . cos ( ak ) sk = math . sin ( ak ) cc = ci * ck cs = ci * sk sc = si * ck ss = si * sk q = np . empty (( 4 , )) q [ 0 ] = cj * sc - sj * cs q [ 1 ] = cj * ss + sj * cc q [ 2 ] = cj * cs - sj * sc q [ 3 ] = cj * cc + sj * ss return q class framepublisher ( node ): def __init__ ( self ): super () . __init__ ( 'turtle_tf2_frame_publisher' ) # declare and acquire `turtlename` parameter self . turtlename = self . declare_parameter ( 'turtlename' , 'turtle' ) . get_parameter_value () . string_value # initialize the transform broadcaster self . tf_broadcaster = transformbroadcaster ( self ) # subscribe to a turtle{1}{2}/pose topic and call handle_turtle_pose # callback function on each message self .  = self . create_ ( pose , f '/ { self . turtlename } /pose' , self . handle_turtle_pose , 1 ) self .  # prevent unused variable warning def handle_turtle_pose ( self , msg ): t = transformstamped () # read message content and assign it to # corresponding tf variables t . header . stamp = self . get_clock () . now () . to_msg () t . header . frame_id = 'world' t . child_frame_id = self . turtlename # turtle only exists in 2d, thus we get x and y translation # coordinates from the message and set the z coordinate to 0 t . transform . translation . x = msg . x t . transform . translation . y = msg . y t . transform . translation . z = 0.0 # for the same reason, turtle can only rotate around one axis # and this why we set rotation in x and y to 0 and obtain # rotation in z axis from the message q = quaternion_from_euler ( 0 , 0 , msg . theta ) t . transform . rotation . x = q [ 0 ] t . transform . rotation . y = q [ 1 ] t . transform . rotation . z = q [ 2 ] t . transform . rotation . w = q [ 3 ] # send the transformation self . tf_broadcaster . sendtransform ( t ) def main (): rclpy . init () node = framepublisher () try : rclpy . spin ( node ) except keyboardinterrupt : pass rclpy . shutdown () 1.1 examine the code ï now, letâs take a look at the code that is relevant to publishing the turtle pose to tf2. firstly, we define and acquire a single parameter turtlename , which specifies a turtle name, e.g. turtle1 or turtle2 . self . turtlename = self . declare_parameter ( 'turtlename' , 'turtle' ) . get_parameter_value () . string_value afterward, the node subscribes to topic {self.turtlename}/pose and runs function handle_turtle_pose on every incoming message. self .  = self . create_ ( pose , f '/ { self . turtlename } /pose' , self . handle_turtle_pose , 1 ) now, we create a transformstamped object and give it the appropriate metadata. we need to give the transform being published a timestamp, and weâll just stamp it with the current time by calling self.get_clock().now() . this will return the current time used by the node . then we need to set the name of the parent frame of the link weâre creating, in this case world . finally, we need to set the name of the child node of the link weâre creating, in this case this is the name of the turtle itself. the handler function for the turtle pose message broadcasts this turtleâs translation and rotation, and publishes it as a transform from frame world to frame turtlex . t = transformstamped () # read message content and assign it to # corresponding tf variables t . header . stamp = self . get_clock () . now () . to_msg () t . header . frame_id = 'world' t . child_frame_id = self . turtlename here we copy the information from the 3d turtle pose into the 3d transform. # turtle only exists in 2d, thus we get x and y translation # coordinates from the message and set the z coordinate to 0 t . transform . translation . x = msg . x t . transform . translation . y = msg . y t . transform . translation . z = 0.0 # for the same reason, turtle can only rotate around one axis # and this why we set rotation in x and y to 0 and obtain # rotation in z axis from the message q = quaternion_from_euler ( 0 , 0 , msg . theta ) t . transform . rotation . x = q [ 0 ] t . transform . rotation . y = q [ 1 ] t . transform . rotation . z = q [ 2 ] t . transform . rotation . w = q [ 3 ] finally we take the transform that we constructed and pass it to the sendtransform method of the transformbroadcaster that will take care of broadcasting. # send the transformation self . tf_broadcaster . sendtransform ( t ) 1.2 add an entry point ï to allow the ros2 run command to run your node, you must add the entry point to setup.py (located in the src/learning_tf2_py directory). add the following line between the 'console_scripts': brackets: 'turtle_tf2_broadcaster = learning_tf2_py.turtle_tf2_broadcaster:main' , 2 write the launch file ï now create a launch file for this demo. create a launch folder in the src/learning_tf2_py directory. with your text editor, create a new file called turtle_tf2_demo_launch.py in the launch folder, and add the following lines: from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' ), node ( package = 'learning_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), ]) 2.1 examine the code ï first we import required modules from the launch and launch_ros packages. it should be noted that launch is a generic launching framework (not ros 2 specific) and launch_ros has ros 2 specific things, like nodes that we import here. from launch import launchdescription from launch_ros.actions import node now we run our nodes that start the turtlesim simulation and broadcast turtle1 state to the tf2 using our turtle_tf2_broadcaster node. node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' ), node ( package = 'learning_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), 2.2 add dependencies ï navigate one level back to the learning_tf2_py directory, where the setup.py , setup.cfg , and package.xml files are located. open package.xml with your text editor. add the following dependencies corresponding to your launch fileâs import statements: <exec_depend> launch </exec_depend> <exec_depend> launch_ros </exec_depend> this declares the additional required launch and launch_ros dependencies when its code is executed. make sure to save the file. 2.3 update setup.py ï reopen setup.py and add the line so that the launch files from the launch/ folder will be installed. the data_files field should now look like this: data_files = [ ... ( os . path . join ( 'share' , package_name , 'launch' ), glob ( os . path . join ( 'launch' , '*launch.[pxy][yma]*' ))), ], also add the appropriate imports at the top of the file: import os from glob import glob you can learn more  creating launch files in this tutorial . 3 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your package: linux macos windows colcon build --packages-select learning_tf2_py colcon build --packages-select learning_tf2_py colcon build --merge-install --packages-select learning_tf2_py open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 4 run ï now run the launch file that will start the turtlesim simulation node and turtle_tf2_broadcaster node: ros2 launch learning_tf2_py turtle_tf2_demo_launch.py in the second terminal window type the following command: ros2 run turtlesim turtle_teleop_key you will now see that the turtlesim simulation has started with one turtle that you can control. now, use the tf2_echo tool to check if the turtle pose is actually getting broadcast to tf2: ros2 run tf2_ros tf2_echo world turtle1 this should show you the pose of the first turtle. drive around the turtle using the arrow keys (make sure your turtle_teleop_key terminal window is active, not your simulator window). in your console output you will see something similar to this: at time 1714913843.708748879 - translation: [4.541, 3.889, 0.000] - rotation: in quaternion [0.000, 0.000, 0.999, -0.035] - rotation: in rpy (radian) [0.000, -0.000, -3.072] - rotation: in rpy (degree) [0.000, -0.000, -176.013] - matrix: -0.998 0.070 0.000 4.541 -0.070 -0.998 0.000 3.889 0.000 0.000 1.000 0.000 0.000 0.000 0.000 1.000 if you run tf2_echo for the transform between the world and turtle2 , you should not see a transform, because the second turtle is not there yet. however, as soon as we add the second turtle in the next tutorial, the pose of turtle2 will be broadcast to tf2. summary ï in this tutorial you learned how to broadcast the pose of the robot (position and orientation of the turtle) to tf2 and how to use the tf2_echo tool. to actually use the transforms broadcasted to tf2, you should move on to the next tutorial  creating a tf2 listener . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling