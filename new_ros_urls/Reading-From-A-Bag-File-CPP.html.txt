tutorials advanced reading from a bag file (c++) edit on github reading from a bag file (c++) ï goal: read data from a bag without using the cli. tutorial level: advanced time: 10 minutes background ï rosbag2 doesnât just provide the ros2 bag command line tool. it also provides a c++ api for reading from and writing to a bag from your own source code. this allows you to read the contents from a bag without having to play the bag, which can sometimes be useful. prerequisites ï you should have the rosbag2 packages installed as part of your regular ros 2 setup. if you need to install ros 2, see the installation instructions . you should have already completed the basic ros 2 bag tutorial , and we will be using the subset bag you created there. tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. in a new or existing workspace , navigate to the src directory and create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 bag_reading_cpp --dependencies rclcpp rosbag2_transport turtlesim your terminal will return a message verifying the creation of your package bag_reading_cpp and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml and cmakelists.txt . in this case, the package will use the rosbag2_transport package as well as the rclcpp package. a dependency on the turtlesim package is also required for working with the custom turtlesim messages. 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml or cmakelists.txt . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> c++ bag reading tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 2 write the c++ reader ï inside your packageâs src directory, create a new file called simple_bag_reader.cpp and paste the following code into it. #include <chrono> #include <functional> #include <iostream> #include <memory> #include <string> #include "rclcpp/rclcpp.hpp" #include "rclcpp/serialization.hpp" #include "rosbag2_transport/reader_writer_factory.hpp" #include "turtlesim/msg/pose.hpp" using namespace std :: chrono_literals ; class playbacknode : public rclcpp :: node { public : playbacknode ( const std :: string & bag_filename ) : node ( "playback_node" ) { publisher_ = this -> create_publisher < turtlesim :: msg :: pose > ( "/turtle1/pose" , 10 ); timer_ = this -> create_wall_timer ( 100 ms , [ this ](){ return this -> timer_callback ();} ); rosbag2_storage :: storageoptions storage_options ; storage_options . uri = bag_filename ; reader_ = rosbag2_transport :: readerwriterfactory :: make_reader ( storage_options ); reader_ -> open ( storage_options ); } private : void timer_callback () { while ( reader_ -> has_next ()) { rosbag2_storage :: serializedbagmessagesharedptr msg = reader_ -> read_next (); if ( msg -> topic_name != "/turtle1/pose" ) { continue ; } rclcpp :: serializedmessage serialized_msg ( * msg -> serialized_data ); turtlesim :: msg :: pose :: sharedptr ros_msg = std :: make_shared < turtlesim :: msg :: pose > (); serialization_ . deserialize_message ( & serialized_msg , ros_msg . get ()); publisher_ -> publish ( * ros_msg ); std :: cout << '(' << ros_msg -> x << ", " << ros_msg -> y << ") \n " ; break ; } } rclcpp :: timerbase :: sharedptr timer_ ; rclcpp :: publisher < turtlesim :: msg :: pose >:: sharedptr publisher_ ; rclcpp :: serialization < turtlesim :: msg :: pose > serialization_ ; std :: unique_ptr < rosbag2_cpp :: reader > reader_ ; }; int main ( int argc , char ** argv ) { if ( argc != 2 ) { std :: cerr << "usage: " << argv [ 0 ] << " <bag>" << std :: endl ; return 1 ; } rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < playbacknode > ( argv [ 1 ])); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï the #include statements at the top are the package dependencies. note the inclusion of headers from the rosbag2_transport package for the functions and structures necessary to work with bag files. the next line creates the node which will read from the bag file and play back the data. class playbacknode : public rclcpp :: node now, we can create a timer callback which will run at 10 hz. our goal is to replay one message to the /turtle1/pose topic each time the callback is run. note the constructor takes a path to the bag file as a parameter. public : playbacknode ( const std :: string & bag_filename ) : node ( "playback_node" ) { publisher_ = this -> create_publisher < turtlesim :: msg :: pose > ( "/turtle1/pose" , 10 ); timer_ = this -> create_wall_timer ( 100 ms , [ this ](){ return this -> timer_callback ();} ); we also open the bag in the constructor. the rosbag2_transport::readerwriterfactory is a class that can construct a compressed or uncompressed reader or writer based on the storage options. rosbag2_storage :: storageoptions storage_options ; storage_options . uri = bag_filename ; reader_ = rosbag2_transport :: readerwriterfactory :: make_reader ( storage_options ); reader_ -> open ( storage_options ); now, inside our timer callback, we loop through messages in the bag until we read a message recorded from our desired topic. note that the serialized message has timestamp metadata in addition to the topic name. void timer_callback () { while ( reader_ -> has_next ()) { rosbag2_storage :: serializedbagmessagesharedptr msg = reader_ -> read_next (); if ( msg -> topic_name != "/turtle1/pose" ) { continue ; } we then construct an rclcpp::serializedmessage object from the serialized data we just read. additionally, we need to create a ros 2 deserialized message which will hold the result of our deserialization. then, we can pass both these objects to the rclcpp::serialization::deserialize_message method. rclcpp :: serializedmessage serialized_msg ( * msg -> serialized_data ); turtlesim :: msg :: pose :: sharedptr ros_msg = std :: make_shared < turtlesim :: msg :: pose > (); serialization_ . deserialize_message ( & serialized_msg , ros_msg . get ()); finally, we publish the deserialized message and print out the xy coordinate to the terminal. we also break out of the loop so that we publish the next message during the next timer calback. publisher_ -> publish ( * ros_msg ); std :: cout << '(' << ros_msg -> x << ", " << ros_msg -> y << ") \n " ; break ; } we must also declare the private variables used throughout the node. rclcpp :: timerbase :: sharedptr timer_ ; rclcpp :: publisher < turtlesim :: msg :: pose >:: sharedptr publisher_ ; rclcpp :: serialization < turtlesim :: msg :: pose > serialization_ ; std :: unique_ptr < rosbag2_cpp :: reader > reader_ ; }; lastly, we create the main function which will check that the user passes an argument for the bag file path and spins our node. int main ( int argc , char ** argv ) { if ( argc != 2 ) { std :: cerr << "usage: " << argv [ 0 ] << " <bag>" << std :: endl ; return 1 ; } rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < playbacknode > ( argv [ 1 ])); rclcpp :: shutdown (); return 0 ; } 2.2 add executable ï now open the cmakelists.txt file. below the dependencies block, which contains find_package(rosbag2_transport required) , add the following lines of code. add_executable(simple_bag_reader src/simple_bag_reader.cpp) ament_target_dependencies(simple_bag_reader rclcpp rosbag2_transport turtlesim) install(targets simple_bag_reader destination lib/{project_name} ) 3 build and run ï navigate back to the root of your workspace and build your new package. linux macos windows colcon build --packages-select bag_reading_cpp colcon build --packages-select bag_reading_cpp colcon build --merge-install --packages-select bag_reading_cpp next, source the setup files. linux macos windows source install/setup.bash source install/setup.bash call install/setup.bat now, run the script. make sure to replace /path/to/subset with the path to your subset bag. ros2 run bag_reading_cpp simple_bag_reader /path/to/subset you should see the (x, y) coordinates of the turtle printed to the console. summary ï you created a c++ executable that reads data from a bag. you then compiled and ran the executable which printed some information from the bag to the console. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling