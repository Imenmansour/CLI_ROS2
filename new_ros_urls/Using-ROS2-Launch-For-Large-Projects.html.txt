tutorials intermediate launch managing large projects edit on github managing large projects ï goal: learn best practices of managing large projects using ros 2 launch files. tutorial level: intermediate time: 20 minutes background ï this tutorial describes some tips for writing launch files for large projects. the focus is on how to structure launch files so they may be reused as much as possible in different situations. additionally, it covers usage examples of different ros 2 launch tools, like parameters, yaml files, remappings, namespaces, default arguments, and rviz configs. prerequisites ï this tutorial uses the turtlesim and turtle_tf2_py packages. this tutorial also assumes you have created a new package of build type ament_python called launch_tutorial . introduction ï large applications on a robot typically involve several interconnected nodes, each of which can have many parameters. simulation of multiple turtles in the turtle simulator can serve as a good example. the turtle simulation consists of multiple turtle nodes, the world configuration, and the tf broadcaster and listener nodes. between all of the nodes, there are a large number of ros parameters that affect the behavior and appearance of these nodes. ros 2 launch files allow us to start all nodes and set corresponding parameters in one place. by the end of a tutorial, you will build the launch_turtlesim_launch.py launch file in the launch_tutorial package. this launch file will bring up different nodes responsible for the simulation of two turtlesim simulations, starting tf broadcasters and listener, loading parameters, and launching an rviz configuration. in this tutorial, weâll go over this launch file and all related features used. writing launch files ï 1 top-level organization ï one of the aims in the process of writing launch files should be making them as reusable as possible. this could be done by clustering related nodes and configurations into separate launch files. afterwards, a top-level launch file dedicated to a specific configuration could be written. this would allow moving between identical robots to be done without changing the launch files at all. even a change such as moving from a real robot to a simulated one can be done with only a few changes. we will now go over the top-level launch file structure that makes this possible. firstly, we will create a launch file that will call separate launch files. to do this, letâs create a launch_turtlesim_launch.py file in the /launch folder of our launch_tutorial package. import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch.actions import includelaunchdescription from launch.launch_description_sources import pythonlaunchdescriptionsource def generate_launch_description (): turtlesim_world_1 = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/turtlesim_world_1_launch.py' ]) ) turtlesim_world_2 = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/turtlesim_world_2_launch.py' ]) ) broadcaster_listener_nodes = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/broadcaster_listener_launch.py' ]), launch_arguments = { 'target_frame' : 'carrot1' } . items (), ) mimic_node = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/mimic_launch.py' ]) ) fixed_frame_node = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/fixed_broadcaster_launch.py' ]) ) rviz_node = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/turtlesim_rviz_launch.py' ]) ) return launchdescription ([ turtlesim_world_1 , turtlesim_world_2 , broadcaster_listener_nodes , mimic_node , fixed_frame_node , rviz_node ]) this launch file includes a set of other launch files. each of these included launch files contains nodes, parameters, and possibly, nested includes, which pertain to one part of the system. to be exact, we launch two turtlesim simulation worlds, tf broadcaster, tf listener, mimic, fixed frame broadcaster, and rviz nodes. note design tip: top-level launch files should be short, consist of includes to other files corresponding to subcomponents of the application, and commonly changed parameters. writing launch files in the following manner makes it easy to swap out one piece of the system, as weâll see later. however, there are cases when some nodes or launch files have to be launched separately due to performance and usage reasons. note design tip: be aware of the tradeoffs when deciding how many top-level launch files your application requires. 2 parameters ï 2.1 setting parameters in the launch file ï we will begin by writing a launch file that will start our first turtlesim simulation. first, create a new file called turtlesim_world_1_launch.py . from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import launchconfiguration , textsubstitution from launch_ros.actions import node def generate_launch_description (): background_r_launch_arg = declarelaunchargument ( 'background_r' , default_value = textsubstitution ( text = '0' ) ) background_g_launch_arg = declarelaunchargument ( 'background_g' , default_value = textsubstitution ( text = '84' ) ) background_b_launch_arg = declarelaunchargument ( 'background_b' , default_value = textsubstitution ( text = '122' ) ) return launchdescription ([ background_r_launch_arg , background_g_launch_arg , background_b_launch_arg , node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' , parameters = [{ 'background_r' : launchconfiguration ( 'background_r' ), 'background_g' : launchconfiguration ( 'background_g' ), 'background_b' : launchconfiguration ( 'background_b' ), }] ), ]) this launch file starts the turtlesim_node node, which starts the turtlesim simulation, with simulation configuration parameters that are defined and passed to the nodes. 2.2 loading parameters from yaml file ï in the second launch, we will start a second turtlesim simulation with a different configuration. now create a turtlesim_world_2_launch.py file. import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): config = os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'config' , 'turtlesim.yaml' ) return launchdescription ([ node ( package = 'turtlesim' , executable = 'turtlesim_node' , namespace = 'turtlesim2' , name = 'sim' , parameters = [ config ] ) ]) this launch file will launch the same turtlesim_node with parameter values that are loaded directly from the yaml configuration file. defining arguments and parameters in yaml files make it easy to store and load a large number of variables. in addition, yaml files can be easily exported from the current ros2 param list. to learn how to do that, refer to the understand parameters tutorial. letâs now create a configuration file, turtlesim.yaml , in the /config folder of our package, which will be loaded by our launch file. /turtlesim2/sim : ros__parameters : background_b : 255 background_g : 86 background_r : 150 to learn more  using parameters and using yaml files, take a look at the understand parameters tutorial. 2.3 using wildcards in yaml files ï there are cases when we want to set the same parameters in more than one node. these nodes could have different namespaces or names but still have the same parameters. defining separate yaml files that explicitly define namespaces and node names is not efficient. a solution is to use wildcard characters, which act as substitutions for unknown characters in a text value, to apply parameters to several different nodes. now letâs create a new turtlesim_world_3_launch.py file similar to turtlesim_world_2_launch.py to include one more turtlesim_node node. ... node ( package = 'turtlesim' , executable = 'turtlesim_node' , namespace = 'turtlesim3' , name = 'sim' , parameters = [ config ] ) loading the same yaml file, however, will not affect the appearance of the third turtlesim world. the reason is that its parameters are stored under another namespace as shown below: /turtlesim3/sim: background_b background_g background_r therefore, instead of creating a new configuration for the same node that use the same parameters, we can use wildcards syntax. /** will assign all the parameters in every node, despite differences in node names and namespaces. we will now update the turtlesim.yaml , in the /config folder in the following manner: /** : ros__parameters : background_b : 255 background_g : 86 background_r : 150 now include the turtlesim_world_3_launch.py launch description in our main launch file. using that configuration file in our launch descriptions will assign background_b , background_g , and background_r parameters to specified values in turtlesim3/sim and turtlesim2/sim nodes. 3 namespaces ï as you may have noticed, we have defined the namespace for the turlesim world in the turtlesim_world_2_launch.py file. unique namespaces allow the system to start two similar nodes without node name or topic name conflicts. namespace = 'turtlesim2' , however, if the launch file contains a large number of nodes, defining namespaces for each of them can become tedious. to solve that issue, the pushrosnamespace action can be used to define the global namespace for each launch file description. every nested node will inherit that namespace automatically. to do that, firstly, we need to remove the namespace='turtlesim2' line from the turtlesim_world_2_launch.py file. afterwards, we need to update the launch_turtlesim_launch.py to include the following lines: from launch.actions import groupaction from launch_ros.actions import pushrosnamespace ... turtlesim_world_2 = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/turtlesim_world_2_launch.py' ]) ) turtlesim_world_2_with_namespace = groupaction ( actions = [ pushrosnamespace ( 'turtlesim2' ), turtlesim_world_2 , ] ) finally, we replace the turtlesim_world_2 to turtlesim_world_2_with_namespace in the return launchdescription statement. as a result, each node in the turtlesim_world_2_launch.py launch description will have a turtlesim2 namespace. 4 reusing nodes ï now create a broadcaster_listener_launch.py file. from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import launchconfiguration from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ declarelaunchargument ( 'target_frame' , default_value = 'turtle1' , description = 'target frame name.' ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster2' , parameters = [ { 'turtlename' : 'turtle2' } ] ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_listener' , name = 'listener' , parameters = [ { 'target_frame' : launchconfiguration ( 'target_frame' )} ] ), ]) in this file, we have declared the target_frame launch argument with a default value of turtle1 . the default value means that the launch file can receive an argument to forward to its nodes, or in case the argument is not provided, it will pass the default value to its nodes. afterwards, we use the turtle_tf2_broadcaster node two times using different names and parameters during launch. this allows us to duplicate the same node without conflicts. we also start a turtle_tf2_listener node and set its target_frame parameter that we declared and acquired above. 5 parameter overrides ï recall that we called the broadcaster_listener_launch.py file in our top-level launch file. in addition to that, we have passed it target_frame launch argument as shown below: broadcaster_listener_nodes = includelaunchdescription ( pythonlaunchdescriptionsource ([ os . path . join ( get_package_share_directory ( 'launch_tutorial' ), 'launch' ), '/broadcaster_listener_launch.py' ]), launch_arguments = { 'target_frame' : 'carrot1' } . items (), ) this syntax allows us to change the default goal target frame to carrot1 . if you would like turtle2 to follow turtle1 instead of the carrot1 , just remove the line that defines launch_arguments . this will assign target_frame its default value, which is turtle1 . 6 remapping ï now create a mimic_launch.py file. from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'turtlesim' , executable = 'mimic' , name = 'mimic' , remappings = [ ( '/input/pose' , '/turtle2/pose' ), ( '/output/cmd_vel' , '/turtlesim2/turtle1/cmd_vel' ), ] ) ]) this launch file will start the mimic node, which will give commands to one turtlesim to follow the other. the node is designed to receive the target pose on the topic /input/pose . in our case, we want to remap the target pose from /turtle2/pose topic. finally, we remap the /output/cmd_vel topic to /turtlesim2/turtle1/cmd_vel . this way turtle1 in our turtlesim2 simulation world will follow turtle2 in our initial turtlesim world. 7 config files ï letâs now create a file called turtlesim_rviz_launch.py . import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): rviz_config = os . path . join ( get_package_share_directory ( 'turtle_tf2_py' ), 'rviz' , 'turtle_rviz.rviz' ) return launchdescription ([ node ( package = 'rviz2' , executable = 'rviz2' , name = 'rviz2' , arguments = [ '-d' , rviz_config ] ) ]) this launch file will start the rviz with the configuration file defined in the turtle_tf2_py package. this rviz configuration will set the world frame, enable tf visualization, and start rviz with a top-down view. 8 environment variables ï letâs now create the last launch file called fixed_broadcaster_launch.py in our package. from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import environmentvariable , launchconfiguration from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ declarelaunchargument ( 'node_prefix' , default_value = [ environmentvariable ( 'user' ), '_' ], description = 'prefix for node name' ), node ( package = 'turtle_tf2_py' , executable = 'fixed_frame_tf2_broadcaster' , name = [ launchconfiguration ( 'node_prefix' ), 'fixed_broadcaster' ], ), ]) this launch file shows the way environment variables can be called inside the launch files. environment variables can be used to define or push namespaces for distinguishing nodes on different computers or robots. note if you are running the launch file where the user environment variable is not defined (like in the ros docker file), then you can replace the environmentvariable('user') above with any other word of your liking. running launch files ï 1 update setup.py ï open setup.py and add the following lines so that the launch files from the launch/ folder and configuration file from the config/ would be installed. the data_files field should now look like this: import os from glob import glob from setuptools import setup ... data_files = [ ... ( os . path . join ( 'share' , package_name , 'launch' ), glob ( os . path . join ( 'launch' , '*launch.[pxy][yma]*' ))), ( os . path . join ( 'share' , package_name , 'config' ), glob ( os . path . join ( 'config' , '*.yaml' ))), ( os . path . join ( 'share' , package_name , 'rviz' ), glob ( os . path . join ( 'config' , '*.rviz' ))), ], 2 build and run ï to finally see the result of our code, build the package and launch the top-level launch file using the following command: ros2 launch launch_tutorial launch_turtlesim_launch.py you will now see the two turtlesim simulations started. there are two turtles in the first one and one in the second one. in the first simulation, turtle2 is spawned in the bottom-left part of the world. its aim is to reach the carrot1 frame which is five meters away on the x-axis relative to the turtle1 frame. the turtlesim2/turtle1 in the second is designed to mimic the behavior of the turtle2 . if you want to control the turtle1 , run the teleop node. ros2 run turtlesim turtle_teleop_key as a result, you will see a similar picture: in addition to that, the rviz should have started. it will show all turtle frames relative to the world frame, whose origin is at the bottom-left corner. summary ï in this tutorial, you learned  various tips and practices of managing large projects using ros 2 launch files. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling