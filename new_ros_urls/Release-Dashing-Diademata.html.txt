distributions end-of-life distributions dashing diademata ( dashing ) edit on github dashing diademata ( dashing ) ï dashing diademata is the fourth release of ros 2. supported platforms ï dashing diademata is primarily supported on the following platforms: tier 1 platforms: ubuntu 18.04 (bionic): amd64 and arm64 mac macos 10.12 (sierra) windows 10 (visual studio 2019) tier 2 platforms: ubuntu 18.04 (bionic): arm32 tier 3 platforms: debian stretch (9): amd64 , arm64 and arm32 openembedded thud (2.6) / webos ose: arm32 and x86 for more information  rmw implementations, compiler / interpreter versions, and system dependency versions see rep 2000 . installation ï install dashing diademata new features in this ros 2 release ï a few features and improvements we would like to highlight: components are now the recommended way to write your node. they can be used standalone as well as being composed within a process and both ways are fully support from launch files. the intra-process communication (c++ only) has been improved - both in  of latency as well as minimizing copies. the python client library has been updated to match most of the c++ equivalent and some important bug fixes and improvements have landed related to memory usage and performance. parameters are now a complete alternative to dynamic_reconfigure from ros 1 including constraints like ranges or being read-only. by relying on (a subset of) idl 4.2 for the message generation pipeline it is now possible to use .idl files (beside .msg / .srv / .action files). this change comes with support for optional utf-8 encoding for ordinary strings as well as utf-16 encoded multi-byte strings (see wide strings design article ). command line tools related to actions and components . support for deadline, lifespan & liveliness quality of service settings. moveit 2 alpha release .  see the dashing meta ticket on github, which contains more information as well as references to specific tickets with additional details. changes since the crystal release ï declaring parameters ï there have been some changes to the behavior of parameters starting in dashing, which have also lead to some new apiâs and the deprecation of other apiâs. see the rclcpp and rclpy sections below for more information  api changes. getting and setting undeclared parameters ï as of dashing, parameters now need to be declared before being accessed or set. before dashing, you could call get_parameter(name) and get either a value, if it had been previously set, or a parameter of type parameter_not_set . you could also call set_parameter(name, value) at any point, even if the parameter was previously unset. since dashing, you need to first declare a parameter before getting or setting it. if you try to get or set an undeclared parameter you will either get an exception thrown, e.g. parameternotdeclaredexception, or in certain cases you will get an unsuccessful result communicated in a variety of ways (see specific functions for more details). however, you can get the old behavior (mostly, see the note in the next paragraph) by using the allow_undeclared_parameters option when creating your node. you might want to do this in order to avoid code changes for now, or in order to fulfill some uncommon use cases. for example, a âglobal parameter serverâ or âparameter blackboardâ may want to allow external nodes to set new parameters on itself without first declaring them, so it may use the allow_undeclared_parameters option to accomplish that. in most cases, however, this option is not recommended because it makes the rest of the parameter api less safe to bugs like parameter name typos and âuse before setâ logical errors. note that using allow_undeclared_parameters will get you most of the old behavior specifically for âgetâ and âsetâ methods, but it will not revert all the behavior changes related to parameters back to how it was for ros crystal. for that you need to also set the automatically_declare_parameters_from_overrides option to true , which is described below in parameter configuration using a yaml file . declaring a parameter with a parameterdescriptor ï another benefit to declaring your parameters before using them, is that it allows you to declare a parameter descriptor at the same time. now when declaring a parameter you may include a custom parameterdescriptor as well as a name and default value. the parameterdescriptor is defined as a message in rcl_interfaces/msg/parameterdescriptor and contains meta data like description and constraints like read_only or integer_range . these constraints can be used to reject invalid values when setting parameters and/or as hints to external tools  what values are valid for a given parameter. the read_only constraint will prevent the parameterâs value from changing after being declared, as well as prevent if from being undeclared. for reference, hereâs a link to the parameterdescriptor message as of the time of writing this: https://github.com/ros2/rcl_interfaces/blob/0aba5a142878c2077d7a03977087e7d74d40ee68/rcl_interfaces/msg/parameterdescriptor.msg#l1 parameter configuration using a yaml file ï as of dashing, parameters in a yaml configuration file, e.g. passed to the node via the command line argument __params:= , are only used to override a parameterâs default value when declaring the parameter. before dashing, any parameters you passed via a yaml file would be implicitly set on the node. since dashing, this is no longer the case, as parameters need to be declared in order to appear on the node to external observers, like ros2 param list . the old behavior may be achieved using the automatically_declare_parameters_from_overrides option when creating a node. this option, if set to true , will automatically declare all parameters in the input yaml file when the node is constructed. this may be used to avoid major changes to your existing code or to serve specific use cases. for example, a âglobal parameter serverâ may want to be seeded with arbitrary parameters on launch, which it could not have declared ahead of time. most of the time, however, this option is not recommended, as it may lead to setting a parameter in a yaml file with the assumption that the node will use it, even if the node does not actually use it. in the future we hope to have a checker that will warn you if you pass a parameter to a node that it was not expecting. the parameters in the yaml file will continue to influence the value of parameters when they are first declared. ament_cmake ï the cmake function ament_index_has_resource was returning either true or false . as of this release it returns either the prefix path in case the resource was found or false . if you are using the return value in a cmake condition like this: ament_index_has_resource ( var ... ) if ( { var } ) you need to update the condition to ensure it considers a string value as true : if ( var ) rclcpp ï behavior change for node::get_node_names() ï the function nodegraph::get_node_names() , and therefore also node::get_node_names() , now returns a std::vector<std::string> containing fully qualified node names with their namespaces included, instead of just the node names. changed the way that options are passed to nodes ï extended arguments (beyond name and namespace) to the rclcpp::node() constructor have been replaced with a rclcpp::nodeoptions structure. see ros2/rclcpp#622 for details  the structure and default values of the options. if you are using any of the extended arguments to rclcpp::node() like this: auto context = rclcpp :: contexts :: default_context :: get_global_default_context (); std :: vector < std :: string > args ; std :: vector < rclcpp :: parameter > params = { rclcpp :: parameter ( "use_sim_time" , true ) }; auto node = std :: make_shared < rclcpp :: node > ( "foo_node" , "bar_namespace" , context , args , params ); you need to update to use the nodeoptions structure std :: vector < std :: string > args ; std :: vector < rclcpp :: parameter > params = { rclcpp :: parameter ( "use_sim_time" , true ) }; rclcpp :: nodeoptions node_options ; node_options . arguments ( args ); node_options . parameter_overrides ( params ); auto node = std :: make_shared < rclcpp :: node > ( "foo_node" , "bar_namespace" , node_options ); changes to creating publishers and s ï there have been a few changes to creating publishers and s which are new in dashing: qos settings are now passed using the new rclcpp::qos class, and the api encourages the user to specify at least the history depth. options are now passed as an object, i.e. rclcpp::publisheroptions and rclcpp::options . all changes are backwards compatible (no code changes are required), but several existing call styles have been deprecated. users are encouraged to update to the new signatures. in the past, when creating a publisher or , you could either not specify any qos settings (e.g. just provide topic name for a publisher) or you could specify a âqos profileâ data structure (of type rmw_qos_profile_t ) with all the settings already set. now you must use the new rclcpp::qos object to specify your qos and at least the history settings for your qos. this encourages the user to specify a history depth when using keep_last , rather than defaulting it to a value that may or may not be appropriate. in ros 1, this was known as the queue_size and it was required in both c++ and python. weâre changing the ros 2 api to bring this requirement back. also, any options which could previously be passed during creation of a publisher or  have now been encapsulated in an rclcpp::publisheroptions and rclcpp::options class respectively. this allows for shorter signatures, more convenient use, and for adding new future options without breaking api. some signatures for creating publishers and subscribers are now deprecated, and new signatures have been added to allow you to use the new rclcpp::qos and publisher/ option classes. these are the new and recommended apiâs: template < typename messaget , typename allocatort = std :: allocator < void > , typename publishert = :: rclcpp :: publisher < messaget , allocatort >> std :: shared_ptr < publishert > create_publisher ( const std :: string & topic_name , const rclcpp :: qos & qos , const publisheroptionswithallocator < allocatort > & options = publisheroptionswithallocator < allocatort > () ); template < typename messaget , typename callbackt , typename allocatort = std :: allocator < void > , typename t = rclcpp ::  < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , allocatort >> std :: shared_ptr < t > create_ ( const std :: string & topic_name , const rclcpp :: qos & qos , callbackt && callback , const optionswithallocator < allocatort > & options = optionswithallocator < allocatort > (), typename rclcpp :: message_memory_strategy :: messagememorystrategy < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , allocatort >:: sharedptr msg_mem_strat = nullptr ); and these are the deprecated ones: template < typename messaget , typename allocatort = std :: allocator < void > , typename publishert = :: rclcpp :: publisher < messaget , allocatort >> [[ deprecated ( "use create_publisher(const std::string &, const rclcpp::qos &, ...) instead" )]] std :: shared_ptr < publishert > create_publisher ( const std :: string & topic_name , size_t qos_history_depth , std :: shared_ptr < allocatort > allocator ); template < typename messaget , typename allocatort = std :: allocator < void > , typename publishert = :: rclcpp :: publisher < messaget , allocatort >> [[ deprecated ( "use create_publisher(const std::string &, const rclcpp::qos &, ...) instead" )]] std :: shared_ptr < publishert > create_publisher ( const std :: string & topic_name , const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default , std :: shared_ptr < allocatort > allocator = nullptr ); template < typename messaget , typename callbackt , typename alloc = std :: allocator < void > , typename t = rclcpp ::  < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , alloc >> [[ deprecated ( "use create_(const std::string &, const rclcpp::qos &, callbackt, ...) instead" )]] std :: shared_ptr < t > create_ ( const std :: string & topic_name , callbackt && callback , const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default , rclcpp :: callback_group :: callbackgroup :: sharedptr group = nullptr , bool ignore_local_publications = false , typename rclcpp :: message_memory_strategy :: messagememorystrategy < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , alloc >:: sharedptr msg_mem_strat = nullptr , std :: shared_ptr < alloc > allocator = nullptr ); template < typename messaget , typename callbackt , typename alloc = std :: allocator < void > , typename t = rclcpp ::  < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , alloc >> [[ deprecated ( "use create_(const std::string &, const rclcpp::qos &, callbackt, ...) instead" )]] std :: shared_ptr < t > create_ ( const std :: string & topic_name , callbackt && callback , size_t qos_history_depth , rclcpp :: callback_group :: callbackgroup :: sharedptr group = nullptr , bool ignore_local_publications = false , typename rclcpp :: message_memory_strategy :: messagememorystrategy < typename rclcpp :: _traits :: has_message_type < callbackt >:: type , alloc >:: sharedptr msg_mem_strat = nullptr , std :: shared_ptr < alloc > allocator = nullptr ); the change to how qos is passed is most likely to impact users. a typical change for a publisher looks like this: - pub_ = create_publisher<std_msgs::msg::string>("chatter"); + pub_ = create_publisher<std_msgs::msg::string>("chatter", 10); and for a : - sub_ = create_<std_msgs::msg::string>("chatter", callback); + sub_ = create_<std_msgs::msg::string>("chatter", 10, callback); if you have no idea what depth to use and donât care right now (maybe just prototyping), then we recommend using 10 , as that was the default before and should preserve existing behavior. more in depth documentation  how to select an appropriate depth is forthcoming. this is an example of a slightly more involved change to avoid the newly deprecated apiâs: - // creates a latched topic - rmw_qos_profile_t qos = rmw_qos_profile_default; - qos.depth = 1; - qos.durability = rmw_qos_policy_durability_transient_local; - model_xml_.data = model_xml; node_handle->declare_parameter("robot_description", model_xml); description_pub_ = node_handle->create_publisher<std_msgs::msg::string>( - "robot_description", qos); + "robot_description", + // transient local is similar to latching in ros 1. + rclcpp::qos(1).transient_local()); see the pull request (and connected pull requests) that introduced the qos change for more examples and details: https://github.com/ros2/rclcpp/pull/713 https://github.com/ros2/demos/pull/332 https://github.com/ros2/robot_state_publisher/pull/19 and othersâ changes due to declare parameter change ï for details  the actual behavior change, see declaring parameters above. there are several new api calls in the rclcpp::node âs interface: methods that declare parameters given a name, optional default value, optional descriptor, and return the value actually set: const rclcpp :: parametervalue & rclcpp::node::declare_parameter ( const std :: string & name , const rclcpp :: parametervalue & default_value = rclcpp :: parametervalue (), const rcl_interfaces :: msg :: parameterdescriptor & parameter_descriptor = rcl_interfaces :: msg :: parameterdescriptor ()); template < typename parametert > auto rclcpp :: node :: declare_parameter ( const std :: string & name , const parametert & default_value , const rcl_interfaces :: msg :: parameterdescriptor & parameter_descriptor = rcl_interfaces :: msg :: parameterdescriptor ()); template < typename parametert > std :: vector < parametert > rclcpp :: node :: declare_parameters ( const std :: string & namespace_ , const std :: map < std :: string , parametert > & parameters ); template < typename parametert > std :: vector < parametert > rclcpp :: node :: declare_parameters ( const std :: string & namespace_ , const std :: map < std :: string , std :: pair < parametert , rcl_interfaces :: msg :: parameterdescriptor > > & parameters ); a method to undeclare parameters and to check if a parameter has been declared: void rclcpp::node::undeclare_parameter ( const std :: string & name ); bool rclcpp::node::has_parameter ( const std :: string & name ) const ; some convenience methods that did not previously exist: rcl_interfaces :: msg :: setparametersresult rclcpp::node::set_parameter ( const rclcpp :: parameter & parameter ); std :: vector < rclcpp :: parameter > rclcpp :: node :: get_parameters ( const std :: vector < std :: string > & names ) const ; rcl_interfaces :: msg :: parameterdescriptor rclcpp::node::describe_parameter ( const std :: string & name ) const ; a new method to set the callback which is called anytime a parameter will be changed, giving you the opportunity to reject it: using onparameterssetcallbacktype = rclcpp :: node_interfaces :: nodeparametersinterface :: onparameterssetcallbacktype ; onparameterssetcallbacktype rclcpp::node::set_on_parameters_set_callback ( onparameterssetcallbacktype callback ); there were also several deprecated methods: template < typename parametert > [[ deprecated ( "use declare_parameter() instead" )]] void rclcpp :: node :: set_parameter_if_not_set ( const std :: string & name , const parametert & value ); template < typename parametert > [[ deprecated ( "use declare_parameters() instead" )]] void rclcpp :: node :: set_parameters_if_not_set ( const std :: string & name , const std :: map < std :: string , parametert > & values ); template < typename parametert > [[ deprecated ( "use declare_parameter() and it's return value instead" )]] void rclcpp :: node :: get_parameter_or_set ( const std :: string & name , parametert & value , const parametert & alternative_value ); template < typename callbackt > [[ deprecated ( "use set_on_parameters_set_callback() instead" )]] void rclcpp :: node :: register_param_change_callback ( callbackt && callback ); memory strategy ï the interface rclcpp::memory_strategy::memorystrategy was using the typedef weaknodevector in various method signatures. as of dashing the typedef has been been changed to weaknodelist and with it the type of the parameter in various methods. any custom memory strategy needs to be updated to match the modified interface. the relevant api change can be found in ros2/rclcpp#741 . rclcpp_components ï the correct way to implement composition in dashing is by utilizing the rclcpp_components package. the following changes must be made to nodes in order to correctly implement runtime composition: the node must have a constructor that takes rclcpp::nodeoptions : class listener : public rclcpp :: node { listener ( const rclcpp :: nodeoptions & options ) : node ( "listener" , options ) { } }; c++ registration macros (if present) need to be updated to use the rclcpp_components equivalent. if not present, registration macros must be added in one translation unit. // insert at bottom of translation unit, e.g. listener.cpp #include "rclcpp_components/register_node_macro.hpp" // use fully-qualifed name in registration rclcpp_components_register_node ( composition :: listener ); cmake registration macros (if present) need to be updated. if not present, registration macros must be added to the projectâs cmake. add_library ( listener src/listener.cpp ) rclcpp_components_register_nodes ( listener "composition::listener" ) for more information on composition, see the tutorial rclpy ï changes to creating publishers, s, and qos profiles ï prior to dashing, you could optionally provide a qosprofile object when creating a publisher or . in an effort to encourage users to specify a history depth for message queues, we now require that a depth value or qosprofile object is given when creating publishers or s. to create a publisher, previously you would have written: node . create_publisher ( empty , 'chatter' ) # or using a keyword argument for qosprofile node . create_publisher ( empty , 'chatter' , qos_profile = qos_profile_sensor_data ) in dashing, prefer the following api that provides a depth value or qosprofile object as a third positional argument: # assume a history setting of keep_last with depth 10 node . create_publisher ( empty , 'chatter' , 10 ) # or pass a qosprofile object directly node . create_publisher ( empty , 'chatter' , qos_profile_sensor_data ) likewise for s, previously you would have written: node . create_ ( basictypes , 'chatter' , lambda msg : print ( msg )) # or using a keyword argument for qosprofile node . create_ ( basictypes , 'chatter' , lambda msg : print ( msg ), qos_profile = qos_profile_sensor_data ) in dashing: # assume a history setting of keep_last with depth 10 node . create_ ( basictypes , 'chatter' , lambda msg : print ( msg ), 10 ) # or pass a qosprofile object directly node . create_ ( basictypes , 'chatter' , lambda msg : print ( msg ), qos_profile_sensor_data ) to ease the transition, users who do not use the new api will see deprecation warnings. furthermore, we also require that when constructing qosprofile objects that a history policy and/or depth is set. if a history policy of keep_last is provided, then a depth argument is also required. for example, these calls are valid: qosprofile ( history = qoshistorypolicy . rmw_qos_policy_history_keep_all ) qosprofile ( history = qoshistorypolicy . rmw_qos_policy_history_keep_last , depth = 10 ) qosprofile ( depth = 10 ) # equivalent to the previous line and these calls will cause a deprecation warning: qosprofile () qosprofile ( reliability = qosreliabilitypolicy . rmw_qos_policy_reliability_best_effort ) # keep_last but no depth qosprofile ( history = qoshistorypolicy . rmw_qos_policy_history_keep_last ) see the issue and pull request related to introducing this change for more details: https://github.com/ros2/rclpy/issues/342 https://github.com/ros2/rclpy/pull/344 changes due to declare parameter change ï for details  the actual behavior change, see declaring parameters above. the changes are analogous to the ones in rclcpp . these are the new api methods available in rclpy.node.node interface: to declare parameters given a name, an optional default value (supported by rcl_interfaces.msg.parametervalue ) and an optional descriptor, returning the value actually set: def declare_parameter ( name : str , value : any = none , descriptor : parameterdescriptor = parameterdescriptor () ) -> parameter def declare_parameters ( namespace : str , parameters : list [ union [ tuple [ str ], tuple [ str , any ], tuple [ str , any , parameterdescriptor ], ]] ) -> list [ parameter ] to undeclare previously declared parameters and to check if a parameter has been declared beforehand: def undeclare_parameter ( name : str ) -> none def has_parameter ( name : str ) -> bool to get and set parameter descriptors: def describe_parameter ( name : str ) -> parameterdescriptor def describe_parameters ( names : list [ str ]) -> list [ parameterdescriptor ] def set_descriptor ( name : str , descriptor : parameterdescriptor , alternative_value : optional [ parametervalue ] = none ) -> parametervalue a convenience method to get parameters that may not have been declared: def get_parameter_or ( name : str , alternative_value : optional [ parameter ] = none ) -> parameter other changes ï rclpy.parameter.parameter can now guess its type without explicitly setting it (as long as itâs one of the supported ones by rcl_interfaces.msg.parametervalue ). for example, this code: p = parameter ( 'myparam' , parameter . type . double , 2.41 ) is equivalent to this code: p = parameter ( 'myparam' , value = 2.41 ) this change does not break existing api. rosidl ï until crystal each message generator package registered itself using the ament_cmake extension point rosidl_generate_interfaces and was passed a set of .msg / .srv / .action files. as of dashing the message generation pipeline is based on .idl files instead. any message generator package needs to change and register itself using the new extension point rosidl_generate_idl_interfaces which passes only .idl files instead. the message generators for the commonly supported languages c, c++, and python as well as the typesupport packages for introspection, fast rtps, connext and opensplice have already been updated (see ros2/rosidl#334 ). the cmake code calling rosidl_generate_interfaces() can either pass .idl files directly or pass .msg / .srv / .action which will then internally be converted into .idl files before being passed to each message generator. the format of .msg / .srv / .action files is not being evolved in the future. the mapping between .msg / .srv / .action files and .idl files is described in this design article . a second design article describes the supported features in .idl files. in order to leverage any of the new features existing interfaces need to be converted (e.g. using the command line tools msg2idl / srv2idl / action2idl ). to distinguish same type names, but with different namespaces, the introspection structs now contain a namespace field that replaces the package name (see ros2/rosidl#335 ). mapping of char in .msg files ï in ros 1 char has been deprecated for a long time and is being mapped to uint8 . in ros 2 until crystal char was mapped to a single character ( char in c / c++, str with length 1 in python) in an effort to provide a more natural mapping. as of dashing the ros 1 semantic has been restored and char maps to uint8 again. rosidl_generator_cpp ï the c++ data structures generated for messages, services and actions provide setter methods for each field. until crystal each setter returned a pointer to the data structure itself to enable the named parameter idiom. as of dashing these setters return a reference instead since that seems to be the more common signature as well as it clarifies that the returned value canât be a nullptr . rosidl_generator_py ï until crystal an array (fixed size) or sequence (dynamic size, optionally with an upper boundary) field in a message was stored as a list in python. as of dashing the python type for arrays / sequences of numeric values has been changed: an array of numeric values is stored as a numpy.ndarray (the dtype is chosen to match the type of the numeric value) a sequence of numeric values is stored as an array.array (the typename is chosen to match the type of the numeric value) as before an array / sequence of non-numeric types is still represented as a list in python. this change brings a number of benefits: the new data structures ensure that each item in the array / sequence complies with the value range restrictions of the numeric type. the numeric values can be stored more efficiently in memory which avoid the overhead of python objects for each item. the memory layout of both data structures allows to read and write all items of the array / sequence in a single operation which makes the conversion from and to python significantly faster / more efficient. launch ï the launch_testing package caught up with the launch package redesign done in bouncy bolson. the legacy python api, already moved into the launch.legacy submodule, has thus been deprecated and removed. see launch examples and documentation for reference on how to use its new api. see demos tests for reference on how to use the new launch_testing api. rmw ï changes since the crystal clemmys release: new api in rmw , a fini function for rmw_context_t : rmw_context_fini modification of rmw , now passes rmw_context_t to rmw_create_wait_set : rmw_create_wait_set new apis in rmw for preallocating space for published and subscribed messages: rmw_init_publisher_allocation rmw_fini_publisher_allocation rmw_init__allocation rmw_fini__allocation rmw_serialized_message_size modification of rmw , now passes rmw_publisher_allocation_t or rmw__allocation_t to rmw_publish and rmw_take , respectively. note that this argument can be null or nullptr , which keeps existing crystal behavior. rmw_publish rmw_take type names returned by rmw_get_*_names_and_types* functions should have a fully-qualified namespace. for example, instead of rcl_interfaces/parameter and rcl_interfaces/getparameters , the returned type names should be rcl_interface/msg/parameter and rcl_interfaces/srv/getparameters . actions ï changes to rclcpp_action::client signatures: the signature of rclcpp_action::client::async_send_goal has changed. now users can optionally provide callback functions for the goal response and the result using the new sendgoaloptions struct. the goal response callback is called when an action server accepts or rejects the goal and the result callback is called when the result for the goal is received. optional callbacks were also added to rclcpp_action::client::async_cancel_goal and rclcpp_action::client::async_get_result . changes to goal transition names: the names of goal state transitions have been refactored to reflect the design documention. this affects rcl_action , rclcpp_action , and rclpy . here is a list of the event name changes ( old name -> new name ): goal_event_cancel -> goal_event_cancel_goal goal_event_set_succeeded -> goal_event_succeed goal_event_set_aborted -> goal_event_abort goal_event_set_canceled -> goal_event_canceled changes to cancelgoal.srv : a return_code field was added to the response message of the cancelgoal service. this is to better communicate a reason for a failed service call. see the pull request and connected issue for details. rviz ï plugins should use fully qualified type names otherwise a warning will be logged. for example , use the type sensor_msgs/msg/image instead of sensor_msgs/image . see pr introducing this change for more details. known issues ï [ros2/rclcpp#715] there is an inconsistency in the way that parameter yaml files are loaded between standalone ros 2 nodes and composed ros 2 nodes. currently available workarounds are noted in an issue comment [ros2/rclpy#360] rclpy nodes ignore ctrl - c when using opensplice on windows. [ros2/rosidl_typesupport_opensplice#30] there is a bug preventing nesting a message inside of a service or action definition with the same name when using opensplice. [ros2/rclcpp#781] calling get_parameter / list_parameter from within on_set_parameter_callback causes a deadlock on dashing. this is fixed for eloquent, but is an abi break so has not been backported to dashing. [ros2/rclcpp#912] inter-process communication forces a message copy when intra-process communication takes place between an std::unique_ptr publisher and a single std::unique_ptr  (published std::unique_ptr is internally being promoted to an std::shared_ptr ). [ros2/rosbag2#125] topics with unreliable qos are not recorded. [ros2/rclcpp#715] composable nodes cannot receive parameters via remapping. supplying parameters to composable nodes can be accomplished using the methods described in [this comment] . [ros2/rclcpp#893] rclcpp::context is not destroyed because of a reference cycle with rclcpp::graphlistener . this causes a memory leak. a fix has not been backported because of the risk of breaking abi. timeline before the release ï a few milestones leading up to the release: mon. apr 8th (alpha) first releases of core packages available. testing can happen from now on (some features might not have landed yet). thu. may 2nd api freeze for core packages mon. may 6th (beta) updated releases of core packages available. additional testing of the latest features. thu. may 16th feature freeze. only bug fix releases should be made after this point. new packages can be released independently. mon. may 20th (release candidate) updated releases of core packages available. wed. may 29th freeze rosdistro. no prs for dashing on the rosdistro repo will be merged (reopens after the release announcement). other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling