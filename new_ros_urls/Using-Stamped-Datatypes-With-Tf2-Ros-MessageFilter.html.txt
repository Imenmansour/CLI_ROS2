tutorials intermediate tf2 using stamped datatypes with tf2_ros::messagefilter edit on github using stamped datatypes with tf2_ros::messagefilter ï goal: learn how to use tf2_ros::messagefilter to process stamped datatypes. tutorial level: intermediate time: 10 minutes background ï this tutorial explains how to use sensor data with tf2. some real-world examples of sensor data are: cameras, both mono and stereo laser scans suppose that a new turtle named turtle3 is created and it doesnât have good odometry, but there is an overhead camera tracking its position and publishing it as a pointstamped message in relation to the world frame. turtle1 wants to know where turtle3 is compared to itself. to do this turtle1 must listen to the topic where turtle3 âs pose is being published, wait until transforms into the desired frame are ready, and then do its operations. to make this easier the tf2_ros::messagefilter is very useful. the tf2_ros::messagefilter will take a  to any ros 2 message with a header and cache it until it is possible to transform it into the target frame. tasks ï 1 write the broadcaster node of pointstamped messages ï for this tutorial we will set up a demo application which has a node (in python) to broadcast the pointstamped position messages of turtle3 . first, letâs create the source file. go to the learning_tf2_py package we created in the previous tutorial. inside the src/learning_tf2_py/learning_tf2_py directory download the example sensor message broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py -o turtle_tf2_message_broadcaster.py or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py -o turtle_tf2_message_broadcaster.py open the file using your preferred text editor. from geometry_msgs.msg import pointstamped from geometry_msgs.msg import twist import rclpy from rclpy.node import node from turtlesim.msg import pose from turtlesim.srv import spawn class pointpublisher ( node ): def __init__ ( self ): super () . __init__ ( 'turtle_tf2_message_broadcaster' ) # create a client to spawn a turtle self . spawner = self . create_client ( spawn , 'spawn' ) # boolean values to store the information # if the service for spawning turtle is available self . turtle_spawning_service_ready = false # if the turtle was successfully spawned self . turtle_spawned = false # if the topics of turtle3 can be subscribed self . turtle_pose_cansubscribe = false self . timer = self . create_timer ( 1.0 , self . on_timer ) def on_timer ( self ): if self . turtle_spawning_service_ready : if self . turtle_spawned : self . turtle_pose_cansubscribe = true else : if self . result . done (): self . get_logger () . info ( f 'successfully spawned { self . result . result () . name } ' ) self . turtle_spawned = true else : self . get_logger () . info ( 'spawn is not finished' ) else : if self . spawner . service_is_ready (): # initialize request with turtle name and coordinates # note that x, y and theta are defined as floats in turtlesim/srv/spawn request = spawn . request () request . name = 'turtle3' request . x = 4.0 request . y = 2.0 request . theta = 0.0 # call request self . result = self . spawner . call_async ( request ) self . turtle_spawning_service_ready = true else : # check if the service is ready self . get_logger () . info ( 'service is not ready' ) if self . turtle_pose_cansubscribe : self . vel_pub = self . create_publisher ( twist , 'turtle3/cmd_vel' , 10 ) self . sub = self . create_ ( pose , 'turtle3/pose' , self . handle_turtle_pose , 10 ) self . pub = self . create_publisher ( pointstamped , 'turtle3/turtle_point_stamped' , 10 ) def handle_turtle_pose ( self , msg ): vel_msg = twist () vel_msg . linear . x = 1.0 vel_msg . angular . z = 1.0 self . vel_pub . publish ( vel_msg ) ps = pointstamped () ps . header . stamp = self . get_clock () . now () . to_msg () ps . header . frame_id = 'world' ps . point . x = msg . x ps . point . y = msg . y ps . point . z = 0.0 self . pub . publish ( ps ) def main (): rclpy . init () node = pointpublisher () try : rclpy . spin ( node ) except keyboardinterrupt : pass rclpy . shutdown () 1.1 examine the code ï now letâs take a look at the code. first, in the on_timer callback function, we spawn the turtle3 by asynchronously calling the spawn service of turtlesim , and initialize its position at (4, 2, 0), when the turtle spawning service is ready. # initialize request with turtle name and coordinates # note that x, y and theta are defined as floats in turtlesim/srv/spawn request = spawn . request () request . name = 'turtle3' request . x = 4.0 request . y = 2.0 request . theta = 0.0 # call request self . result = self . spawner . call_async ( request ) afterward, the node publishes the topic turtle3/cmd_vel , topic turtle3/turtle_point_stamped , and subscribes to topic turtle3/pose and runs callback function handle_turtle_pose on every incoming message. self . vel_pub = self . create_publisher ( twist , '/turtle3/cmd_vel' , 10 ) self . sub = self . create_ ( pose , '/turtle3/pose' , self . handle_turtle_pose , 10 ) self . pub = self . create_publisher ( pointstamped , '/turtle3/turtle_point_stamped' , 10 ) finally, in the callback function handle_turtle_pose , we initialize the twist messages of turtle3 and publish them, which will make the turtle3 move along a circle. then we fill up the pointstamped messages of turtle3 with incoming pose messages and publish them. vel_msg = twist () vel_msg . linear . x = 1.0 vel_msg . angular . z = 1.0 self . vel_pub . publish ( vel_msg ) ps = pointstamped () ps . header . stamp = self . get_clock () . now () . to_msg () ps . header . frame_id = 'world' ps . point . x = msg . x ps . point . y = msg . y ps . point . z = 0.0 self . pub . publish ( ps ) 1.2 write the launch file ï in order to run this demo, we need to create a launch file turtle_tf2_sensor_message_launch.py in the launch subdirectory of package learning_tf2_py : from launch import launchdescription from launch.actions import declarelaunchargument from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ declarelaunchargument ( 'target_frame' , default_value = 'turtle1' , description = 'target frame name.' ), node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' , output = 'screen' ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster2' , parameters = [ { 'turtlename' : 'turtle3' } ] ), node ( package = 'turtle_tf2_py' , executable = 'turtle_tf2_message_broadcaster' , name = 'message_broadcaster' , ), ]) 1.3 add an entry point ï to allow the ros2 run command to run your node, you must add the entry point to setup.py (located in the src/learning_tf2_py directory). add the following line between the 'console_scripts': brackets: 'turtle_tf2_message_broadcaster = learning_tf2_py.turtle_tf2_message_broadcaster:main' , 1.4 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself and then we can build the package: linux macos windows colcon build --packages-select learning_tf2_py colcon build --packages-select learning_tf2_py colcon build --merge-install --packages-select learning_tf2_py 2 writing the message filter/listener node ï now, to get the streaming pointstamped data of turtle3 in the frame of turtle1 reliably, we will create the source file of the message filter/listener node. go to the learning_tf2_cpp package we created in the previous tutorial. inside the src/learning_tf2_cpp/src directory download file turtle_tf2_message_filter.cpp by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp -o turtle_tf2_message_filter.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp -o turtle_tf2_message_filter.cpp open the file using your preferred text editor. #include <chrono> #include <memory> #include <string> #include "geometry_msgs/msg/point_stamped.hpp" #include "message_filters/subscriber.h" #include "rclcpp/rclcpp.hpp" #include "tf2_ros/buffer.h" #include "tf2_ros/create_timer_ros.h" #include "tf2_ros/message_filter.h" #include "tf2_ros/transform_listener.h" #ifdef tf2_cpp_headers #include "tf2_geometry_msgs/tf2_geometry_msgs.hpp" #else #include "tf2_geometry_msgs/tf2_geometry_msgs.h" #endif using namespace std :: chrono_literals ; class posedrawer : public rclcpp :: node { public : posedrawer () : node ( "turtle_tf2_pose_drawer" ) { // declare and acquire `target_frame` parameter target_frame_ = this -> declare_parameter < std :: string > ( "target_frame" , "turtle1" ); std :: chrono :: duration < int > buffer_timeout ( 1 ); tf2_buffer_ = std :: make_shared < tf2_ros :: buffer > ( this -> get_clock ()); // create the timer interface before call to waitfortransform, // to avoid a tf2_ros::createtimerinterfaceexception exception auto timer_interface = std :: make_shared < tf2_ros :: createtimerros > ( this -> get_node_base_interface (), this -> get_node_timers_interface ()); tf2_buffer_ -> setcreatetimerinterface ( timer_interface ); tf2_listener_ = std :: make_shared < tf2_ros :: transformlistener > ( * tf2_buffer_ ); point_sub_ . subscribe ( this , "/turtle3/turtle_point_stamped" ); tf2_filter_ = std :: make_shared < tf2_ros :: messagefilter < geometry_msgs :: msg :: pointstamped >> ( point_sub_ , * tf2_buffer_ , target_frame_ , 100 , this -> get_node_logging_interface (), this -> get_node_clock_interface (), buffer_timeout ); // register a callback with tf2_ros::messagefilter to be called when transforms are available tf2_filter_ -> registercallback ( & posedrawer :: msgcallback , this ); } private : void msgcallback ( const geometry_msgs :: msg :: pointstamped :: sharedptr point_ptr ) { geometry_msgs :: msg :: pointstamped point_out ; try { tf2_buffer_ -> transform ( * point_ptr , point_out , target_frame_ ); rclcpp_info ( this -> get_logger (), "point of turtle3 in frame of turtle1: x:%f y:%f z:%f \n " , point_out . point . x , point_out . point . y , point_out . point . z ); } catch ( const tf2 :: transformexception & ex ) { rclcpp_warn ( // print exception which was caught this -> get_logger (), "failure %s \n " , ex . what ()); } } std :: string target_frame_ ; std :: shared_ptr < tf2_ros :: buffer > tf2_buffer_ ; std :: shared_ptr < tf2_ros :: transformlistener > tf2_listener_ ; message_filters :: subscriber < geometry_msgs :: msg :: pointstamped > point_sub_ ; std :: shared_ptr < tf2_ros :: messagefilter < geometry_msgs :: msg :: pointstamped >> tf2_filter_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < posedrawer > ()); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï first, you must include the tf2_ros::messagefilter headers from the tf2_ros package, as well as the previously used tf2 and ros2 related headers. #include "geometry_msgs/msg/point_stamped.hpp" #include "message_filters/subscriber.h" #include "rclcpp/rclcpp.hpp" #include "tf2_ros/buffer.h" #include "tf2_ros/create_timer_ros.h" #include "tf2_ros/message_filter.h" #include "tf2_ros/transform_listener.h" #ifdef tf2_cpp_headers #include "tf2_geometry_msgs/tf2_geometry_msgs.hpp" #else #include "tf2_geometry_msgs/tf2_geometry_msgs.h" #endif second, there needs to be persistent instances of tf2_ros::buffer , tf2_ros::transformlistener and tf2_ros::messagefilter . std :: string target_frame_ ; std :: shared_ptr < tf2_ros :: buffer > tf2_buffer_ ; std :: shared_ptr < tf2_ros :: transformlistener > tf2_listener_ ; message_filters :: subscriber < geometry_msgs :: msg :: pointstamped > point_sub_ ; std :: shared_ptr < tf2_ros :: messagefilter < geometry_msgs :: msg :: pointstamped >> tf2_filter_ ; third, the ros 2 message_filters::subscriber must be initialized with the topic. and the tf2_ros::messagefilter must be initialized with that subscriber object. the other arguments of note in the messagefilter constructor are the target_frame and the callback function. the target frame is the frame into which it will make sure cantransform will succeed. and the callback function is the function that will be called when the data is ready. posedrawer () : node ( "turtle_tf2_pose_drawer" ) { // declare and acquire `target_frame` parameter target_frame_ = this -> declare_parameter < std :: string > ( "target_frame" , "turtle1" ); std :: chrono :: duration < int > buffer_timeout ( 1 ); tf2_buffer_ = std :: make_shared < tf2_ros :: buffer > ( this -> get_clock ()); // create the timer interface before call to waitfortransform, // to avoid a tf2_ros::createtimerinterfaceexception exception auto timer_interface = std :: make_shared < tf2_ros :: createtimerros > ( this -> get_node_base_interface (), this -> get_node_timers_interface ()); tf2_buffer_ -> setcreatetimerinterface ( timer_interface ); tf2_listener_ = std :: make_shared < tf2_ros :: transformlistener > ( * tf2_buffer_ ); point_sub_ . subscribe ( this , "/turtle3/turtle_point_stamped" ); tf2_filter_ = std :: make_shared < tf2_ros :: messagefilter < geometry_msgs :: msg :: pointstamped >> ( point_sub_ , * tf2_buffer_ , target_frame_ , 100 , this -> get_node_logging_interface (), this -> get_node_clock_interface (), buffer_timeout ); // register a callback with tf2_ros::messagefilter to be called when transforms are available tf2_filter_ -> registercallback ( & posedrawer :: msgcallback , this ); } and last, the callback method will call tf2_buffer_->transform when the data is ready and print output to the console. private : void msgcallback ( const geometry_msgs :: msg :: pointstamped :: sharedptr point_ptr ) { geometry_msgs :: msg :: pointstamped point_out ; try { tf2_buffer_ -> transform ( * point_ptr , point_out , target_frame_ ); rclcpp_info ( this -> get_logger (), "point of turtle3 in frame of turtle1: x:%f y:%f z:%f \n " , point_out . point . x , point_out . point . y , point_out . point . z ); } catch ( const tf2 :: transformexception & ex ) { rclcpp_warn ( // print exception which was caught this -> get_logger (), "failure %s \n " , ex . what ()); } } 2.2 add dependencies ï before building the package learning_tf2_cpp ,  add two another dependencies in the package.xml file of this package: <depend> message_filters </depend> <depend> tf2_geometry_msgs </depend> 2.3 cmakelists.txt ï and in the cmakelists.txt file, add two lines below the existing dependencies: find_package(message_filters required) find_package(tf2_geometry_msgs required) the lines below will deal with differences between ros distributions: if(target tf2_geometry_msgs::tf2_geometry_msgs) get_target_property(_include_dirs tf2_geometry_msgs::tf2_geometry_msgs interface_include_directories) else() set(_include_dirs {tf2_geometry_msgs_include_dirs}) endif() find_file(tf2_cpp_headers names tf2_geometry_msgs.hpp paths {_include_dirs} no_cache path_suffixes tf2_geometry_msgs ) after that, add the executable and name it turtle_tf2_message_filter , which youâll use later with ros2 run . add_executable(turtle_tf2_message_filter src/turtle_tf2_message_filter.cpp) ament_target_dependencies( turtle_tf2_message_filter geometry_msgs message_filters rclcpp tf2 tf2_geometry_msgs tf2_ros ) if(exists {tf2_cpp_headers}) target_compile_definitions(turtle_tf2_message_filter public -dtf2_cpp_headers) endif() finally, add the install(targetsâ) section (below other existing nodes) so ros2 run can find your executable: install(targets turtle_tf2_message_filter destination lib/{project_name}) 2.4 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself now open a new terminal, navigate to the root of your workspace, and rebuild the package with command: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 3 run ï first we need to run several nodes (including the broadcaster node of pointstamped messages) by launching the launch file turtle_tf2_sensor_message_launch.py : ros2 launch learning_tf2_py turtle_tf2_sensor_message_launch.py this will bring up the turtlesim window with two turtles, where turtle3 is moving along a circle, while turtle1 isnât moving at first. but you can run the turtle_teleop_key node in another terminal to drive turtle1 to move: ros2 run turtlesim turtle_teleop_key now if you echo the topic turtle3/turtle_point_stamped : ros2 topic echo /turtle3/turtle_point_stamped then there will be output like this: header: stamp: sec: 1629877510 nanosec: 902607040 frame_id: world point: x: 4.989276885986328 y: 3.073937177658081 z: 0.0 --- header: stamp: sec: 1629877510 nanosec: 918389395 frame_id: world point: x: 4.987966060638428 y: 3.089883327484131 z: 0.0 --- header: stamp: sec: 1629877510 nanosec: 934186680 frame_id: world point: x: 4.986400127410889 y: 3.105806589126587 z: 0.0 --- when the demo is running, open another terminal and run the message filter/listener node: ros2 run learning_tf2_cpp turtle_tf2_message_filter if itâs running correctly you should see streaming data like this: [info] [1630016162.006173900] [turtle_tf2_pose_drawer]: point of turtle3 in frame of turtle1: x:-6.493231 y:-2.961614 z:0.000000 [info] [1630016162.006291983] [turtle_tf2_pose_drawer]: point of turtle3 in frame of turtle1: x:-6.472169 y:-3.004742 z:0.000000 [info] [1630016162.006326234] [turtle_tf2_pose_drawer]: point of turtle3 in frame of turtle1: x:-6.479420 y:-2.990479 z:0.000000 [info] [1630016162.006355644] [turtle_tf2_pose_drawer]: point of turtle3 in frame of turtle1: x:-6.486441 y:-2.976102 z:0.000000 summary ï in this tutorial you learned how to use sensor data/messages in tf2. specifically speaking, you learned how to publish pointstamped messages on a topic, and how to listen to the topic and transform the frame of pointstamped messages with tf2_ros::messagefilter . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling