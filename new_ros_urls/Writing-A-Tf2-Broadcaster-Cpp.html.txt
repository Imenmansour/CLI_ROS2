tutorials intermediate tf2 writing a broadcaster (c++) edit on github writing a broadcaster (c++) ï goal: learn how to broadcast the state of a robot to tf2. tutorial level: intermediate time: 15 minutes background ï in the next two tutorials we will write the code to reproduce the demo from the introduction to tf2 tutorial. after that, the following tutorials focus on extending the demo with more advanced tf2 features, including the usage of timeouts in transformation lookups and time travel. prerequisites ï this tutorial assumes you have a working knowledge of ros 2 and you have completed the introduction to tf2 tutorial and tf2 static broadcaster tutorial (c++) . weâll be reusing the learning_tf2_cpp package from that last tutorial. in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 write the broadcaster node ï letâs first create the source files. go to the learning_tf2_cpp package we created in the previous tutorial. inside the src directory download the example broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_broadcaster.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_broadcaster.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_broadcaster.cpp -o turtle_tf2_broadcaster.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_broadcaster.cpp -o turtle_tf2_broadcaster.cpp open the file using your preferred text editor. #include <functional> #include <memory> #include <sstream> #include <string> #include "geometry_msgs/msg/transform_stamped.hpp" #include "rclcpp/rclcpp.hpp" #include "tf2/linearmath/quaternion.h" #include "tf2_ros/transform_broadcaster.h" #include "turtlesim/msg/pose.hpp" class framepublisher : public rclcpp :: node { public : framepublisher () : node ( "turtle_tf2_frame_publisher" ) { // declare and acquire `turtlename` parameter turtlename_ = this -> declare_parameter < std :: string > ( "turtlename" , "turtle" ); // initialize the transform broadcaster tf_broadcaster_ = std :: make_unique < tf2_ros :: transformbroadcaster > ( * this ); // subscribe to a turtle{1}{2}/pose topic and call handle_turtle_pose // callback function on each message std :: ostringstream stream ; stream << "/" << turtlename_ . c_str () << "/pose" ; std :: string topic_name = stream . str (); auto handle_turtle_pose = [ this ]( const std :: shared_ptr < turtlesim :: msg :: pose > msg ){ geometry_msgs :: msg :: transformstamped t ; // read message content and assign it to // corresponding tf variables t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "world" ; t . child_frame_id = turtlename_ . c_str (); // turtle only exists in 2d, thus we get x and y translation // coordinates from the message and set the z coordinate to 0 t . transform . translation . x = msg -> x ; t . transform . translation . y = msg -> y ; t . transform . translation . z = 0.0 ; // for the same reason, turtle can only rotate around one axis // and this why we set rotation in x and y to 0 and obtain // rotation in z axis from the message tf2 :: quaternion q ; q . setrpy ( 0 , 0 , msg -> theta ); t . transform . rotation . x = q . x (); t . transform . rotation . y = q . y (); t . transform . rotation . z = q . z (); t . transform . rotation . w = q . w (); // send the transformation tf_broadcaster_ -> sendtransform ( t ); }; _ = this -> create_ < turtlesim :: msg :: pose > ( topic_name , 10 , handle_turtle_pose ); } private : rclcpp ::  < turtlesim :: msg :: pose >:: sharedptr _ ; std :: unique_ptr < tf2_ros :: transformbroadcaster > tf_broadcaster_ ; std :: string turtlename_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < framepublisher > ()); rclcpp :: shutdown (); return 0 ; } 1.1 examine the code ï now, letâs take a look at the code that is relevant to publishing the turtle pose to tf2. firstly, we define and acquire a single parameter turtlename , which specifies a turtle name, e.g. turtle1 or turtle2 . turtlename_ = this -> declare_parameter < std :: string > ( "turtlename" , "turtle" ); afterward, the node subscribes to topic turtlex/pose and runs function handle_turtle_pose on every incoming message. _ = this -> create_ < turtlesim :: msg :: pose > ( topic_name , 10 , handle_turtle_pose ); now, we create a transformstamped object and give it the appropriate metadata. we need to give the transform being published a timestamp, and weâll just stamp it with the current time by calling this->get_clock()->now() . this will return the current time used by the node . then we need to set the name of the parent frame of the link weâre creating, in this case world . finally, we need to set the name of the child node of the link weâre creating, in this case this is the name of the turtle itself. the handler function for the turtle pose message broadcasts this turtleâs translation and rotation, and publishes it as a transform from frame world to frame turtlex . geometry_msgs :: msg :: transformstamped t ; // read message content and assign it to // corresponding tf variables t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "world" ; t . child_frame_id = turtlename_ . c_str (); here we copy the information from the 3d turtle pose into the 3d transform. // turtle only exists in 2d, thus we get x and y translation // coordinates from the message and set the z coordinate to 0 t . transform . translation . x = msg -> x ; t . transform . translation . y = msg -> y ; t . transform . translation . z = 0.0 ; // for the same reason, turtle can only rotate around one axis // and this why we set rotation in x and y to 0 and obtain // rotation in z axis from the message tf2 :: quaternion q ; q . setrpy ( 0 , 0 , msg -> theta ); t . transform . rotation . x = q . x (); t . transform . rotation . y = q . y (); t . transform . rotation . z = q . z (); t . transform . rotation . w = q . w (); finally we take the transform that we constructed and pass it to the sendtransform method of the transformbroadcaster that will take care of broadcasting. // send the transformation tf_broadcaster_ -> sendtransform ( t ); 1.2 cmakelists.txt ï navigate one level back to the learning_tf2_cpp directory, where the cmakelists.txt and package.xml files are located. now open the cmakelists.txt add the executable and name it turtle_tf2_broadcaster , which youâll use later with ros2 run . add_executable(turtle_tf2_broadcaster src/turtle_tf2_broadcaster.cpp) ament_target_dependencies( turtle_tf2_broadcaster geometry_msgs rclcpp tf2 tf2_ros turtlesim ) finally, add the install(targetsâ) section so ros2 run can find your executable: install(targets turtle_tf2_broadcaster destination lib/{project_name}) 2 write the launch file ï now create a launch file for this demo. create a launch folder in the src/learning_tf2_cpp directory. with your text editor, create a new file called turtle_tf2_demo_launch.py in the launch folder, and add the following lines: from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), ]) 2.1 examine the code ï first we import required modules from the launch and launch_ros packages. it should be noted that launch is a generic launching framework (not ros 2 specific) and launch_ros has ros 2 specific things, like nodes that we import here. from launch import launchdescription from launch_ros.actions import node now we run our nodes that start the turtlesim simulation and broadcast turtle1 state to the tf2 using our turtle_tf2_broadcaster node. node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), 2.2 add dependencies ï navigate one level back to the learning_tf2_cpp directory, where the cmakelists.txt and package.xml files are located. open package.xml with your text editor. add the following dependencies corresponding to your launch fileâs import statements: <exec_depend> launch </exec_depend> <exec_depend> launch_ros </exec_depend> this declares the additional required launch and launch_ros dependencies when its code is executed. make sure to save the file. 2.3 cmakelists.txt ï reopen cmakelists.txt and add the line so that the launch files from the launch/ folder will be installed. install(directory launch destination share/{project_name}) you can learn more  creating launch files in this tutorial . 3 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your package: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 4 run ï now run the launch file that will start the turtlesim simulation node and turtle_tf2_broadcaster node: ros2 launch learning_tf2_cpp turtle_tf2_demo_launch.py in the second terminal window type the following command: ros2 run turtlesim turtle_teleop_key you will now see that the turtlesim simulation have started with one turtle that you can control. now, use the tf2_echo tool to check if the turtle pose is actually getting broadcast to tf2: ros2 run tf2_ros tf2_echo world turtle1 this should show you the pose of the first turtle. drive around the turtle using the arrow keys (make sure your turtle_teleop_key terminal window is active, not your simulator window). in your console output you will see something similar to this: at time 1625137663.912474878 - translation: [5.276, 7.930, 0.000] - rotation: in quaternion [0.000, 0.000, 0.934, -0.357] at time 1625137664.950813527 - translation: [3.750, 6.563, 0.000] - rotation: in quaternion [0.000, 0.000, 0.934, -0.357] at time 1625137665.906280726 - translation: [2.320, 5.282, 0.000] - rotation: in quaternion [0.000, 0.000, 0.934, -0.357] at time 1625137666.850775673 - translation: [2.153, 5.133, 0.000] - rotation: in quaternion [0.000, 0.000, -0.365, 0.931] if you run tf2_echo for the transform between the world and turtle2 , you should not see a transform, because the second turtle is not there yet. however, as soon as we add the second turtle in the next tutorial, the pose of turtle2 will be broadcast to tf2. summary ï in this tutorial you learned how to broadcast the pose of the robot (position and orientation of the turtle) to tf2 and how to use the tf2_echo tool. to actually use the transforms broadcasted to tf2, you should move on to the next tutorial  creating a tf2 listener . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling