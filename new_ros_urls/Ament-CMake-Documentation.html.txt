how-to guides ament_cmake user documentation edit on github ament_cmake user documentation ï ament_cmake is the build system for cmake based packages in ros 2 (in particular, it will be used for most c/c++ projects). it is a set of scripts enhancing cmake and adding convenience functionality for package authors. before using ament_cmake , it is very helpful to know the basics of cmake . an official tutorial can be found here . basics ï a basic cmake outline can be produced using ros2 pkg create <package_name> on the command line. the build information is then gathered in two files: the package.xml and the cmakelists.txt , which must be in the same directory. the package.xml must contain all dependencies and a bit of metadata to allow colcon to find the correct build order for your packages, to install the required dependencies in ci, and to provide the information for a release with bloom . the cmakelists.txt contains the commands to build and package executables and libraries and will be the main focus of this document. basic project outline ï the basic outline of the cmakelists.txt of an ament package contains: cmake_minimum_required ( version 3.8 ) project ( my_project ) ament_package () the argument to project will be the package name and must be identical to the package name in the package.xml . the project setup is done by ament_package() and this call must occur exactly once per package. ament_package() installs the package.xml , registers the package with the ament index, and installs configuration (and possibly target) files for cmake so that it can be found by other packages using find_package . since ament_package() gathers a lot of information from the cmakelists.txt it should be the last call in your cmakelists.txt . ament_package can be given additional arguments: config_extras : a list of cmake files ( .cmake or .cmake.in templates expanded by configure_file() ) which should be available to clients of the package. for an example of when to use these arguments, see the discussion in adding resources . for more information on how to use template files, see the official documentation . config_extras_post : same as config_extras , but the order in which the files are added differs. while config_extras files are included before the files generated for the ament_export_* calls the files from config_extras_post are included afterwards. instead of adding to ament_package , you can also add to the variable {project_name}_config_extras and {project_name}_config_extras_post with the same effect. the only difference is again the order in which the files are added with the following total order: files added by config_extras files added by appending to {project_name}_config_extras files added by appending to {project_name}_config_extras_post files added by config_extras_post compiler and linker options ï ros 2 targets compilers which comply with the c++17 and c99 standard. newer versions might be targeted in the future and are referenced here . therefore it is customary to set the corresponding cmake flags: if ( not cmake_c_standard ) set ( cmake_c_standard 99 ) endif () if ( not cmake_cxx_standard ) set ( cmake_cxx_standard 17 ) endif () to keep the code clean, compilers should throw warnings for questionable code and these warnings should be fixed. it is recommended to at least cover the following warning levels: for visual studio: the default w1 warnings for gcc and clang: -wall -wextra -wpedantic are highly recommended and -wshadow is advisable it is currently recommended to use add_compile_options to add these options for all targets. this avoids cluttering the code with target-based compile options for all executables, libraries, and tests: if ( cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang" ) add_compile_options ( -wall -wextra -wpedantic ) endif () finding dependencies ï most ament_cmake projects will have dependencies on other packages. in cmake, this is accomplished by calling find_package . for instance, if your package depends on rclcpp , then the cmakelists.txt file should contain: find_package ( rclcpp required ) note it should never be necessary to find_package a library that is not explicitly needed but is a dependency of another dependency that is explicitly needed. if that is the case, file a bug against the corresponding package. adding targets ï in cmake nomenclature, targets are the artifacts that this project will create. either libraries or executables can be created, and a single project can contain zero or many of each of them. libraries executables these are created with a call to add_library , which should contain both the name of the target and the source files that should be compiled to create the library. with the separation of header files and implementation in c/c++, it is not usually necessary to add header files as arguments to add_library . the following best practice is proposed: put all headers which should be usable by clients of this library (and therefore must be installed) into a subdirectory of the include folder named like the package, while all other files ( .c/.cpp and header files which should not be exported) are inside the src folder only .c/.cpp files are explicitly referenced in the call to add_library find headers to your library my_library via target_include_directories ( my_library public "<build_interface:{cmake_current_source_dir}/include>" "<install_interface:include/{project_name}>" ) this adds all files in the folder {cmake_current_source_dir}/include to the public interface during build time and all files in the include folder (relative to {cmake_install_dir} ) when being installed. ros2 pkg create creates a package layout that follows these rules. note since windows is one of the officially supported platforms, to have maximum impact, any package should also build on windows. the windows library format enforces symbol visibility; that is, every symbol which should be used from a client has to be explicitly exported by the library (and symbols need to be implicitly imported). since gcc and clang builds do not generally do this, it is advised to use the logic in the gcc wiki . to use it for a package called my_library : copy the logic in the link into a header file called visibility_control.hpp . replace dll by my_library (for an example, see visibility control of rviz_rendering ). use the macros âmy_library_publicâ for all symbols you need to export (i.e. classes or functions). in the project cmakelists.txt use: target_compile_definitions ( my_library private "my_library_building_library" ) for more details, see windows symbol visibility in the windows tips and tricks document . these should be created with a call to add_executable , which should contain both the name of the target and the source files that should be compiled to create the executable. the executable may also have to be linked with any libraries created in this package by using target_link_libraries . since executables arenât generally used by clients as a library, no header files need to be put in the include directory. in the case that a package has both libraries and executables, make sure to combine the advice from both âlibrariesâ and âexecutablesâ above. linking to dependencies ï there are two ways to link your targets against a dependency. the first and recommended way is to use the ament macro ament_target_dependencies . as an example, suppose we want to link my_library against the linear algebra library eigen3. find_package ( eigen3 required ) ament_target_dependencies ( my_library public eigen3 ) it includes the necessary headers and libraries and their dependencies to be correctly found by the project. the second way is to use target_link_libraries . modern cmake prefers to use only targets, exporting and linking against them. cmake targets may be namespaced, similar to c++. prefer to use the namespaced targets if they are available. for instance, eigen3 defines the target eigen3::eigen . in the example of eigen3, the call should then look like target_link_libraries ( my_library public eigen3::eigen ) this will also include necessary headers, libraries and their dependencies. note that this dependency must have been previously discovered via a call to find_package . installing ï libraries executables when building a reusable library, some information needs to be exported for downstream packages to easily use it. first, install the headers files which should be available to clients. the include directory is custom to support overlays in colcon ; see https://colcon.readthedocs.io/en/released/user/overriding-packages.html#install-headers-to-a-unique-include-directory for more information. install ( directory include/ destination include/ { project_name } ) next, install the targets and create the export target ( export_{project_name} ) that other code will use to find this package. note that you can use a single install call to install all of the libraries in the project. install ( targets my_library export export_ { project_name } library destination lib archive destination lib runtime destination bin ) ament_export_targets ( export_ { project_name } has_library_target ) ament_export_dependencies ( some_dependency ) here is whatâs happening in the snippet above: the ament_export_targets macro exports the targets for cmake. this is necessary to allow your libraryâs clients to use the target_link_libraries(client private my_library::my_library) syntax. if the export set includes a library, add the option has_library_target to ament_export_targets , which adds potential libraries to environment variables. the ament_export_dependencies exports dependencies to downstream packages. this is necessary so that the user of the library does not have to call find_package for those dependencies, too. warning calling ament_export_targets , ament_export_dependencies , or other ament commands from a cmake subdirectory will not work as expected. this is because the cmake subdirectory has no way of setting necessary variables in the parent scope where ament_package is called. note windows dlls are treated as runtime artifacts and installed into the runtime destination folder. it is therefore advised to keep the runtime install even when developing libraries on unix based systems. the export notation of the install call requires additional attention: it installs the cmake files for the my_library target. it must be named exactly the same as the argument in ament_export_targets . to ensure that it can be used via ament_target_dependencies , it should not be named exactly the same as the library name, but instead should have a prefix like export_ (as shown above). all install paths are relative to cmake_install_prefix , which is already set correctly by colcon/ament. there are two additional functions which are available, but are superfluous for target based installs: ament_export_include_directories ( "include/{project_name}" ) ament_export_libraries ( my_library ) the first macro marks the directory of the exported include directories. the second macro marks the location of the installed library (this is done by the has_library_target argument in the call to ament_export_targets ). these should only be used if the downstream projects canât or donât want to use cmake target based dependencies. some of the macros can take different types of arguments for non-target exports, but since the recommended way for modern make is to use targets, we will not cover them here. documentation of these options can be found in the source code itself. when installing an executable, the following stanza must be followed exactly for the rest of the ros tooling to find it: install ( targets my_exe destination lib/ { project_name } ) in the case that a package has both libraries and executables, make sure to combine the advice from both âlibrariesâ and âexecutablesâ above. linting and testing ï in order to separate testing from building the library with colcon, wrap all calls to linters and tests in a conditional: if ( build_testing ) find_package ( ament_cmake_gtest required ) ament_add_gtest ( <tests> ) endif () linting ï itâs advised to use the combined call from ament_lint_auto : find_package ( ament_lint_auto required ) ament_lint_auto_find_test_dependencies () this will run linters as defined in the package.xml . it is recommended to use the set of linters defined by the package ament_lint_common . the individual linters included there, as well as their functions, can be seen in the ament_lint_common docs . linters provided by ament can also be added separately, instead of running ament_lint_auto . one example of how to do so can be found in the ament_cmake_lint_cmake documentation . testing ï ament contains cmake macros to simplify setting up gtests. call: find_package ( ament_cmake_gtest ) ament_add_gtest ( some_test <test_sources> ) to add a gtest. this is then a regular target which can be linked against other libraries (such as the project library). the macros have additional parameters: append_env : append environment variables. for instance you can add to the ament prefix path by calling: find_package ( ament_cmake_gtest required ) ament_add_gtest ( some_test <test_sources> append_env path=some/addtional/path/for/testing/resources ) append_library_dirs : append libraries so that they can be found by the linker at runtime. this can be achieved by setting environment variables like path on windows and ld_library_path on linux, but this makes the call platform specific. env : set environment variables (same syntax as append_env ). timeout : set a test timeout in second. the default for gtests is 60 seconds. for example: ament_add_gtest ( some_test <test_sources> timeout 120 ) skip_test : skip this test (will be shown as âpassedâ in the console output). skip_linking_main_libraries : donât link against gtest. working_directory : set the working directory for the test. the default working directory otherwise is the cmake_current_binary_dir , which is described in the cmake documentation . similarly, there is a cmake macro to set up gtest including gmock: find_package ( ament_cmake_gmock required ) ament_add_gmock ( some_test <test_sources> ) it has the same additional parameters as ament_add_gtest . extending ament ï it is possible to register additional macros/functions with ament_cmake and extend it in several ways. adding a function/macro to ament ï extending ament will often times mean that you want to have some functions available to other packages. the best way to provide the macro to client packages is to register it with ament. this can be done by appending the {project_name}_config_extras variable, which is used by ament_package() via list ( append { project_name } _config_extras path/to/file.cmake " other/pathto/file.cmake" ) alternatively, you can directly add the files to the ament_package() call: ament_package ( config_extras path/to/file.cmake other/pathto/file.cmake ) adding to extension points ï in addition to simple files with functions that can be used in other packages, you can also add extensions to ament. those extensions are scripts which are executed with the function which defines the extension point. the most common use-case for ament extensions is probably registering rosidl message generators: when writing a generator, you normally want to generate all messages and services with your generator also without modifying the code for the message/service definition packages. this is possible by registering the generator as an extension to rosidl_generate_interfaces . as an example, see ament_register_extension ( "rosidl_generate_interfaces" "rosidl_generator_cpp" "rosidl_generator_cpp_generate_interfaces.cmake" ) which registers the macro rosidl_generator_cpp_generate_interfaces.cmake for the package rosidl_generator_cpp to the extension point rosidl_generate_interfaces . when the extension point gets executed, this will trigger the execution of the script rosidl_generator_cpp_generate_interfaces.cmake here. in particular, this will call the generator whenever the function rosidl_generate_interfaces gets executed. the most important extension point for generators, aside from rosidl_generate_interfaces , is ament_package , which will simply execute scripts with the ament_package() call. this extension point is useful when registering resources (see below). ament_register_extension is a function which takes exactly three arguments: extension_point : the name of the extension point (most of the time this will be one of ament_package or rosidl_generate_interfaces ) package_name : the name of the package containing the cmake file (i.e. the project name of the project where the file is written to) cmake_filename : the cmake file executed when the extension point is run note it is possible to define custom extension points in a similar manner to ament_package and rosidl_generate_interfaces , but this should hardly be necessary. adding extension points ï very rarely, it might be interesting to define a new extension point to ament. extension points can be registered within a macro so that all extensions will be executed when the corresponding macro is called. to do so: define and document a name for your extension (e.g. my_extension_point ), which is the name passed to the ament_register_extension macro when using the extension point. in the macro/function which should execute the extensions call: ament_execute_extensions ( my_extension_point ) ament extensions work by defining a variable containing the name of the extension point and filling it with the macros to be executed. upon calling ament_execute_extensions , the scripts defined in the variable are then executed one after another. adding resources ï especially when developing plugins or packages which allow plugins it is often essential to add resources to one ros package from another (e.g. a plugin). examples can be plugins for tools using the pluginlib. this can be achieved using the ament index (also called âresource indexâ). the ament index explained ï for details on the design and intentions, see here in principle, the ament index is contained in a folder within the install/share folder of your package. it contains shallow subfolders named after different types of resources. within the subfolder, each package providing said resource is referenced by name with a âmarker fileâ. the file may contain whatever content necessary to obtain the resources, e.g. relative paths to the installation directories of the resource, it may also be simply empty. to give an example, consider providing display plugins for rviz: when providing rviz plugins in a project named my_rviz_displays which will be read by the pluginlib, you will provide a plugin_description.xml file, which will be installed and used by the pluginlib to load the plugins. to achieve this, the plugin_description.xml is registered as a resource in the resource_index via pluginlib_export_plugin_description_file ( rviz_common plugins_description.xml ) when running colcon build , this installs a file my_rviz_displays into a subfolder rviz_common__pluginlib__plugin into the resource_index. pluginlib factories within rviz_common will know to gather information from all folders named rviz_common__pluginlib__plugin for packages that export plugins. the marker file for pluginlib factories contains an install-folder relative path to the plugins_description.xml file (and the name of the library as marker file name). with this information, the pluginlib can load the library and know which plugins to load from the plugin_description.xml file. as a second example, consider the possibility to let your own rviz plugins use your own custom meshes. meshes get loaded at startup time so that the plugin owner does not have to deal with it, but this implies rviz has to know  the meshes. to achieve this, rviz provides a function: register_rviz_ogre_media_exports ( directories <my_dirs> ) this registers the directories as an ogre_media resource in the ament index. in short, it installs a file named after the project which calls the function into a subfolder called rviz_ogre_media_exports . the file contains the install folder relative paths to the directories listed in the macros. on startup time, rviz can now search for all folders called rviz_ogre_media_exports and load resources in all folders provided. these searches are done using ament_index_cpp (or ament_index_py for python packages). in the following sections we will explore how to add your own resources to the ament index and provide best practices for doing so. querying the ament index ï if necessary, it is possible to query the ament index for resources via cmake. to do so, there are three functions: ament_index_has_resource : obtain a prefix path to the resource if it exists with the following parameters: var : the output parameter: fill this variable with false if the resource does not exist or the prefix path to the resource otherwise resource_type : the type of the resource (e.g. rviz_common__pluginlib__plugin ) resource_name : the name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. rviz_default_plugins ) ament_index_get_resource : obtain the content of a specific resource, i.e. the contents of the marker file in the ament index. var : the output parameter: filled with the content of the resource marker file if it exists. resource_type : the type of the resource (e.g. rviz_common__pluginlib__plugin ) resource_name : the name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. rviz_default_plugins ) prefix_path : the prefix path to search for (usually, the default ament_index_get_prefix_path() will be enough). note that ament_index_get_resource will throw an error if the resource does not exist, so it might be necessary to check using ament_index_has_resource . ament_index_get_resources : get all packages which registered resources of a specific type from the index var : output parameter: filled with a list of names of all packages which registered a resource of resource_type resource_type : the type of the resource (e.g. rviz_common__pluginlib__plugin ) prefix_path : the prefix path to search for (usually, the default ament_index_get_prefix_path() will be enough). adding to the ament index ï defining a resource requires two bits of information: a name for the resource which must be unique, a layout of the marker file, which can be anything and could also be empty (this is true for instance for the âpackageâ resource marking a ros 2 package) for the rviz mesh resource, the corresponding choices were: rviz_ogre_media_exports as name of the resource, install path relative paths to all folders containing resources. this will already enable you to write the logic for using the corresponding resource in your package. to allow users to easily register resources for your package, you should furthermore provide macros or functions such as the pluginlib function or rviz_ogre_media_exports function. to register a resource, use the ament function ament_index_register_resource . this will create and install the marker files in the resource_index. as an example, the corresponding call for rviz_ogre_media_exports is the following: ament_index_register_resource ( rviz_ogre_media_exports content { ogre_media_resource_file } ) this installs a file named like {project_name} into a folder rviz_ogre_media_exports into the resource_index with content given by variable {ogre_media_resource_file} . the macro has a number of parameters that can be useful: the first (unnamed) parameter is the name of the resource, which amounts to the name of the folder in the resource_index content : the content of the marker file as string. this could be a list of relative paths, etc. content cannot be used together with content_file . content_file : the path to a file which will be use to create the marker file. the file can be a plain file or a template file expanded with configure_file() . content_file cannot be used together with content . package_name : the name of the package/library exporting the resource, which amounts to the name of the marker file. defaults to {project_name} . ament_index_binary_dir : the base path of the generated ament index. unless really necessary, always use the default {cmake_binary_dir}/ament_cmake_index . skip_install : skip installing the marker file. since only one marker file exists per package, it is usually a problem if the cmake function/macro gets called twice by the same project. however, for large projects it might be best to split up calls registering resources. therefore, it is best practice to let a macro registering a resource such as register_rviz_ogre_media_exports.cmake only fill some variables. the real call to ament_index_register_resource can then be added within an ament extension to ament_package . since there must only ever be one call to ament_package per project, there will always only be one place where the resource gets registered. in the case of rviz_ogre_media_exports this amounts to the following strategy: the macro register_rviz_ogre_media_exports takes a list of folders and appends them to a variable called ogre_media_resource_file . another macro called register_rviz_ogre_media_exports_hook calls ament_index_register_resource if {ogre_media_resource_file} is non-empty. the register_rviz_ogre_media_exports_hook.cmake file is registered as an ament extension in a third file register_rviz_ogre_media_exports_hook-extras.cmake via calling ament_register_extension ( "ament_package" "rviz_rendering" "register_rviz_ogre_media_exports_hook.cmake" ) the files register_rviz_ogre_media_exports.cmake and register_rviz_ogre_media_exports_hook-extra.cmake are registered as config_extra with ament_package() . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling