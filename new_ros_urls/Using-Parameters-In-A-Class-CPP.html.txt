tutorials beginner: client libraries using parameters in a class (c++) edit on github using parameters in a class (c++) ï goal: create and run a class with ros parameters using c++. tutorial level: beginner time: 20 minutes background ï when making your own nodes you will sometimes need to add parameters that can be set from the launch file. this tutorial will show you how to create those parameters in a c++ class, and how to set them in a launch file. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . you have also learned  parameters and their function in a ros 2 system. tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. follow these instructions to create a new workspace named ros2_ws . recall that packages should be created in the src directory, not the root of the workspace. navigate into ros2_ws/src and create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 cpp_parameters --dependencies rclcpp your terminal will return a message verifying the creation of your package cpp_parameters and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml and cmakelists.txt . 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml or cmakelists.txt . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> c++ parameter tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 2 write the c++ node ï inside the ros2_ws/src/cpp_parameters/src directory, create a new file called cpp_parameters_node.cpp and paste the following code within: #include <chrono> #include <functional> #include <string> #include <rclcpp/rclcpp.hpp> using namespace std :: chrono_literals ; class minimalparam : public rclcpp :: node { public : minimalparam () : node ( "minimal_param_node" ) { this -> declare_parameter ( "my_parameter" , "world" ); auto timer_callback = [ this ](){ std :: string my_param = this -> get_parameter ( "my_parameter" ). as_string (); rclcpp_info ( this -> get_logger (), "hello %s!" , my_param . c_str ()); std :: vector < rclcpp :: parameter > all_new_parameters { rclcpp :: parameter ( "my_parameter" , "world" )}; this -> set_parameters ( all_new_parameters ); }; timer_ = this -> create_wall_timer ( 1000 ms , timer_callback ); } private : rclcpp :: timerbase :: sharedptr timer_ ; }; int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < minimalparam > ()); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï the #include statements at the top are the package dependencies. the next piece of code creates the class and the constructor. the first line of this constructor creates a parameter with the name my_parameter and a default value of world . the parameter type is inferred from the default value, so in this case it would be set to a string type. next, a lambda function called timer_callback is declared. it performs a by-reference capture of the current object this , takes no input arguments and returns void. the first line of our timer_callback function gets the parameter my_parameter from the node, and stores it in my_param . then the rclcpp_info function ensures the event is logged. the set_parameters function sets the parameter my_parameter back to the default string value world . in the case that the user changed the parameter externally, this ensures it is always reset back to the original. in the end, timer_ is initialized with a period of 1000ms, which causes the timer_callback function to be executed once a second. class minimalparam : public rclcpp :: node { public : minimalparam () : node ( "minimal_param_node" ) { this -> declare_parameter ( "my_parameter" , "world" ); auto timer_callback = [ this ](){ std :: string my_param = this -> get_parameter ( "my_parameter" ). as_string (); rclcpp_info ( this -> get_logger (), "hello %s!" , my_param . c_str ()); std :: vector < rclcpp :: parameter > all_new_parameters { rclcpp :: parameter ( "my_parameter" , "world" )}; this -> set_parameters ( all_new_parameters ); }; timer_ = this -> create_wall_timer ( 1000 ms , timer_callback ); } last is the declaration of timer_ . private : rclcpp :: timerbase :: sharedptr timer_ ; following our minimalparam is our main . here ros 2 is initialized, an instance of the minimalparam class is constructed, and rclcpp::spin starts processing data from the node. int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < minimalparam > ()); rclcpp :: shutdown (); return 0 ; } 2.1.1 (optional) add parameterdescriptor ï optionally, you can set a descriptor for the parameter. descriptors allow you to specify a text description of the parameter and its constraints, like making it read-only, specifying a range, etc. for that to work, the code in the constructor has to be changed to: // ... class minimalparam : public rclcpp :: node { public : minimalparam () : node ( "minimal_param_node" ) { auto param_desc = rcl_interfaces :: msg :: parameterdescriptor {}; param_desc . description = "this parameter is mine!" ; this -> declare_parameter ( "my_parameter" , "world" , param_desc ); auto timer_callback = [ this ](){ std :: string my_param = this -> get_parameter ( "my_parameter" ). as_string (); rclcpp_info ( this -> get_logger (), "hello %s!" , my_param . c_str ()); std :: vector < rclcpp :: parameter > all_new_parameters { rclcpp :: parameter ( "my_parameter" , "world" )}; this -> set_parameters ( all_new_parameters ); }; timer_ = this -> create_wall_timer ( 1000 ms , timer_callback ); } the rest of the code remains the same. once you run the node, you can then run ros2 param describe /minimal_param_node my_parameter to see the type and description. 2.2 add executable ï now open the cmakelists.txt file. below the dependency find_package(rclcpp required) add the following lines of code. add_executable ( minimal_param_node src/cpp_parameters_node.cpp ) ament_target_dependencies ( minimal_param_node rclcpp ) install ( targets minimal_param_node destination lib/ { project_name } ) 3 build and run ï itâs good practice to run rosdep in the root of your workspace ( ros2_ws ) to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you can skip ahead to next step. rosdep only runs on linux, so you can skip ahead to next step. navigate back to the root of your workspace, ros2_ws , and build your new package: linux macos windows colcon build --packages-select cpp_parameters colcon build --packages-select cpp_parameters colcon build --merge-install --packages-select cpp_parameters open a new terminal, navigate to ros2_ws , and source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the node: ros2 run cpp_parameters minimal_param_node the terminal should return the following message every second: [info] [minimal_param_node]: hello world! now you can see the default value of your parameter, but you want to be able to set it yourself. there are two ways to accomplish this. 3.1 change via the console ï this part will use the knowledge you have gained from the tutorial  parameters and apply it to the node you have just created. make sure the node is running: ros2 run cpp_parameters minimal_param_node open another terminal, source the setup files from inside ros2_ws again, and enter the following line: ros2 param list there you will see the custom parameter my_parameter . to change it, simply run the following line in the console: ros2 param set /minimal_param_node my_parameter earth you know it went well if you got the output set parameter successful . if you look at the other terminal, you should see the output change to [info] [minimal_param_node]: hello earth! 3.2 change via a launch file ï you can also set the parameter in a launch file, but first you will need to add the launch directory. inside the ros2_ws/src/cpp_parameters/ directory, create a new directory called launch . in there, create a new file called cpp_parameters_launch.py from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = "cpp_parameters" , executable = "minimal_param_node" , name = "custom_minimal_param_node" , output = "screen" , emulate_tty = true , parameters = [ { "my_parameter" : "earth" } ] ) ]) here you can see that we set my_parameter to earth when we launch our node minimal_param_node . by adding the two lines below, we ensure our output is printed in our console. output="screen", emulate_tty=true, now open the cmakelists.txt file. below the lines you added earlier, add the following lines of code. install( directory launch destination share/{project_name} ) open a console and navigate to the root of your workspace, ros2_ws , and build your new package: linux macos windows colcon build --packages-select cpp_parameters colcon build --packages-select cpp_parameters colcon build --merge-install --packages-select cpp_parameters then source the setup files in a new terminal: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the node using the launch file we have just created: ros2 launch cpp_parameters cpp_parameters_launch.py the terminal should return the following message the first time: [info] [custom_minimal_param_node]: hello earth! further outputs should show [info] [minimal_param_node]: hello world! every second. summary ï you created a node with a custom parameter that can be set either from a launch file or the command line. you added the dependencies, executables, and a launch file to the package configuration files so that you could build and run them, and see the parameter in action. next steps ï now that you have some packages and ros 2 systems of your own, the next tutorial will show you how to examine issues in your environment and systems in case you have problems. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling