tutorials advanced recording a bag from a node (c++) edit on github recording a bag from a node (c++) ï goal: record data from your own c++ node to a bag. tutorial level: advanced time: 20 minutes background ï rosbag2 doesnât just provide the ros2 bag command line tool. it also provides a c++ api for reading from and writing to a bag from your own source code. this allows you to subscribe to a topic and save the received data to a bag at the same time as performing any other processing of your choice on that data. prerequisites ï you should have the rosbag2 packages installed as part of your regular ros 2 setup. if youâve installed from deb packages on linux, it may be installed by default. if it is not, you can install it using this command. sudo apt install ros-jazzy-rosbag2 this tutorial discusses using ros 2 bags, including from the terminal. you should have already completed the basic ros 2 bag tutorial . tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate into the ros2_ws directory created in a previous tutorial . navigate into the ros2_ws/src directory and create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 bag_recorder_nodes --dependencies example_interfaces rclcpp rosbag2_cpp std_msgs your terminal will return a message verifying the creation of your package bag_recorder_nodes and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml and cmakelists.txt . in this case, the package will use the rosbag2_cpp package as well as the rclcpp package. a dependency on the example_interfaces package is also required for later parts of this tutorial. 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml or cmakelists.txt . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> c++ bag writing tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 2 write the c++ node ï inside the ros2_ws/src/bag_recorder_nodes/src directory, create a new file called simple_bag_recorder.cpp and paste the following code into it. #include <rclcpp/rclcpp.hpp> #include <std_msgs/msg/string.hpp> #include <rosbag2_cpp/writer.hpp> class simplebagrecorder : public rclcpp :: node { public : simplebagrecorder () : node ( "simple_bag_recorder" ) { writer_ = std :: make_unique < rosbag2_cpp :: writer > (); writer_ -> open ( "my_bag" ); auto _callback_lambda = [ this ]( std :: shared_ptr < rclcpp :: serializedmessage > msg ){ rclcpp :: time time_stamp = this -> now (); writer_ -> write ( msg , "chatter" , "std_msgs/msg/string" , time_stamp ); }; _ = create_ < std_msgs :: msg :: string > ( "chatter" , 10 , _callback_lambda ); } private : rclcpp ::  < std_msgs :: msg :: string >:: sharedptr _ ; std :: unique_ptr < rosbag2_cpp :: writer > writer_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < simplebagrecorder > ()); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï the #include statements at the top are the package dependencies. note the inclusion of headers from the rosbag2_cpp package for the functions and structures necessary to work with bag files. in the class constructor we begin by creating the writer object we will use to write to the bag. writer_ = std :: make_unique < rosbag2_cpp :: writer > (); now that we have a writer object, we can open the bag using it. we specify just the uri of the bag to create, leaving other options at their defaults. the default storage options are used, which means that an mcap -format bag will be created. the default conversion options are used, too, which will perform no conversion, instead storing messages in the serialisation format they are received in. writer_ -> open ( "my_bag" ); with the writer now set up to record data we pass to it, we create a  and specify a callback for it. we will write data to the bag in the callback. auto _callback_lambda = [ this ]( std :: shared_ptr < rclcpp :: serializedmessage > msg ){ rclcpp :: time time_stamp = this -> now (); writer_ -> write ( msg , "chatter" , "std_msgs/msg/string" , time_stamp ); }; _ = create_ < std_msgs :: msg :: string > ( "chatter" , 10 , _callback_lambda ); the callback itself is different from a typical callback. rather than receiving an instance of the data type of the topic, we instead receive a rclcpp::serializedmessage . we do this for two reasons. the message data will need to be serialized by rosbag2 before being written to the bag, so rather than unserializing it when receiving the data and then re-serializing it, we ask ros to just give us the serialized message as-is. the writer api can accept a serialized message. auto _callback_lambda = [ this ]( std :: shared_ptr < rclcpp :: serializedmessage > msg ){ within the  callback, the first thing to do is determine the time stamp to use for the stored message. this can be anything appropriate to your data, but two common values are the time at which the data was produced, if known, and the time it is received. the second option, the time of reception, is used here. rclcpp :: time time_stamp = this -> now (); we can then write the message into the bag. because we have not yet registered any topics with the bag, we must specify the full topic information with the message. this is why we pass in the topic name and the topic type. writer_ -> write ( msg , "chatter" , "std_msgs/msg/string" , time_stamp ); the class contains two member variables. the  object. a managed pointer to the writer object used to write to the bag. note the type of writer used here is the rosbag2_cpp::writer , the generic writer interface. other writers may be available with different behaviours. rclcpp ::  < std_msgs :: msg :: string >:: sharedptr _ ; std :: unique_ptr < rosbag2_cpp :: writer > writer_ ; the file finishes with the main function used to create an instance of the node and start ros processing it. int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < simplebagrecorder > ()); rclcpp :: shutdown (); return 0 ; } 2.2 add executable ï now open the cmakelists.txt file. near the top of the file, change cmake_cxx_standard from 14 to 17 . # default to c++17 if(not cmake_cxx_standard) set(cmake_cxx_standard 17) endif() below the dependencies block, which contains find_package(rosbag2_cpp required) , add the following lines of code. add_executable(simple_bag_recorder src/simple_bag_recorder.cpp) ament_target_dependencies(simple_bag_recorder rclcpp rosbag2_cpp std_msgs) install(targets simple_bag_recorder destination lib/{project_name} ) 3 build and run ï navigate back to the root of your workspace, ros2_ws , and build your new package. linux macos windows colcon build --packages-select bag_recorder_nodes colcon build --packages-select bag_recorder_nodes colcon build --merge-install --packages-select bag_recorder_nodes open a new terminal, navigate to ros2_ws , and source the setup files. linux macos windows source install/setup.bash source install/setup.bash call install/setup.bat now run the node: ros2 run bag_recorder_nodes simple_bag_recorder open a second terminal and run the talker example node. ros2 run demo_nodes_cpp talker this will start publishing data on the chatter topic. as the bag-writing node receives this data, it will write it to the my_bag bag. terminate both nodes. then, in one terminal start the listener example node. ros2 run demo_nodes_cpp listener in the other terminal, use ros2 bag to play the bag recorded by your node. ros2 bag play my_bag you will see the messages from the bag being received by the listener node. if you wish to run the bag-writing node again, you will first need to delete the my_bag directory. 4 record synthetic data from a node ï any data can be recorded into a bag, not just data received over a topic. a common use case for writing to a bag from your own node is to generate and store synthetic data. in this section you will learn how to write a node that generates some data and stores it in a bag. we will demonstrate two approaches for doing this. the first uses a node with a timer; this is the approach that you would use if your data generation is external to the node, such as reading data directly from hardware (e.g. a camera). the second approach does not use a node; this is the approach you can use when you do not need to use any functionality from the ros infrastructure. 4.1 write a c++ node ï inside the ros2_ws/src/bag_recorder_nodes/src directory, create a new file called data_generator_node.cpp and paste the following code into it. #include <chrono> #include <example_interfaces/msg/int32.hpp> #include <rclcpp/rclcpp.hpp> #include <rosbag2_cpp/writer.hpp> using namespace std :: chrono_literals ; class datagenerator : public rclcpp :: node { public : datagenerator () : node ( "data_generator" ) { data_ . data = 0 ; writer_ = std :: make_unique < rosbag2_cpp :: writer > (); writer_ -> open ( "timed_synthetic_bag" ); writer_ -> create_topic ( { 0u , "synthetic" , "example_interfaces/msg/int32" , rmw_get_serialization_format (), {}, "" , }); auto timer_callback_lambda = [ this ](){ return this -> timer_callback ();}; timer_ = create_wall_timer ( 1 s , timer_callback_lambda ); } private : void timer_callback () { writer_ -> write ( data_ , "synthetic" , now ()); ++ data_ . data ; } rclcpp :: timerbase :: sharedptr timer_ ; std :: unique_ptr < rosbag2_cpp :: writer > writer_ ; example_interfaces :: msg :: int32 data_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < datagenerator > ()); rclcpp :: shutdown (); return 0 ; } 4.2 examine the code ï much of this code is the same as the first example. the important differences are described here. first, the name of the bag is changed. writer_ -> open ( "timed_synthetic_bag" ); in this example we are registering the topic with the bag in advance. this is optional in most cases, but it must be done when passing in a serialized message without topic information. writer_ -> create_topic ( { 0u , "synthetic" , "example_interfaces/msg/int32" , rmw_get_serialization_format (), {}, "" , }); rather than a  to a topic, this node has a timer. the timer fires with a one-second period, and calls the given member function when it does. auto timer_callback_lambda = [ this ](){ return this -> timer_callback ();}; timer_ = create_wall_timer ( 1 s , timer_callback_lambda ); within the timer callback, we generate (or otherwise obtain, e.g. read from a serial port connected to some hardware) the data we wish to store in the bag. the important difference between this and the previous sample is that the data is not yet serialized. instead we are passing a ros message data type to the writer object, in this case an instance of example_interfaces/msg/int32 . the writer will serialize the data for us before writing it into the bag. writer_ -> write ( data_ , "synthetic" , now ()); 4.3 add executable ï open the cmakelists.txt file and add the following lines after the previously-added lines (specifically, after the install(targets ...) macro call). add_executable(data_generator_node src/data_generator_node.cpp) ament_target_dependencies(data_generator_node rclcpp rosbag2_cpp example_interfaces) install(targets data_generator_node destination lib/{project_name} ) 4.4 build and run ï navigate back to the root of your workspace, ros2_ws , and build your package. linux macos windows colcon build --packages-select bag_recorder_nodes colcon build --packages-select bag_recorder_nodes colcon build --merge-install --packages-select bag_recorder_nodes open a new terminal, navigate to ros2_ws , and source the setup files. linux macos windows source install/setup.bash source install/setup.bash call install/setup.bat (if the timed_synthetic_bag directory already exists, you must first delete it before running the node.) now run the node: ros2 run bag_recorder_nodes data_generator_node wait for 30 seconds or so, then terminate the node with ctrl - c . next, play back the created bag. ros2 bag play timed_synthetic_bag open a second terminal and echo the /synthetic topic. ros2 topic echo /synthetic you will see the data that was generated and stored in the bag printed to the console at a rate of one message per second. 5 record synthetic data from an executable ï now that you can create a bag that stores data from a source other than a topic, you will learn how to generate and record synthetic data from a non-node executable. the advantage of this approach is simpler code and rapid creation of a large quantity of data. 5.1 write a c++ executable ï inside the ros2_ws/src/bag_recorder_nodes/src directory, create a new file called data_generator_executable.cpp and paste the following code into it. #include <chrono> #include <rclcpp/rclcpp.hpp> // for rclcpp::clock, rclcpp::duration and rclcpp::time #include <example_interfaces/msg/int32.hpp> #include <rosbag2_cpp/writer.hpp> #include <rosbag2_cpp/writers/sequential_writer.hpp> #include <rosbag2_storage/serialized_bag_message.hpp> using namespace std :: chrono_literals ; int main ( int , char ** ) { example_interfaces :: msg :: int32 data ; data . data = 0 ; std :: unique_ptr < rosbag2_cpp :: writer > writer_ = std :: make_unique < rosbag2_cpp :: writer > (); writer_ -> open ( "big_synthetic_bag" ); writer_ -> create_topic ( { 0u , "synthetic" , "example_interfaces/msg/int32" , rmw_get_serialization_format (), {}, "" , }); rclcpp :: clock clock ; rclcpp :: time time_stamp = clock . now (); for ( int32_t ii = 0 ; ii < 100 ; ++ ii ) { writer_ -> write ( data , "synthetic" , time_stamp ); ++ data . data ; time_stamp += rclcpp :: duration ( 1 s ); } return 0 ; } 5.2 examine the code ï a comparison of this sample and the previous sample will reveal that they are not that different. the only significant difference is the use of a for loop to drive the data generation rather than a timer. notice that we are also now generating time stamps for the data rather than relying on the current system time for each sample. the time stamp can be any value you need it to be. the data will be played back at the rate given by these time stamps, so this is a useful way to control the default playback speed of the samples. notice also that while the gap between each sample is a full second in time, this executable does not need to wait a second between each sample. this allows us to generate a lot of data covering a wide span of time in much less time than playback will take. rclcpp :: clock clock ; rclcpp :: time time_stamp = clock . now (); for ( int32_t ii = 0 ; ii < 100 ; ++ ii ) { writer_ -> write ( data , "synthetic" , time_stamp ); ++ data . data ; time_stamp += rclcpp :: duration ( 1 s ); } 5.3 add executable ï open the cmakelists.txt file and add the following lines after the previously-added lines. add_executable(data_generator_executable src/data_generator_executable.cpp) ament_target_dependencies(data_generator_executable rclcpp rosbag2_cpp example_interfaces) install(targets data_generator_executable destination lib/{project_name} ) 5.4 build and run ï navigate back to the root of your workspace, ros2_ws , and build your package. linux macos windows colcon build --packages-select bag_recorder_nodes colcon build --packages-select bag_recorder_nodes colcon build --merge-install --packages-select bag_recorder_nodes open a terminal, navigate to ros2_ws , and source the setup files. linux macos windows source install/setup.bash source install/setup.bash call install/setup.bat (if the big_synthetic_bag directory already exists, you must first delete it before running the executable.) now run the executable: ros2 run bag_recorder_nodes data_generator_executable note that the executable runs and finishes very quickly. now play back the created bag. ros2 bag play big_synthetic_bag open a second terminal and echo the /synthetic topic. ros2 topic echo /synthetic you will see the data that was generated and stored in the bag printed to the console at a rate of one message per second. even though the bag was generated rapidly it is still played back at the rate the time stamps indicate. summary ï you created a node that records data it receives on a topic into a bag. you tested recording a bag using the node, and verified the data was recorded by playing back the bag. you then went on to create a node and an executable to generate synthetic data and store it in a bag. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling