how-to guides synchronous vs. asynchronous service clients edit on github synchronous vs. asynchronous service clients ï level: intermediate time: 10 minutes introduction ï this guide is intended to warn users of the risks associated with the python synchronous service client call() api. it is very easy to mistakenly cause deadlock when calling services synchronously, so we do not recommend using call() . we provide an example on how to use call() correctly for experienced users who wish to use synchronous calls and are aware of the pitfalls. we also highlight possible scenarios for deadlock that accompany it. because we recommend avoiding sync calls, this guide will also address the features and usage of the recommended alternative, async calls ( call_async() ). the c++ service call api is only available in async, so the comparisons and examples in this guide pertain to python services and clients. the definition of async given here generally applies to c++, with some exceptions. 1 synchronous calls ï a synchronous client will block the calling thread when sending a request to a service until a response has been received; nothing else can happen on that thread during the call. the call can take arbitrary amounts of time to complete. once complete, the response returns directly to the client. the following is an example of how to correctly execute a synchronous service call from a client node, similar to the async node in the simple service and client tutorial. import sys from threading import thread from example_interfaces.srv import addtwoints import rclpy from rclpy.node import node class minimalclientsync ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_client_sync' ) self . cli = self . create_client ( addtwoints , 'add_two_ints' ) while not self . cli . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . req = addtwoints . request () def send_request ( self ): self . req . a = int ( sys . argv [ 1 ]) self . req . b = int ( sys . argv [ 2 ]) return self . cli . call ( self . req ) # this only works because rclpy.spin() is called in a separate thread below. # another configuration, like spinning later in main() or calling this method from a timer callback, would result in a deadlock. def main (): rclpy . init () minimal_client = minimalclientsync () spin_thread = thread ( target = rclpy . spin , args = ( minimal_client ,)) spin_thread . start () response = minimal_client . send_request () minimal_client . get_logger () . info ( 'result of add_two_ints: for %d + %d = %d ' % ( minimal_client . req . a , minimal_client . req . b , response . sum )) minimal_client . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () note inside main() that the client calls rclpy.spin in a separate thread. both send_request and rclpy.spin are blocking, so they need to be on separate threads. 1.1 sync deadlock ï there are several ways that the synchronous call() api can cause deadlock. as mentioned in the comments of the example above, failing to create a separate thread to spin rclpy is one cause of deadlock. when a client is blocking a thread waiting for a response, but the response can only be returned on that same thread, the client will never stop waiting, and nothing else can happen. another cause of deadlock is blocking rclpy.spin by calling a service synchronously in a , timer callback or service callback. for example, if the synchronous clientâs send_request is placed in a callback: def trigger_request ( msg ): response = minimal_client . send_request () # this will cause deadlock minimal_client . get_logger () . info ( 'result of add_two_ints: for %d + %d = %d ' % ( minimal_client . req . a , minimal_client . req . b , response . sum ))  = minimal_client . create_ ( string , 'trigger' , trigger_request , 10 ) rclpy . spin ( minimal_client ) deadlock occurs because rclpy.spin will not preempt the callback with the send_request call. in general, callbacks should only perform light and fast operations. warning when deadlock occurs, you will not receive any indication that the service is blocked. there will be no warning or exception thrown, no indication in the stack trace, and the call will not fail. 2 asynchronous calls ï async calls in rclpy are entirely safe and the recommended method of calling services. they can be made from anywhere without running the risk of blocking other ros and non-ros processes, unlike sync calls. an asynchronous client will immediately return future , a value that indicates whether the call and response is finished (not the value of the response itself), after sending a request to a service. the returned future may be queried for a response at any time. since sending a request doesnât block anything, a loop can be used to both spin rclpy and check future in the same thread, for example: while rclpy . ok (): rclpy . spin_once ( node ) if future . done (): #get response the simple service and client tutorial for python illustrates how to perform an async service call and retrieve the future using a loop. the future can also be retrieved using a timer or callback, like in this example , a dedicated thread, or by another method. it is up to you, as the caller, to decide how to store future , check on its status, and retrieve your response. summary ï it is not recommended to implement a synchronous service client. they are susceptible to deadlock, but will not provide any indication of issue when deadlock occurs. if you must use synchronous calls, the example in section 1 synchronous calls is a safe method of doing so. you should also be aware of the conditions that cause deadlock outlined in section 1.1 sync deadlock . we recommend using async service clients instead. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling