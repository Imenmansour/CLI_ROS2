tutorials beginner: client libraries implementing custom interfaces edit on github implementing custom interfaces ï goal: learn more ways to implement custom interfaces in ros 2. tutorial level: beginner time: 15 minutes background ï in a previous tutorial , you learned how to create custom msg and srv interfaces. while best practice is to declare interfaces in dedicated interface packages, sometimes it can be convenient to declare, create and use an interface all in one package. recall that interfaces can currently only be defined in cmake packages. it is possible, however, to have python libraries and nodes in cmake packages (using ament_cmake_python ), so you could define interfaces and python nodes together in one package. weâll use a cmake package and c++ nodes here for the sake of simplicity. this tutorial will focus on the msg interface type, but the steps here are applicable to all interface types. prerequisites ï we assume youâve reviewed the basics in the creating custom msg and srv files tutorial before working through this one. you should have ros 2 installed , a workspace , and an understanding of creating packages . as always, donât forget to source ros 2 in every new terminal you open. tasks ï 1 create a package ï in your workspace src directory, create a package more_interfaces and make a directory within it for msg files: ros2 pkg create --build-type ament_cmake --license apache-2.0 more_interfaces mkdir more_interfaces/msg 2 create a msg file ï inside more_interfaces/msg , create a new file addressbook.msg , and paste the following code to create a message meant to carry information  an individual: uint8 phone_type_home = 0 uint8 phone_type_work = 1 uint8 phone_type_mobile = 2 string first_name string last_name string phone_number uint8 phone_type this message is composed of these fields: first_name: of type string last_name: of type string phone_number: of type string phone_type: of type uint8, with several named constant values defined note that itâs possible to set default values for fields within a message definition. see interfaces for more ways you can customize interfaces. next, we need to make sure that the msg file is turned into source code for c++, python, and other languages. 2.1 build a msg file ï open package.xml and add the following lines: <buildtool_depend> rosidl_default_generators </buildtool_depend> <exec_depend> rosidl_default_runtime </exec_depend> <member_of_group> rosidl_interface_packages </member_of_group> note that at build time, we need rosidl_default_generators , while at runtime, we only need rosidl_default_runtime . open cmakelists.txt and add the following lines: find the package that generates message code from msg/srv files: find_package ( rosidl_default_generators required ) declare the list of messages you want to generate: set ( msg_files "msg/addressbook.msg" ) by adding the .msg files manually, we make sure that cmake knows when it has to reconfigure the project after you add other .msg files. generate the messages: rosidl_generate_interfaces ( { project_name } { msg_files } ) also make sure you export the message runtime dependency: ament_export_dependencies ( rosidl_default_runtime ) now youâre ready to generate source files from your msg definition. weâll skip the compile step for now as weâll do it all together below in step 4. 3 use an interface from the same package ï now we can start writing code that uses this message. in more_interfaces/src create a file called publish_address_book.cpp and paste the following code: #include <chrono> #include <memory> #include "rclcpp/rclcpp.hpp" #include "more_interfaces/msg/address_book.hpp" using namespace std :: chrono_literals ; class addressbookpublisher : public rclcpp :: node { public : addressbookpublisher () : node ( "address_book_publisher" ) { address_book_publisher_ = this -> create_publisher < more_interfaces :: msg :: addressbook > ( "address_book" , 10 ); auto publish_msg = [ this ]() -> void { auto message = more_interfaces :: msg :: addressbook (); message . first_name = "john" ; message . last_name = "doe" ; message . phone_number = "1234567890" ; message . phone_type = message . phone_type_mobile ; std :: cout << "publishing  \n first:" << message . first_name << " last:" << message . last_name << std :: endl ; this -> address_book_publisher_ -> publish ( message ); }; timer_ = this -> create_wall_timer ( 1 s , publish_msg ); } private : rclcpp :: publisher < more_interfaces :: msg :: addressbook >:: sharedptr address_book_publisher_ ; rclcpp :: timerbase :: sharedptr timer_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < addressbookpublisher > ()); rclcpp :: shutdown (); return 0 ; } 3.1 the code explained ï include the header of our newly created addressbook.msg . #include "more_interfaces/msg/address_book.hpp" create a node and an addressbook publisher. using namespace std :: chrono_literals ; class addressbookpublisher : public rclcpp :: node { public : addressbookpublisher () : node ( "address_book_publisher" ) { address_book_publisher_ = this -> create_publisher < more_interfaces :: msg :: addressbook > ( "address_book" ); create a callback to publish the messages periodically. auto publish_msg = [ this ]() -> void { create an addressbook message instance that we will later publish. auto message = more_interfaces :: msg :: addressbook (); populate addressbook fields. message . first_name = "john" ; message . last_name = "doe" ; message . phone_number = "1234567890" ; message . phone_type = message . phone_type_mobile ; finally send the message periodically. std :: cout << "publishing  \n first:" << message . first_name << " last:" << message . last_name << std :: endl ; this -> address_book_publisher_ -> publish ( message ); create a 1 second timer to call our publish_msg function every second. timer_ = this -> create_wall_timer ( 1 s , publish_msg ); 3.2 build the publisher ï we need to create a new target for this node in the cmakelists.txt : find_package ( rclcpp required ) add_executable ( publish_address_book src/publish_address_book.cpp ) ament_target_dependencies ( publish_address_book rclcpp ) install ( targets publish_address_book destination lib/ { project_name } ) 3.3 link against the interface ï in order to use the messages generated in the same package we need to use the following cmake code: rosidl_get_typesupport_target ( cpp_typesupport_target { project_name } rosidl_typesupport_cpp ) target_link_libraries ( publish_address_book "{cpp_typesupport_target}" ) this finds the relevant generated c++ code from addressbook.msg and allows your target to link against it. you may have noticed that this step was not necessary when the interfaces being used were from a different package that was built independently. this cmake code is only required when you want to use interfaces in the same package as the one in which they are defined. 4 try it out ï return to the root of the workspace to build the package: linux macos windows cd ~/ros2_ws colcon build --packages-up-to more_interfaces cd ~/ros2_ws colcon build --packages-up-to more_interfaces cd /ros2_ws colcon build --merge-install --packages-up-to more_interfaces then source the workspace and run the publisher: linux macos windows source install/local_setup.bash ros2 run more_interfaces publish_address_book . install/local_setup.bash ros2 run more_interfaces publish_address_book call install/local_setup.bat ros2 run more_interfaces publish_address_book or using powershell: install/local_setup.ps1 ros2 run more_interfaces publish_address_book you should see the publisher relaying the msg you defined, including the values you set in publish_address_book.cpp . to confirm the message is being published on the address_book topic, open another terminal, source the workspace, and call topic echo : linux macos windows source install/setup.bash ros2 topic echo /address_book . install/setup.bash ros2 topic echo /address_book call install/setup.bat ros2 topic echo /address_book or using powershell: install/setup.ps1 ros2 topic echo /address_book we wonât create a subscriber in this tutorial, but you can try to write one yourself for practice (use writing a simple publisher and subscriber (c++) to help). 5 (extra) use an existing interface definition ï note you can use an existing interface definition in a new interface definition. for example, letâs say there is a message named .msg that belongs to an existing ros 2 package named rosidl_tutorials_msgs . assume that its definition is identical to our custom-made addressbook.msg interface from earlier. in that case you could have defined addressbook.msg (an interface in the package with your nodes) as type  (an interface in a separate package). you could even define addressbook.msg as an array of type  , like so: rosidl_tutorials_msgs /  [] address_book to generate this message you would need to declare a dependency on .msg's package, rosidl_tutorials_msgs , in package.xml : <build_depend> rosidl_tutorials_msgs </build_depend> <exec_depend> rosidl_tutorials_msgs </exec_depend> and in cmakelists.txt : find_package ( rosidl_tutorials_msgs required ) rosidl_generate_interfaces ( { project_name } { msg_files } dependencies rosidl_tutorials_msgs ) you would also need to include the header of .msg in your publisher node in order to be able to add s to your address_book . #include "rosidl_tutorials_msgs/msg/.hpp" you could change the callback to something like this: auto publish_msg = [ this ]() -> void { auto msg = std :: make_shared < more_interfaces :: msg :: addressbook > (); { rosidl_tutorials_msgs :: msg ::   ;  . first_name = "john" ;  . last_name = "doe" ;  . phone_number = "1234567890" ;  . phone_type = message . phone_type_mobile ; msg -> address_book . push_back (  ); } { rosidl_tutorials_msgs :: msg ::   ;  . first_name = "jane" ;  . last_name = "doe" ;  . phone_number = "4254242424" ;  . phone_type = message . phone_type_home ; msg -> address_book . push_back (  ); } std :: cout << "publishing address book:" << std :: endl ; for ( auto  : msg -> address_book ) { std :: cout << "first:" <<  . first_name << " last:" <<  . last_name << std :: endl ; } address_book_publisher_ -> publish ( * msg ); }; building and running these changes would show the msg defined as expected, as well as the array of msgs defined above. summary ï in this tutorial, you tried out different field types for defining interfaces, then built an interface in the same package where itâs being used. you also learned how to use another interface as a field type, as well as the package.xml , cmakelists.txt , and #include statements necessary for utilizing that feature. next steps ï next you will create a simple ros 2 package with a custom parameter that you will learn to set from a launch file. again, you can choose to write it in either c++ or python . related content ï there are several design articles on ros 2 interfaces and the idl (interface definition language). other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling