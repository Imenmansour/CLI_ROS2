distributions end-of-life distributions galactic geochelone ( galactic ) edit on github galactic geochelone ( galactic ) ï galactic geochelone is the seventh release of ros 2. what follows is highlights of the important changes and features in galactic geochelone since the last release. for a list of all of the changes since foxy, see the long form changelog . supported platforms ï galactic geochelone is primarily supported on the following platforms: tier 1 platforms: ubuntu 20.04 (focal): amd64 and arm64 windows 10 (visual studio 2019): amd64 tier 2 platforms: rhel 8: amd64 tier 3 platforms: ubuntu 20.04 (focal): arm32 debian bullseye (11): amd64 , arm64 and arm32 openembedded thud (2.6) / webos ose: arm32 and arm64 mac macos 10.14 (mojave): amd64 for more information  rmw implementations, compiler / interpreter versions, and system dependency versions see rep 2000 . installation ï install galactic geochelone new features in this ros 2 release ï ability to specify per-logger log levels ï it is now possible to specify different logging levels for different loggers on the command line: ros2 run demo_nodes_cpp talker --ros-args --log-level warn --log-level talker: = debug the above command sets a global log level of warn, but sets the log level of the talker node messages to debug. the --log-level command-line option can be passed an arbitrary number of times to set different log levels for each logger. ability to configure logging directory through environment variables ï it is now possible to configure the logging directory through two environment variables: ros_log_dir and ros_home . the logic is as follows: use ros_log_dir if ros_log_dir is set and not empty. otherwise, use ros_home/log , using ~/.ros for ros_home if not set or if empty. thus the default value stays the same: ~/.ros/log . related prs: ros2/rcl_logging#53 and ros2/launch#460 . for example: ros_log_dir = /tmp/foo ros2 run demo_nodes_cpp talker will place all logs in /tmp/foo . ros_home = /path/to/home ros2 run demo_nodes_cpp talker will place all logs in /path/to/home/log . ability to invoke rosidl pipeline outside cmake ï it is now straightforward to invoke the rosidl interface generation pipeline outside cmake. source code generators and interface definition translators are accessible through a unified command line interface. for example, given a demo message in some demo package like: mkdir -p demo/msg cd demo cat << eof > msg/demo.msg std_msgs/header header geometry_msgs/twist twist geometry_msgs/accel accel eof it is easy to generate c, c++, and python support source code: rosidl generate -o gen -t c -t cpp -t py -i ( ros2 pkg prefix --share std_msgs ) /.. \ -i ( ros2 pkg prefix --share geometry_msgs ) /.. demo msg/demo.msg generated source code will be put in the gen directory. one may also translate the message definition to a different format for a third-party code generation tool to consume: rosidl translate -o gen --to idl -i ( ros2 pkg prefix --share std_msgs ) /.. \ -i ( ros2 pkg prefix --share geometry_msgs ) /.. demo msg/demo.msg the translated message definition will be put in the gen directory. note that these tools generate sources but do not build it â that responsibility is still on the caller. this is a first step towards enabling rosidl interface generation in build systems other than cmake. see the design document for further reference and next steps. externally configure qos at start-up ï it is now possible to externally configure the qos settings for a node at start-up time. qos settings are not configurable during runtime; they are only configurable at start-up. node authors must opt-in to enable changing qos settings at start-up. if the feature is enabled on a node, then qos settings can be set with ros parameters when a node first starts. demos in c++ and python can be found here. see the design document for more details . note, user code handling parameter changes with registered callbacks should avoid rejecting updates for unknown parameters. it was considered bad practice prior to galactic, but with externally configurable qos enabled it will result in a hard failure. related prs: ros2/rclcpp#1408 and ros2/rclpy#635 python point_cloud2 utilities available ï several utilities for interacting with pointcloud2 messages in python were ported to ros 2 . these utilities allow one to get a list of points from a pointcloud2 message ( read_points and read_points_list ), and to create a pointcloud2 message from a list of points ( create_cloud and create_cloud_xyz32 ). an example of creating pointcloud 2 message, then reading it back: import sensor_msgs_py.point_cloud2 from std_msgs.msg import header pointlist = [[ 0.0 , 0.1 , 0.2 ]] pointcloud = sensor_msgs_py . point_cloud2 . create_cloud_xyz32 ( header ( frame_id = 'frame' ), pointlist ) for point in sensor_msgs_py . point_cloud2 . read_points ( pointcloud ): print ( point ) rviz2 time panel ï the rviz2 time panel, which shows the current wall and ros time, along with the elapsed wall and ros time, has been ported to rviz2 . to enable the time panel, click on panels -> add new panel, and select âtimeâ. a panel that looks like the following will appear: ros2 topic echo can print serialized data ï when debugging middleware issues, it can be useful to see the raw serialized data that the rmw is sending. the âraw command-line flag was added to ros2 topic echo to show this data. to see this in action, run the following commands. terminal 1:  ros2 topic pub /chatter std_msgs/msg/string "data: 'hello'" terminal 2:  ros2 topic echo --raw /chatter b '\x00\x01\x00\x00\x06\x00\x00\x00hello\x00\x00\x00' --- get the yaml representation of messages ï it is now possible to get a yaml representation of all messages in c++ using the to_yaml function. an example of code that prints out the yaml representation: #include <cstdio> #include <std_msgs/msg/string.hpp> int main () { std_msgs :: msg :: string msg ; msg . data = "hello world" ; printf ( "%s" , rosidl_generator_traits :: to_yaml ( msg ). c_str ()); return 0 ; } ability to load parameter files at runtime through the ros2 command ï ros 2 has long had the ability to specify parameter values at startup (through command-line arguments or a yaml file), and to dump current parameters out to a file (through ros2 param dump ). galactic adds the ability to load parameter values at runtime from a yaml file using the ros2 param load verb. for example: terminal 1:  ros2 run demo_nodes_cpp parameter_blackboard terminal 2:  ros2 param set /parameter_blackboard foo bar # sets 'foo' parameter to value 'bar'  ros2 param dump /parameter_blackboard # dumps current value of parameters to ./parameter_blackboard.yaml  ros2 param set /parameter_blackboard foo different # sets 'foo' parameter to value 'different'  ros2 param load /parameter_blackboard ./parameter_blackboard.yaml # reloads previous state of parameters, 'foo' is back to 'bar' tools to check for qos incompatibilities ï built on top of new qos compatibility check apis, ros2doctor and rqt_graph can now detect and report qos incompatibilities between publishers and s. given a publisher and a  with incompatible qos settings : terminal 1:  ros2 run demo_nodes_py talker_qos -n 1000 # i.e. best_effort publisher terminal 2:  ros2 run demo_nodes_py listener_qos --reliable -n 1000 # i.e. reliable  ros2doctor reports:  ros2 doctor --report # ... qos compatibility list topic [ type ] : /chatter [ std_msgs/msg/string ] publisher node : talker_qos subscriber node : listener_qos compatibility status : error: best effort publisher and reliable  ; # ... while rqt_graph shows: related prs: ros2/ros2cli#621 , ros-visualization/rqt_graph#61 use launch substitutions in parameter files ï just like rosparam tags in ros 1 roslaunch , launch_ros can now evaluate substitutions in parameter files. for example, given some parameter_file_with_substitutions.yaml like the following: /** : ros__parameters : launch_date : (command date) set allow_substs to true to get substitutions evaluated upon node launch: import launch import launch_ros.parameter_descriptions import launch_ros.actions def generate_launch_description (): return launch . launchdescription ([ launch_ros . actions . node ( package = 'demo_nodes_cpp' , executable = 'parameter_blackboard' , parameters = [ launch_ros . parameter_descriptions . parameterfile ( param_file = 'parameter_file_with_substitutions.yaml' , allow_substs = true ) ] ) ]) xml launch files also support this. <launch> <node pkg= "demo_nodes_cpp" exec= "parameter_blackboard" > <param from= "parameter_file_with_substitutions.yaml" allow_substs= "true" /> </node> </launch> related pr: ros2/launch_ros#168 support for unique network flows ï applications may now require udp/tcp and ip-based rmw implementations to provide unique network flows (i.e. unique differentiated services code points and/or unique ipv6 flow labels and/or unique ports in ip packet headers) for publishers and s, enabling qos specifications for these ip streams in network architectures that support such a feature, like 5g networks. to see this in action, you may run these c++ examples (to be found in the ros2/examples repository): terminal 1: ros2 run examples_rclcpp_minimal_publisher publisher_member_function_with_unique_network_flow_endpoints terminal 2: ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function_with_unique_network_flow_endpoints see the unique network flows design document for further reference. rosbag2 new features ï split recording by time ï in foxy, you could only split bags as they were recording by the size of the bag, now you can also split by the elapsed time. the following command will split bagfiles into 100-second chunks. ros2 bag record --all --max-bag-duration 100 ros2 bag list ï this new command lists installed plugins of various types that rosbag2 uses.  ros2 bag list storage rosbag2_v2 sqlite3  ros2 bag list converter rosbag_v2_converter compression implementation is a plugin ï in foxy, rosbag2 compression was hardcoded with a zstd library implementation. this has been rearchitected so that compression implementations are a plugin, and can be swapped out without modifying the core rosbag2 codebase. the default plugin that ships with ros-galactic-rosbag2 is still the zstd plugin - but now more can be released and used, and by selectively installing packages zstd could be excluded from an installation. compress per-message ï in foxy, you could automatically compress each rosbag file as it was split (per-file compression), but now you can also specify per-message compression. ros2 bag record --all --compression-format zstd --compression-mode message rosbag2 python api ï a new package rosbag2_py has been released in galactic, which provides a python api. this package is a pybind11 binding around the c++ api. as of the initial galactic release, it does not yet expose all functionality available via the rosbag2_cpp api, but it is the sole connection for the ros2 bag cli tool, so a good deal of functionality is available. performance testing package and performance improvements ï a thorough performance analysis project was performed on rosbag2 since the foxy release. the full initial report is available at https://github.com/ros2/rosbag2/blob/galactic/rosbag2_performance/rosbag2_performance_benchmarking/docs/rosbag2_performance_improvements.pdf . the package rosbag2_performance_benchmarking provides tools to run performance analyses, especially on recording, which helps us maintain and improve the performance of rosbag2. following this report, key work was done do improve the performance to a much more usable state for actual robot workflows. to highlight a key metric - in a high bandwidth stress test (200mbps), the foxy release dropped up to 70% of messages, whereas the galactic version was approximately 100% retention.  see the linked report for more details. --regex and --exclude options for topic selection ï the new recording options --regex and --exclude allow for fine-tuning the topics recorded in a bag, without having to explicitly list all topics. these options may be used together or separately, and in conjunction with --all the following command will record only topics with âscanâ in the name. ros2 bag record --regex "*scan*" the following command will record all topics except for ones in /my_namespace/ ros2 bag record --all --exclude "/my_namespace/*" ros2 bag reindex ï ros 2 bags are represented by a directory, instead of a single file. this directory contains a metadata.yaml file, and one or more bag files. when the metadata.yaml file is lost or missing, ros2 bag reindex bag_dir will attempt to reconstruct it by reading all the bag files in the directory. playback time control ï new controls have been added for rosbag2 playback - pause & resume, change rate, and play-next. as of the galactic release, these controls are exposed only as services on the rosbag2 player node. development is in progress to expose them to keyboard controls as well in ros2 bag play , but until then a user application with buttons or keyboard controls may be trivially implemented to call these services. # in one shell  ros2 bag play my_bag # in another shell  ros2 service list -t /rosbag2_player/get_rate [ rosbag2_interfaces/srv/getrate ] /rosbag2_player/is_paused [ rosbag2_interfaces/srv/ispaused ] /rosbag2_player/pause [ rosbag2_interfaces/srv/pause ] /rosbag2_player/play_next [ rosbag2_interfaces/srv/playnext ] /rosbag2_player/resume [ rosbag2_interfaces/srv/resume ] /rosbag2_player/set_rate [ rosbag2_interfaces/srv/setrate ] /rosbag2_player/toggle_paused [ rosbag2_interfaces/srv/togglepaused ] # check if playback is paused  ros2 service call /rosbag2_player/is_paused rosbag2_interfaces/ispaused # pause playback  ros2 service call /rosbag2_player/pause rosbag2_interfaces/pause # resume playback  ros2 service call /rosbag2_player/resume rosbag2_interfaces/resume # change the paused state of playback to its opposite. if playing, pauses. if paused, resumes.  ros2 service call /rosbag2_player/toggle_paused rosbag2_interfaces/togglepaused # get the current playback rate  ros2 service call /rosbag2_player/get_rate # set the current playback rate (must be > 0)  ros2 service call /rosbag2_player/set_rate rosbag2_interfaces/setrate "rate: 0.1" # play a single next message (only works while paused)  ros2 service call /rosbag2_player/play_next rosbag2_interfaces/playnext playback publishes /clock ï rosbag2 can also dictate âsimulation timeâ by publishing to the /clock topic during playback. the following commands will publish the clock message at a regular interval. # publish at default rate - 40hz ros2 bag play my_bag --clock # publish at specific rate - 100hz ros2 bag play my_bag --clock 100 changes since the foxy release ï default rmw changed to eclipse cyclone dds ï during the galactic development process, the ros 2 technical steering committee voted to change the default ros middleware (rmw) to eclipse cyclone dds project of eclipse foundation . without any configuration changes, users will get eclipse cyclone dds by default. fast dds and connext are still tier-1 supported rmw vendors, and users can opt-in to use one of these rmws at their discretion by using the rmw_implementation environment variable. see the working with multiple rmw implementations guide for more information. connext rmw changed to rmw_connextdds ï a new rmw for connext called rmw_connextdds was merged for galactic. this rmw has better performance and fixes many of the issues with the older rmw rmw_connext_cpp . large improvements in testing and overall quality ï galactic contains many changes that fix race conditions, plug memory leaks, and fix user reported problems. besides these changes, there was a concerted effort during galactic development to improve overall quality of the system by implementing rep 2004 . the rclcpp package and all of its dependencies (which include most of the ros 2 non-python core packages) were brought up to quality level 1 by: having a version policy (ql1 requirement 1) having a documented change control process (ql1 requirement 2) documenting all features and public apis (ql1 requirement 3) adding many additional tests (ql1 requirement 4): system tests for all features unit tests for all public apis nightly performance tests code coverage at 95% having all runtime dependencies of packages be at least as high as the package (ql1 requirement 5) supporting all of the rep-2000 platforms (ql1 requirement 6) having a vulnerability disclosure policy (ql1 requirement 7) rmw ï new api for checking qos profile compatibility ï rmw_qos_profile_check_compatible is a new function for checking the compatibility of two qos profiles. rmw vendors should implement this api for qos debugging and introspection features in tools such as rqt_graph to work correctly. related pr: ros2/rmw#299 ament_cmake ï ament_install_python_package() now installs a python egg ï by installing a flat python egg, python packages installed using ament_install_python_package() can be discovered using modules such as pkg_resources and `importlib.metadata . also, additional metadata can be provided in a setup.cfg file (including entry points). related pr: ament/ament_cmake#326 ament_target_dependencies() handles system dependencies ï some package dependencies can now be marked as system dependencies, helping to cope with warnings in external code. typically, system dependencies are also excluded from dependency calculations â use them with care. related pr: ament/ament_cmake#297 nav2 ï changes include, but are not limited to, a number of stability improvements, new plugins, interface changes, costmap filters. see migration guides for full list tf2_ros python split out of tf2_ros ï the python code that used to live in tf2_ros has been moved into its own package named tf2_ros_py. any existing python code that depends on tf2_ros will continue to work, but the package.xml of those packages should be amended to exec_depend on tf2_ros_py. tf2_ros python transformlistener uses global namespace ï the python transformlistener now subscribes to /tf and /tf_static in the global namespace. previously, it was susbcribing in the nodeâs namespace. this means that the nodeâs namespace will no longer have an effect on the /tf and /tf_static s. for example: ros2 run tf2_ros tf2_echo --ros-args -r __ns: = /test -- odom base_link will subscribe to /tf and /tf_static , as ros2 topic list will show. related pr: ros2/geometry2#390 rclcpp ï change in spin_until_future_complete template parameters ï the first template parameter of executor::spin_until_future_complete was the future result type resultt , and the method only accepted a std::shared_future<resultt> . in order to accept other types of futures (e.g.: std::future ), that parameter was changed to the future type itself. in places where a spin_until_future_complete call was relying on template argument deduction, no change is needed. if not, this is an example diff: std::shared_future<myresultt> future; ... -executor.spin_until_future_complete<myresultt>(future); +executor.spin_until_future_complete<std::shared_future<myresultt>>(future); for more details, see ros2/rclcpp#1160 . for an example of the needed changes in user code, see ros-visualization/interactive_markers#72 . change in default /clock  qos profile ï the default was changed from a reliable communication with history depth 10 to a best effort communication with history depth 1. see ros2/rclcpp#1312 . waitable api ï waitable api was modified to avoid issues with the multithreadedexecutor . this only affects users implementing a custom waitable. see ros2/rclcpp#1241 for more details. change in rclcpp âs logging macros ï previously, the logging macros were vulnerable to a format string attack , where the format string is evaluated and can potentially execute code, read the stack, or cause a segmentation fault in the running program. to address this security issue, the logging macro now accepts only string literals for itâs format string argument. if you previously had code like: const char * my_const_char_string format = "foo" ; rclcpp_debug ( get_logger (), my_const_char_string ); you should now replace it with: const char * my_const_char_string format = "foo" ; rclcpp_debug ( get_logger (), " %s " , my_const_char_string ); or: rclcpp_debug ( get_logger (), "foo" ); this change removes some convenience from the logging macros, as std::string s are no longer accepted as the format argument. if you previously had code with no format arguments like: std :: string my_std_string = "foo" ; rclcpp_debug ( get_logger (), my_std_string ); you should now replace it with: std :: string my_std_string = "foo" ; rclcpp_debug ( get_logger (), " %s " , my_std_string . c_str ()); note if you are using a std::string as a format string with format arguments, converting that string to a char * and using it as the format string will yield a format security warning. thatâs because the compiler has no way at compile to introspect into the std::string to verify the arguments. to avoid the security warning, we recommend you build the string manually and pass it in with no format arguments like the previous example. std::stringstream types are still accepted as arguments to the stream logging macros. see ros2/rclcpp#1442 for more details. parameter types are now static by default ï previously, the type of a parameter could be changed when a parameter was set. for example, if a parameter was declared as an integer, a later call to set the parameter could change that type to a string. this behavior could lead to bugs, and is rarely what the user wants. as of galactic parameter types are static by default, and attempts to change the type will fail. if the previous dynamic behavior is desired, there is an mechanism to opt it in (see the code below). // declare integer parameter with default value, trying to set it to a different type will fail. node -> declare_parameter ( "my_int" , 5 ); // declare string parameter with no default and mandatory user provided override. // i.e. the user must pass a parameter file setting it or a command line rule -p <param_name>:=<value> node -> declare_parameter ( "string_mandatory_override" , rclcpp :: parameter_string ); // conditionally declare a floating point parameter with a mandatory override. // useful when the parameter is only needed depending on other conditions and no default is reasonable. if ( mode == "modea" ) { node -> declare_parameter ( "conditionally_declare_double_parameter" , rclcpp :: parameter_double ); } // you can also get the old dynamic typing behavior if you want: rcl_interfaces :: msg :: parameterdescriptor descriptor ; descriptor . dynamic_typing = true ; node -> declare_parameter ( "dynamically_typed_param" , rclcpp :: parametervalue {}, descriptor ); for more details see https://github.com/ros2/rclcpp/blob/galactic/rclcpp/doc/notes_on_statically_typed_parameters.md . new api for checking qos profile compatibility ï qos_check_compatible is a new function for checking the compatibility of two qos profiles. related pr: ros2/rclcpp#1554 rclpy ï removal of deprecated node.set_parameters_callback ï the method node.set_parameters_callback was deprecated in ros foxy and has been removed in ros galactic . use node.add_on_set_parameters_callback() instead. here is some example code using it. import rclpy import rclpy.node from rcl_interfaces.msg import parametertype from rcl_interfaces.msg import setparametersresult rclpy . init () node = rclpy . node . node ( 'callback_example' ) node . declare_parameter ( 'my_param' , 'initial value' ) def on_parameter_event ( parameter_list ): for parameter in parameter_list : node . get_logger () . info ( f 'got { parameter . name } = { parameter . value } ' ) return setparametersresult ( successful = true ) node . add_on_set_parameters_callback ( on_parameter_event ) rclpy . spin ( node ) run this command to see the parameter callback in action. ros2 param set / callback_example my_param "hello world" parameter types are now static by default ï in foxy and earlier a call to set a parameter could change its type. as of galactic parameter types are static and cannot be changed by default. if the previous behavior is desired, then set dynamic_typing to true in the parameter descriptor. here is an example. import rclpy import rclpy.node from rcl_interfaces.msg import parameterdescriptor rclpy . init () node = rclpy . node . node ( 'static_param_example' ) node . declare_parameter ( 'static_param' , 'initial value' ) node . declare_parameter ( 'dynamic_param' , 'initial value' , descriptor = parameterdescriptor ( dynamic_typing = true )) rclpy . spin ( node ) run these commands to see how statically and dynamically typed parameters are different.  ros2 param set /static_param_example dynamic_param 42 set parameter successful  ros2 param set /static_param_example static_param 42 setting parameter failed: wrong parameter type, expected 'type.string' got 'type.integer' for more details see https://github.com/ros2/rclcpp/blob/galactic/rclcpp/doc/notes_on_statically_typed_parameters.md . new api for checking qos profile compatibility ï rclpy.qos.qos_check_compatible is a new function for checking the compatibility of two qos profiles. if the profiles are compatible, then a publisher and subscriber using them will be able to talk to each other. import rclpy.qos publisher_profile = rclpy . qos . qos_profile_sensor_data _profile = rclpy . qos . qos_profile_parameter_events print ( rclpy . qos . qos_check_compatible ( publisher_profile , _profile ))  python3 qos_check_compatible_example.py (qoscompatibility.error, 'error: best effort publisher and reliable ;') rclcpp_action ï action client goal response callback signature changed ï the goal response callback should now take a shared pointer to a goal handle, instead of a future. for example , old signature: void goal_response_callback ( std :: shared_future < goalhandlefibonacci :: sharedptr > future ) new signature: void goal_response_callback ( goalhandlefibonacci :: sharedptr goal_handle ) related pr: ros2/rclcpp#1311 rosidl_typesupport_introspection_c ï api break in function that gets an element from an array ï the signature of the function was changed because it was semantically different to all the other functions used to get an element from an array or sequence. this only affects authors of rmw implementations using the introspection typesupport. for further details, see ros2/rosidl#531 . rcl_lifecycle and rclcpp_lifecycle ï rclâs lifecycle state machine gets new init api ï the lifecycle state machine in rcl_lifecycle was modified to expect a newly introduced options struct, combining general configurations for the state machine. the option struct allows to indicate whether the state machine shall be initialized with default values, whether its attached services are active and which allocator to be used. rcl_ret_t rcl_lifecycle_state_machine_init ( rcl_lifecycle_state_machine_t * state_machine , rcl_node_t * node_handle , const rosidl_message_type_support_t * ts_pub_notify , const rosidl_service_type_support_t * ts_srv_change_state , const rosidl_service_type_support_t * ts_srv_get_state , const rosidl_service_type_support_t * ts_srv_get_available_states , const rosidl_service_type_support_t * ts_srv_get_available_transitions , const rosidl_service_type_support_t * ts_srv_get_transition_graph , const rcl_lifecycle_state_machine_options_t * state_machine_options ); rclâs lifecycle state machine stores allocator instance ï the options struct (discussed above) entails an instance of the allocator being used for initializing the state machine. this options struct and there the embodied allocator are being stored within the lifecycle state machine. as a direct consequence, the rcl_lifecycle_fini function no longer expects an allocator in its fini function but rather uses the allocator set in the options struct for deallocating its internal data structures. rcl_ret_t rcl_lifecycle_state_machine_fini ( rcl_lifecycle_state_machine_t * state_machine , rcl_node_t * node_handle ); rclcppâs lifecycle node exposes option to not instantiate services ï in order to use rclcppâs lifecycle nodes without exposing its internal services such as change_state , get_state et. al., the constructor of a lifecycle node has a newly introduced parameter indicating whether or not the services shall be available. this boolean flag is set to true by default, not requiring any changes to existing api if not wished. explicit lifecyclenode ( const std :: string & node_name , const rclcpp :: nodeoptions & options = rclcpp :: nodeoptions (), bool enable_communication_interface = true ); related prs: ros2/rcl#882 and ros2/rclcpp#1507 rcl_lifecycle and rclcpp_lifecycle ï recording - split by time ï known issues ï ros2cli ï daemon slows down cli on windows ï as a workaround, cli commands may be used without a daemon e.g.: ros2 topic list --no-daemon issue is tracked by ros2/ros2cli#637 . rqt ï some rqt_bag icons are missing ï the icons to âzoom inâ, âzoom outâ, âzoom homeâ, and âtoggle thumbnailsâ are missing in rqt_bag . the issue is tracked in ros-visualization/rqt_bag#102 most rqt utilities donât work standalone on windows ï launching the rqt utilities âstandaloneâ on windows (like ros2 run rqt_graph rqt_graph ) generally doesnât work. the workaround is to launch the rqt container process ( rqt ), and then insert the plugins to be used. rviz2 ï rviz2 panel close buttons are blank ï the upper right-hand corner of every rviz2 panel should contain an âxâ to allow one to close the panel. those buttons are there, but the âxâ inside of them is missing on all platforms. the issue is being tracked in ros2/rviz2#692 . timeline before the release ï mon. march 22, 2021 - alpha preliminary testing and stabilization of ros core [ 1 ] packages. mon. april 5, 2021 - freeze api and feature freeze for ros core [ 1 ] packages in rolling ridley. note that this includes rmw , which is a recursive dependency of ros_core . only bug fix releases should be made after this point. new packages can be released independently. mon. april 19, 2021 - branch branch from rolling ridley. rosdistro is reopened for rolling prs for ros core [ 1 ] packages. galactic development shifts from ros-rolling-* packages to ros-galactic-* packages. mon. april 26, 2021 - beta updated releases of ros desktop [ 2 ] packages available. call for general testing. mon. may 17, 2021 - rc release candidate packages are built. updated releases of ros desktop [ 2 ] packages available. thu. may 20, 2021 - distro freeze freeze rosdistro. no prs for galactic on the rosdistro repo will be merged (reopens after the release announcement). sun. may 23, 2021 - general availability release announcement. rosdistro is reopened for galactic prs. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling