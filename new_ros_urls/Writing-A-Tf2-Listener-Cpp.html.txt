tutorials intermediate tf2 writing a listener (c++) edit on github writing a listener (c++) ï goal: learn how to use tf2 to get access to frame transformations. tutorial level: intermediate time: 10 minutes background ï in previous tutorials we created a tf2 broadcaster to publish the pose of a turtle to tf2. in this tutorial weâll create a tf2 listener to start using tf2. prerequisites ï this tutorial assumes you have completed the tf2 static broadcaster tutorial (c++) and the tf2 broadcaster tutorial (c++) . in the previous tutorial, we created a learning_tf2_cpp package, which is where we will continue working from. tasks ï 1 write the listener node ï letâs first create the source files. go to the learning_tf2_cpp package we created in the previous tutorial. inside the src directory download the example listener code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp -o turtle_tf2_listener.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp -o turtle_tf2_listener.cpp open the file using your preferred text editor. #include <chrono> #include <functional> #include <memory> #include <string> #include "geometry_msgs/msg/transform_stamped.hpp" #include "geometry_msgs/msg/twist.hpp" #include "rclcpp/rclcpp.hpp" #include "tf2/exceptions.h" #include "tf2_ros/transform_listener.h" #include "tf2_ros/buffer.h" #include "turtlesim/srv/spawn.hpp" using namespace std :: chrono_literals ; class framelistener : public rclcpp :: node { public : framelistener () : node ( "turtle_tf2_frame_listener" ), turtle_spawning_service_ready_ ( false ), turtle_spawned_ ( false ) { // declare and acquire `target_frame` parameter target_frame_ = this -> declare_parameter < std :: string > ( "target_frame" , "turtle1" ); tf_buffer_ = std :: make_unique < tf2_ros :: buffer > ( this -> get_clock ()); tf_listener_ = std :: make_shared < tf2_ros :: transformlistener > ( * tf_buffer_ ); // create a client to spawn a turtle spawner_ = this -> create_client < turtlesim :: srv :: spawn > ( "spawn" ); // create turtle2 velocity publisher publisher_ = this -> create_publisher < geometry_msgs :: msg :: twist > ( "turtle2/cmd_vel" , 1 ); // call on_timer function every second timer_ = this -> create_wall_timer ( 1 s , [ this ]() { return this -> on_timer ();}); } private : void on_timer () { // store frame names in variables that will be used to // compute transformations std :: string fromframerel = target_frame_ . c_str (); std :: string toframerel = "turtle2" ; if ( turtle_spawning_service_ready_ ) { if ( turtle_spawned_ ) { geometry_msgs :: msg :: transformstamped t ; // look up for the transformation between target_frame and turtle2 frames // and send velocity commands for turtle2 to reach target_frame try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , tf2 :: timepointzero ); } catch ( const tf2 :: transformexception & ex ) { rclcpp_info ( this -> get_logger (), "could not transform %s to %s: %s" , toframerel . c_str (), fromframerel . c_str (), ex . what ()); return ; } geometry_msgs :: msg :: twist msg ; static const double scalerotationrate = 1.0 ; msg . angular . z = scalerotationrate * atan2 ( t . transform . translation . y , t . transform . translation . x ); static const double scaleforwardspeed = 0.5 ; msg . linear . x = scaleforwardspeed * sqrt ( pow ( t . transform . translation . x , 2 ) + pow ( t . transform . translation . y , 2 )); publisher_ -> publish ( msg ); } else { rclcpp_info ( this -> get_logger (), "successfully spawned" ); turtle_spawned_ = true ; } } else { // check if the service is ready if ( spawner_ -> service_is_ready ()) { // initialize request with turtle name and coordinates // note that x, y and theta are defined as floats in turtlesim/srv/spawn auto request = std :: make_shared < turtlesim :: srv :: spawn :: request > (); request -> x = 4.0 ; request -> y = 2.0 ; request -> theta = 0.0 ; request -> name = "turtle2" ; // call request using serviceresponsefuture = rclcpp :: client < turtlesim :: srv :: spawn >:: sharedfuture ; auto response_received_callback = [ this ]( serviceresponsefuture future ) { auto result = future . get (); if ( strcmp ( result -> name . c_str (), "turtle2" ) == 0 ) { turtle_spawning_service_ready_ = true ; } else { rclcpp_error ( this -> get_logger (), "service callback result mismatch" ); } }; auto result = spawner_ -> async_send_request ( request , response_received_callback ); } else { rclcpp_info ( this -> get_logger (), "service is not ready" ); } } } // boolean values to store the information // if the service for spawning turtle is available bool turtle_spawning_service_ready_ ; // if the turtle was successfully spawned bool turtle_spawned_ ; rclcpp :: client < turtlesim :: srv :: spawn >:: sharedptr spawner_ { nullptr }; rclcpp :: timerbase :: sharedptr timer_ { nullptr }; rclcpp :: publisher < geometry_msgs :: msg :: twist >:: sharedptr publisher_ { nullptr }; std :: shared_ptr < tf2_ros :: transformlistener > tf_listener_ { nullptr }; std :: unique_ptr < tf2_ros :: buffer > tf_buffer_ ; std :: string target_frame_ ; }; int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < framelistener > ()); rclcpp :: shutdown (); return 0 ; } 1.1 examine the code ï to understand how the service behind spawning turtle works,  refer to writing a simple service and client (c++) tutorial. now, letâs take a look at the code that is relevant to get access to frame transformations. the tf2_ros contains a transformlistener class that makes the task of receiving transforms easier. #include "tf2_ros/transform_listener.h" here, we create a transformlistener object. once the listener is created, it starts receiving tf2 transformations over the wire, and buffers them for up to 10 seconds. tf_listener_ = std :: make_shared < tf2_ros :: transformlistener > ( * tf_buffer_ ); finally, we query the listener for a specific transformation. we call lookup_transform method with following arguments: target frame source frame the time at which we want to transform providing tf2::timepointzero will just get us the latest available transform. all this is wrapped in a try-catch block to handle possible exceptions. t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , tf2 :: timepointzero ); the resulting transformation represents the position and orientation of the target turtle relative to turtle2 . the angle between the turtles is then used to calculate a velocity command to follow the target turtle. for more general information  tf2 see also the tf2 page in the concepts section . 1.2 cmakelists.txt ï navigate one level back to the learning_tf2_cpp directory, where the cmakelists.txt and package.xml files are located. now open the cmakelists.txt add the executable and name it turtle_tf2_listener , which youâll use later with ros2 run . add_executable(turtle_tf2_listener src/turtle_tf2_listener.cpp) ament_target_dependencies( turtle_tf2_listener geometry_msgs rclcpp tf2 tf2_ros turtlesim ) finally, add the install(targetsâ) section so ros2 run can find your executable: install(targets turtle_tf2_listener destination lib/{project_name}) 2 update the launch file ï open the launch file called turtle_tf2_demo_launch.py in the src/learning_tf2_cpp/launch directory with your text editor, add two new nodes to the launch description, add a launch argument, and add the imports. the resulting file should look like: from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import launchconfiguration from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), declarelaunchargument ( 'target_frame' , default_value = 'turtle1' , description = 'target frame name.' ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster2' , parameters = [ { 'turtlename' : 'turtle2' } ] ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_listener' , name = 'listener' , parameters = [ { 'target_frame' : launchconfiguration ( 'target_frame' )} ] ), ]) this will declare a target_frame launch argument, start a broadcaster for the second turtle that we will spawn and a listener that will subscribe to those transformations. 3 build ï run rosdep in the root of your workspace to check for missing dependencies. linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your package: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 4 run ï now youâre ready to start your full turtle demo: ros2 launch learning_tf2_cpp turtle_tf2_demo_launch.py you should see the turtle sim with two turtles. in the second terminal window type the following command: ros2 run turtlesim turtle_teleop_key to see if things work, simply drive around the first turtle using the arrow keys (make sure your terminal window is active, not your simulator window), and youâll see the second turtle following the first one! summary ï in this tutorial you learned how to use tf2 to get access to frame transformations. you also have finished writing your own turtlesim demo that you first tried in introduction to tf2 tutorial. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling