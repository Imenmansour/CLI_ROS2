tutorials advanced using fast dds discovery server as discovery protocol [community-contributed] edit on github using fast dds discovery server as discovery protocol [community-contributed] ï goal: this tutorial will show how to launch ros 2 nodes using the fast dds discovery server discovery protocol. tutorial level: advanced time: 20 minutes background ï starting from ros 2 eloquent elusor, the fast dds discovery server protocol is a feature that offers a centralized dynamic discovery mechanism, as opposed to the distributed mechanism used in dds by default. this tutorial explains how to run some ros 2 examples using the fast dds discovery server feature as discovery communication. in order to get more information  the available discovery configuration,  check the following documentation or read the fast dds discovery server specific documentation . the simple discovery protocol is the standard protocol defined in the dds standard . however, it has known disadvantages in some scenarios. it does not scale efficiently, as the number of exchanged packets increases significantly as new nodes are added. it requires multicasting capabilities that may not work reliably in some scenarios, e.g. wifi. the fast dds discovery server provides a client-server architecture that allows nodes to connect with each other using an intermediate server. each node functions as a discovery client , sharing its info with one or more discovery servers and receiving discovery information from it. this reduces discovery-related network traffic and it does not require multicasting capabilities. these discovery servers can be independent, duplicated or connected with each other in order to create redundancy over the network and avoid having a single point of failure. fast dds discovery server v2 ï the latest ros 2 foxy fitzroy release (december 2020) included a new version, version 2 of the fast dds discovery server. this version includes a new filter feature that further reduces the number of discovery messages sent. this version uses the topic of the different nodes to decide if two nodes wish to communicate, or if they can be left unmatched (i.e. not discovering each other). the following figure shows the decrease in discovery messages: this architecture reduces the number of messages sent between the server and clients dramatically. in the following graph, the reduction in network traffic over the discovery phase for the rmf clinic demonstration is shown: in order to use this functionality, the discovery server can be configured using the xml configuration for participants . it is also possible to configure the discovery server using the fastdds tool and an environment variable , which is the approach used in this tutorial. for a more detailed explanation  the configuration of the discovery server, visit the fast dds discovery server documentation . prerequisites ï this tutorial assumes you have a ros 2 foxy (or newer) installation . if your installation is using a ros 2 version lower than foxy, you cannot use the fastdds tool. thus, in order to use the discovery server, you can update your repository to use a different fast dds version, or configure the discovery server using the fast dds xml qos configuration . run this tutorial ï the talker-listener ros 2 demo creates a talker node that publishes a âhello worldâ message every second, and a listener node that listens to these messages. by sourcing ros 2 you will get access to the cli tool fastdds . this tool gives access to the discovery tool , which can be used to launch a discovery server. this server will manage the discovery process for the nodes that connect to it. important do not forget to source ros 2 in every new terminal opened. setup discovery server ï start by launching a discovery server with id 0, port 11811 (default port) and listening on all available interfaces. open a new terminal and run: fastdds discovery --server-id 0 launch listener node ï execute the listener demo, to listen to the /chatter topic. in a new terminal, set the environment variable ros_discovery_server to the location of the discovery server. (do not forget to source ros 2 in every new terminal) linux windows export ros_discovery_server=127.0.0.1:11811 set ros_discovery_server=127.0.0.1:11811 launch the listener node. use the argument --remap __node:=listener_discovery_server to change the nodeâs name for this tutorial. ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_discovery_server this will create a ros 2 node, that will automatically create a client for the discovery server and connect to the server created previously to perform discovery, rather than using multicast. launch talker node ï open a new terminal and set the ros_discovery_server environment variable as before so that the node starts a discovery client. linux windows export ros_discovery_server=127.0.0.1:11811 set ros_discovery_server=127.0.0.1:11811 ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_discovery_server you should now see the talker publishing âhello worldâ messages, and the listener receiving these messages. demonstrate discovery server execution ï so far, there is no evidence that this example and the standard talker-listener example are running differently. to clearly demonstrate this, run another node that is not connected to the discovery server. run a new listener (listening in /chatter topic by default) in a new terminal and check that it is not connected to the talker already running. ros2 run demo_nodes_cpp listener --ros-args --remap __node:=simple_listener the new listener node should not be receiving the âhello worldâ messages. to finally verify that everything is running correctly, a new talker can be created using the simple discovery protocol (the default dds distributed discovery mechanism) for discovery. ros2 run demo_nodes_cpp talker --ros-args --remap __node:=simple_talker now you should see the simple_listener node receiving the âhello worldâ messages from simple_talker but not the other messages from talker_discovery_server . visualization tool rqt_graph ï the rqt_graph tool can be used to verify the nodes and structure of this example. remember, in order to use rqt_graph with the discovery server protocol (i.e., to see the listener_discovery_server and talker_discovery_server nodes) the ros_discovery_server environment variable must be set before launching it. advance use cases ï the following sections show different features of the discovery server that allow you to build a robust discovery server over the network. server redundancy ï by using fastdds tool, multiple discovery servers can be created. discovery clients (ros nodes) can connect to as many servers as desired. this allows to have a redundant network that will work even if some servers or nodes shut down unexpectedly. the figure below shows a simple architecture that provides server redundancy. in several terminals, run the following code to establish a communication with redundant servers. fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811 fastdds discovery --server-id 1 --ip-address 127.0.0.1 --port 11888 --server-id n means server with id n. when referencing the servers with ros_discovery_server , server 0 must be in first place and server 1 in second place. linux windows export ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" set ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker linux windows export ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" set ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener now, if one of these servers fails, there will still be discovery capability available and nodes will still discover each other. backup server ï the fast dds discovery server allows creating a server with backup functionality. this allows the server to restore the last state it saved in case of a shutdown. in different terminals, run the following code to establish a communication with a backed-up server. fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811 --backup linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener several backup files are created in the discovery serverâs working directory (the directory it was launched in). the two sqlite files and two json files contain the information required to start a new server and restore the failed serverâs state in case of failure, avoiding the need for the discovery process to happen again, and without losing information. discovery partitions ï communication with discovery servers can be split to create virtual partitions in the discovery information. this means that two endpoints will only know  each other if there is a shared discovery server or a network of discovery servers between them. we are going to execute an example with two independent servers. the following figure shows the architecture. with this schema listener 1 will be connected to talker 1 and talker 2 , as they share server 1 . listener 2 will connect with talker 1 as they share server 2 . but listener 2 will not hear the messages from talker 2 because they do not share any discovery server or discovery servers, including indirectly via connections between redundant discovery servers. run the first server listening on localhost with the default port of 11811. fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811 in another terminal run the second server listening on localhost using another port, in this case port 11888. fastdds discovery --server-id 1 --ip-address 127.0.0.1 --port 11888 now, run each node in a different terminal. use ros_discovery_server environment variable to decide which server they are connected to. be aware that the ids must match . linux windows export ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" set ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_1 linux windows export ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" set ros_discovery_server="127.0.0.1:11811;127.0.0.1:11888" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_1 linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_2 linux windows export ros_discovery_server=";127.0.0.1:11888" set ros_discovery_server=";127.0.0.1:11888" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_2 we should see how listener 1 is receiving messages from both talker nodes, while listener 2 is in a different partition from talker 2 and so does not receive messages from it. note once two endpoints (ros nodes) have discovered each other, they do not need the discovery server network between them to listen to each otherâs messages. ros 2 introspection ï the ros 2 command line interface supports several introspection tools to analyze the behavior of a ros 2 network. these tools (i.e. ros2 bag record , ros2 topic list , etc.) are very helpful to understand a ros 2 working network. most of these tools use dds simple discovery to exchange topic information with every existing participant (using simple discovery, every participant in the network is connected with each other). however, the new discovery server v2 implements a network traffic reduction scheme that limits the discovery data between participants that do not share a topic. this means that nodes will only receive topicâs discovery data if it has a writer or a reader for that topic. as most ros 2 clis need a node in the network (some of them rely on a running ros 2 daemon, and some create their own nodes), using the discovery server v2 these nodes will not have all the network information, and thus their functionality will be limited. the discovery server v2 functionality allows every participant to run as a super client , a kind of client that connects to a server , from which it receives all the available discovery information (instead of just what it needs). in this sense, ros 2 introspection tools can be configured as super client , thus being able to discover every entity that is using the discovery server protocol within the network. note in this section we use the term participant as a dds entity. each dds participant corresponds with a ros 2 context , a ros 2 abstraction over dds. nodes are ros 2 entities that rely on dds communication interfaces: datawriter and datareader . each participant can hold multiple ros 2 nodes. for further details  these concepts,  visit the node to participant mapping design document daemonâs related tools ï the ros 2 daemon is used in several ros 2 cli introspection tools. it creates its own participant to add a ros 2 node to the network graph, in order to receive all the data sent. in order for the ros 2 cli to work when using discovery server mechanism, the ros 2 daemon needs to be configured as super client . therefore, this section is devoted to explain how to use ros 2 cli with ros 2 daemon running as a super client . this will allow the daemon to discover the entire node graph, and to receive all topic and endpoint information. to do so, a fast dds xml configuration file is used to configure the ros 2 daemon and cli tools. below you can find a xml configuration profile, which for this tutorial should be saved in the working directory as `super_client_configuration_file.xml` file. this file will configure every new participant using it, as a super client . <?xml version="1.0" encoding="utf-8" ?> <dds> <profiles xmlns= "http://www.eprosima.com/xmlschemas/fastrtps_profiles" > <participant profile_name= "super_client_profile" is_default_profile= "true" > <rtps> <builtin> <discovery_config> <discoveryprotocol> super_client </discoveryprotocol> <discoveryserverslist> <remoteserver prefix= "44.53.00.5f.45.50.52.4f.53.49.4d.41" > <metatrafficunicastlocatorlist> <locator> <udpv4> <address> 127.0.0.1 </address> <port> 11811 </port> </udpv4> </locator> </metatrafficunicastlocatorlist> </remoteserver> </discoveryserverslist> </discovery_config> </builtin> </rtps> </participant> </profiles> </dds> note under the remoteserver tag, the prefix attribute value should be updated according to the server id passed on the cli (see fast dds cli ). the value specified in the shown xml snippet corresponds to an id of value 0. first of all, instantiate a discovery server using fast dds cli specifying an id of value 0. fastdds discovery -i 0 -l 127.0.0.1 -p 11811 run a talker and a listener that will discover each other through the server (notice that ros_discovery_server configuration is the same as the one in super_client_configuration_file.xml ). linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker then, instantiate a ros 2 daemon using the super client configuration (remember to source ros 2 installation in every new terminal). linux windows export fastrtps_default_profiles_file=super_client_configuration_file.xml set fastrtps_default_profiles_file=super_client_configuration_file.xml ros2 daemon stop ros2 daemon start ros2 topic list ros2 node info /talker ros2 topic info /chatter ros2 topic echo /chatter we can also see the nodeâs graph using the ros 2 tool rqt_graph as follows (you may need to press the refresh button): linux windows export fastrtps_default_profiles_file=super_client_configuration_file.xml set fastrtps_default_profiles_file=super_client_configuration_file.xml rqt_graph no daemon tools ï some ros 2 cli tools do not use the ros 2 daemon. in order for these tools to connect with a discovery server and receive all the topics information they need to be instantiated as a super client that connects to the server . following the previous configuration, build a simple system with a talker and a listener. first, run a server : fastdds discovery -i 0 -l 127.0.0.1 -p 11811 then, run the talker and listener in separate terminals: linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener linux windows export ros_discovery_server="127.0.0.1:11811" set ros_discovery_server="127.0.0.1:11811" ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker continue using the ros 2 cli with --no-daemon option with the new configuration. new nodes will connect with the existing server and will know every topic. exporting ros_discovery_server is not needed as the ros 2 tools will be configured through the fastrtps_default_profiles_file . linux windows export fastrtps_default_profiles_file=super_client_configuration_file.xml set fastrtps_default_profiles_file=super_client_configuration_file.xml ros2 topic list --no-daemon ros2 node info /talker --no-daemon --spin-time 2 compare fast dds discovery server with simple discovery protocol ï in order to compare executing nodes using the simple discovery protocol (the default dds mechanism for distributed discovery) or the discovery server , two scripts that execute a talker and many listeners and analyze the network traffic during this time are provided. for this experiment, tshark is required to be installed on your system. the configuration file is mandatory in order to avoid using intraprocess mode. note these scripts are only supported on linux, and require a discovery server closure feature that is only available from versions newer than the version provided in ros 2 foxy. in order to use this functionality, compile ros 2 with fast dds v2.1.0 or higher. these scriptsâ features are references for advanced purposes and their study is left to the user. bash network traffic generator python3 graph generator xml configuration run the bash script with the path to setup.bash file to source ros 2 as an argument. this will generate the traffic trace for simple discovery. execute the same script with second argument server . it will generate the trace for using the discovery server. note depending on your configuration of tcpdump , this script may require sudo privileges to read traffic across your network device. after both executions are done, run the python script to generate a graph similar to the one below.  export fastrtps_default_profiles_file = "no_intraprocess_configuration.xml"  sudo bash generate_discovery_packages.bash ~/ros2/install/local_setup.bash  sudo bash generate_discovery_packages.bash ~/ros2/install/local_setup.bash server  python3 discovery_packets.py this graph is the result of a specific run of the experiment. the reader can execute the scripts and generate their own results for comparison. it can easily be seen that network traffic is reduced when using discovery service. the reduction in traffic is a result of avoiding every node announcing itself and waiting a response from every other node on the network. this creates a huge amount of traffic in large architectures. the reduction from this method increases with the number of nodes, making this architecture more scalable than the simple discovery protocol approach. the new fast dds discovery server v2 is available since fast dds v2.0.2, replacing the old discovery server. in this new version, those nodes that do not share topics will automatically not discover each other, saving the whole discovery data required to connect them and their endpoints. the experiment above does not show this case, but even so the massive reduction in traffic can be appreciated due to the hidden infrastructure topics of ros 2 nodes. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling