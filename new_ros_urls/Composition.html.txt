tutorials intermediate composing multiple nodes in a single process edit on github composing multiple nodes in a single process ï goal: compose multiple nodes into a single process. tutorial level: intermediate time: 20 minutes background ï see the conceptual article . for information on how to write a composable node, check out this tutorial . prerequisites ï this tutorial uses executables from the rclcpp_components , ros2component , composition , and image_tools packages. if youâve followed the installation instructions for your platform, these should already be installed. run the demos ï discover available components ï to see what components are registered and available in the workspace, execute the following in a shell: ros2 component types the terminal will return the list of all available components: ( ... components of other packages here ) composition composition::talker composition::listener composition::nodelikelistener composition::server composition::client ( ... components of other packages here ) run-time composition using ros services with a publisher and subscriber ï in the first shell, start the component container: ros2 run rclcpp_components component_container open the second shell and verify that the container is running via ros2 command line tools: ros2 component list you should see a name of the component: /componentmanager in the second shell load the talker component (see talker source code): ros2 component load /componentmanager composition composition::talker the command will return the unique id of the loaded component as well as the node name: loaded component 1 into '/componentmanager' container node as '/talker' now the first shell should show a message that the component was loaded as well as repeated message for publishing a message. run another command in the second shell to load the listener component (see listener source code): ros2 component load /componentmanager composition composition::listener terminal will return: loaded component 2 into '/componentmanager' container node as '/listener' the ros2 command line utility can now be used to inspect the state of the container: ros2 component list you will see the following result: /componentmanager 1 /talker 2 /listener now the first shell should show repeated output for each received message. run-time composition using ros services with a server and client ï the example with a server and a client is very similar. in the first shell: ros2 run rclcpp_components component_container in the second shell (see server and client source code): ros2 component load /componentmanager composition composition::server ros2 component load /componentmanager composition composition::client in this case the client sends a request to the server, the server processes the request and replies with a response, and the client prints the received response. compile-time composition with hardcoded nodes ï this demo shows that the same shared libraries can be reused to compile a single executable running multiple components without using ros interfaces. the executable contains all four components from above: talker and listener as well as server and client, which is hardcoded in the main function. in the shell call (see source code ): ros2 run composition manual_composition this should show repeated messages from both pairs, the talker and the listener as well as the server and the client. note manually-composed components will not be reflected in the ros2 component list command line tool output. run-time composition using dlopen ï this demo presents an alternative to run-time composition by creating a generic container process and explicitly passing the libraries to load without using ros interfaces. the process will open each library and create one instance of each ârclcpp::nodeâ class in the library ( source code ). linux macos windows ros2 run composition dlopen_composition ` ros2 pkg prefix composition ` /lib/libtalker_component.so ` ros2 pkg prefix composition ` /lib/liblistener_component.so ros2 run composition dlopen_composition ` ros2 pkg prefix composition ` /lib/libtalker_component.dylib ` ros2 pkg prefix composition ` /lib/liblistener_component.dylib > ros2 pkg prefix composition to get the path to where composition is installed. then call > ros2 run composition dlopen_composition <path_to_composition_install> \b in \t alker_component.dll <path_to_composition_install> \b in \l istener_component.dll now the shell should show repeated output for each sent and received message. note dlopen-composed components will not be reflected in the ros2 component list command line tool output. composition using launch actions ï while the command line tools are useful for debugging and diagnosing component configurations, it is frequently more convenient to start a set of components at the same time. to automate this action, we can use a launch file : ros2 launch composition composition_demo_launch.py advanced topics ï now that we have seen the basic operation of components, we can discuss a few more advanced topics. unloading components ï in the first shell, start the component container: ros2 run rclcpp_components component_container verify that the container is running via ros2 command line tools: ros2 component list you should see a name of the component: /componentmanager in the second shell load both the talker and listener as we have before: ros2 component load /componentmanager composition composition::talker ros2 component load /componentmanager composition composition::listener use the unique id to unload the node from the component container. ros2 component unload /componentmanager 1 2 the terminal should return: unloaded component 1 from '/componentmanager' container unloaded component 2 from '/componentmanager' container in the first shell, verify that the repeated messages from talker and listener have stopped. remapping container name and namespace ï the component manager name and namespace can be remapped via standard command line arguments: ros2 run rclcpp_components component_container --ros-args -r __node: = mycontainer -r __ns: = /ns in a second shell, components can be loaded by using the updated container name: ros2 component load /ns/mycontainer composition composition::listener note namespace remappings of the container do not affect loaded components. remap component names and namespaces ï component names and namespaces may be adjusted via arguments to the load command. in the first shell, start the component container: ros2 run rclcpp_components component_container some examples of how to remap names and namespaces. remap node name: ros2 component load /componentmanager composition composition::talker --node-name talker2 remap namespace: ros2 component load /componentmanager composition composition::talker --node-namespace /ns remap both: ros2 component load /componentmanager composition composition::talker --node-name talker3 --node-namespace /ns2 now use ros2 command line utility: ros2 component list in the console you should see corresponding entries: /componentmanager 1 /talker2 2 /ns/talker 3 /ns2/talker3 note namespace remappings of the container do not affect loaded components. passing parameter values into components ï the ros2 component load command-line supports passing arbitrary parameters to the node as it is constructed. this functionality can be used as follows: ros2 component load /componentmanager image_tools image_tools::cam2image -p burger_mode: = true passing additional arguments into components ï the ros2 component load command-line supports passing particular options to the component manager for use when constructing the node. as of now, the only command-line option that is supported is to instantiate a node using intra-process communication. this functionality can be used as follows: ros2 component load /componentmanager composition composition::talker -e use_intra_process_comms: = true composable nodes as shared libraries ï if you want to export a composable node as a shared library from a package and use that node in another package that does link-time composition, add code to the cmake file which imports the actual targets in downstream packages. then install the generated file and export the generated file. a practical example can be seen here: ros discourse - ament best practice for sharing libraries composing non-node derived components ï in ros 2, components allow for more efficient use of system resources and provide a powerful feature that enables you to create reusable functionality that is not tied to a specific node. one advantage of using components is that they allow you to create non-node derived functionality as standalone executables or shared libraries that can be loaded into the ros system as needed. to create a component that is not derived from a node, follow these guidelines: implement a constructor that takes const rclcpp::nodeoptions& as its argument. implement the get_node_base_interface() method, which should return a nodebaseinterface::sharedptr . you can use the get_node_base_interface() method of a node that you create in your constructor to provide this interface. hereâs an example of a component that is not derived from a node, which listens to a ros topic: node_like_listener_component . for more information on this topic, you can refer to this discussion . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling