tutorials intermediate writing an action server and client (c++) edit on github writing an action server and client (c++) ï goal: implement an action server and client in c++. tutorial level: intermediate time: 15 minutes background ï actions are a form of asynchronous communication in ros. action clients send goal requests to action servers . action servers send goal feedback and results to action clients . prerequisites ï you will need the custom_action_interfaces package and the fibonacci.action interface defined in the previous tutorial, creating an action . tasks ï 1 creating the custom_action_cpp package ï as we saw in the creating a package tutorial, we need to create a new package to hold our c++ and supporting code. 1.1 creating the custom_action_cpp package ï go into the action workspace you created in the previous tutorial (remember to source the workspace), and create a new package for the c++ action server: linux macos windows cd ~/ros2_ws/src ros2 pkg create --dependencies custom_action_interfaces rclcpp rclcpp_action rclcpp_components --license apache-2.0 -- custom_action_cpp cd ~/ros2_ws/src ros2 pkg create --dependencies custom_action_interfaces rclcpp rclcpp_action rclcpp_components --license apache-2.0 -- custom_action_cpp cd \r os2_ws \s rc ros2 pkg create --dependencies custom_action_interfaces rclcpp rclcpp_action rclcpp_components --license apache-2.0 -- custom_action_cpp 1.2 adding in visibility control ï in order to make the package compile and work on windows, we need to add in some âvisibility controlâ. for more details, see windows symbol visibility in the windows tips and tricks document . open up custom_action_cpp/include/custom_action_cpp/visibility_control.h , and put the following code in: #ifndef custom_action_cpp__visibility_control_h_ #define custom_action_cpp__visibility_control_h_ #ifdef __cplusplus extern "c" { #endif // this logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/visibility #if defined _win32 || defined __cygwin__ #ifdef __gnuc__ #define custom_action_cpp_export __attribute__ ((dllexport)) #define custom_action_cpp_import __attribute__ ((dllimport)) #else #define custom_action_cpp_export __declspec(dllexport) #define custom_action_cpp_import __declspec(dllimport) #endif #ifdef custom_action_cpp_building_dll #define custom_action_cpp_public custom_action_cpp_export #else #define custom_action_cpp_public custom_action_cpp_import #endif #define custom_action_cpp_public_type custom_action_cpp_public #define custom_action_cpp_local #else #define custom_action_cpp_export __attribute__ ((visibility("default"))) #define custom_action_cpp_import #if __gnuc__ >= 4 #define custom_action_cpp_public __attribute__ ((visibility("default"))) #define custom_action_cpp_local __attribute__ ((visibility("hidden"))) #else #define custom_action_cpp_public #define custom_action_cpp_local #endif #define custom_action_cpp_public_type #endif #ifdef __cplusplus } #endif #endif // custom_action_cpp__visibility_control_h_ 2 writing an action server ï letâs focus on writing an action server that computes the fibonacci sequence using the action we created in the creating an action tutorial. 2.1 writing the action server code ï open up custom_action_cpp/src/fibonacci_action_server.cpp , and put the following code in: #include <functional> #include <memory> #include <thread> #include "custom_action_interfaces/action/fibonacci.hpp" #include "rclcpp/rclcpp.hpp" #include "rclcpp_action/rclcpp_action.hpp" #include "rclcpp_components/register_node_macro.hpp" #include "custom_action_cpp/visibility_control.h" namespace custom_action_cpp { class fibonacciactionserver : public rclcpp :: node { public : using fibonacci = custom_action_interfaces :: action :: fibonacci ; using goalhandlefibonacci = rclcpp_action :: servergoalhandle < fibonacci > ; custom_action_cpp_public explicit fibonacciactionserver ( const rclcpp :: nodeoptions & options = rclcpp :: nodeoptions ()) : node ( "fibonacci_action_server" , options ) { using namespace std :: placeholders ; auto handle_goal = [ this ]( const rclcpp_action :: goaluuid & uuid , std :: shared_ptr < const fibonacci :: goal > goal ) { rclcpp_info ( this -> get_logger (), "received goal request with order %d" , goal -> order ); ( void ) uuid ; return rclcpp_action :: goalresponse :: accept_and_execute ; }; auto handle_cancel = [ this ]( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { rclcpp_info ( this -> get_logger (), "received request to cancel goal" ); ( void ) goal_handle ; return rclcpp_action :: cancelresponse :: accept ; }; auto handle_accepted = [ this ]( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { // this needs to return quickly to avoid blocking the executor, // so we declare a lambda function to be called inside a new thread auto execute_in_thread = [ this , goal_handle ](){ return this -> execute ( goal_handle );}; std :: thread { execute_in_thread }. detach (); }; this -> action_server_ = rclcpp_action :: create_server < fibonacci > ( this , "fibonacci" , handle_goal , handle_cancel , handle_accepted ); } private : rclcpp_action :: server < fibonacci >:: sharedptr action_server_ ; void execute ( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { rclcpp_info ( this -> get_logger (), "executing goal" ); rclcpp :: rate loop_rate ( 1 ); const auto goal = goal_handle -> get_goal (); auto feedback = std :: make_shared < fibonacci :: feedback > (); auto & sequence = feedback -> partial_sequence ; sequence . push_back ( 0 ); sequence . push_back ( 1 ); auto result = std :: make_shared < fibonacci :: result > (); for ( int i = 1 ; ( i < goal -> order ) && rclcpp :: ok (); ++ i ) { // check if there is a cancel request if ( goal_handle -> is_canceling ()) { result -> sequence = sequence ; goal_handle -> canceled ( result ); rclcpp_info ( this -> get_logger (), "goal canceled" ); return ; } // update sequence sequence . push_back ( sequence [ i ] + sequence [ i - 1 ]); // publish feedback goal_handle -> publish_feedback ( feedback ); rclcpp_info ( this -> get_logger (), "publish feedback" ); loop_rate . sleep (); } // check if goal is done if ( rclcpp :: ok ()) { result -> sequence = sequence ; goal_handle -> succeed ( result ); rclcpp_info ( this -> get_logger (), "goal succeeded" ); } }; }; // class fibonacciactionserver } // namespace custom_action_cpp rclcpp_components_register_node ( custom_action_cpp :: fibonacciactionserver ) the first few lines include all of the headers we need to compile. next we create a class that is a derived class of rclcpp::node : class fibonacciactionserver : public rclcpp :: node the constructor for the fibonacciactionserver class initializes the node name as fibonacci_action_server : explicit fibonacciactionserver ( const rclcpp :: nodeoptions & options = rclcpp :: nodeoptions ()) : node ( "fibonacci_action_server" , options ) the constructor also instantiates a new action server: loop_rate . sleep (); } // check if goal is done if ( rclcpp :: ok ()) { an action server requires 6 things: the templated action type name: fibonacci . a ros 2 node to add the action to: this . the action name: 'fibonacci' . a callback function for handling goals: handle_goal a callback function for handling cancellation: handle_cancel . a callback function for handling goal accept: handle_accept . the implementation of the various callbacks is done with [lambda expressions]( https://en.cppreference.com/w/cpp/language/lambda ) within the constructor. note that all of the callbacks need to return quickly, otherwise we risk starving the executor. we start with the callback for handling new goals: auto handle_goal = [ this ]( const rclcpp_action :: goaluuid & uuid , std :: shared_ptr < const fibonacci :: goal > goal ) { rclcpp_info ( this -> get_logger (), "received goal request with order %d" , goal -> order ); ( void ) uuid ; return rclcpp_action :: goalresponse :: accept_and_execute ; }; this implementation just accepts all goals. next up is the callback for dealing with cancellation: auto handle_cancel = [ this ]( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { rclcpp_info ( this -> get_logger (), "received request to cancel goal" ); ( void ) goal_handle ; return rclcpp_action :: cancelresponse :: accept ; }; this implementation just tells the client that it accepted the cancellation. the last of the callbacks accepts a new goal and starts processing it: auto handle_accepted = [ this ]( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { // this needs to return quickly to avoid blocking the executor, // so we declare a lambda function to be called inside a new thread auto execute_in_thread = [ this , goal_handle ](){ return this -> execute ( goal_handle );}; std :: thread { execute_in_thread }. detach (); }; since the execution is a long-running operation, we spawn off a thread to do the actual work and return from handle_accepted quickly. all further processing and updates are done in the execute method in the new thread: void execute ( const std :: shared_ptr < goalhandlefibonacci > goal_handle ) { rclcpp_info ( this -> get_logger (), "executing goal" ); rclcpp :: rate loop_rate ( 1 ); const auto goal = goal_handle -> get_goal (); auto feedback = std :: make_shared < fibonacci :: feedback > (); auto & sequence = feedback -> partial_sequence ; sequence . push_back ( 0 ); sequence . push_back ( 1 ); auto result = std :: make_shared < fibonacci :: result > (); for ( int i = 1 ; ( i < goal -> order ) && rclcpp :: ok (); ++ i ) { // check if there is a cancel request if ( goal_handle -> is_canceling ()) { result -> sequence = sequence ; goal_handle -> canceled ( result ); rclcpp_info ( this -> get_logger (), "goal canceled" ); return ; } // update sequence sequence . push_back ( sequence [ i ] + sequence [ i - 1 ]); // publish feedback goal_handle -> publish_feedback ( feedback ); rclcpp_info ( this -> get_logger (), "publish feedback" ); loop_rate . sleep (); } // check if goal is done if ( rclcpp :: ok ()) { result -> sequence = sequence ; goal_handle -> succeed ( result ); rclcpp_info ( this -> get_logger (), "goal succeeded" ); } }; this work thread processes one sequence number of the fibonacci sequence every second, publishing a feedback update for each step. when it has finished processing, it marks the goal_handle as succeeded, and quits. we now have a fully functioning action server. letâs get it built and running. 2.2 compiling the action server ï in the previous section we put the action server code into place. to get it to compile and run, we need to do a couple of additional things. first we need to setup the cmakelists.txt so that the action server is compiled. open up custom_action_cpp/cmakelists.txt , and add the following right after the find_package calls: add_library ( action_server shared src/fibonacci_action_server.cpp ) target_include_directories ( action_server private < build_interface:{cmake_current_source_dir}/include > < install_interface:include > ) target_compile_definitions ( action_server private "custom_action_cpp_building_dll" ) ament_target_dependencies ( action_server "custom_action_interfaces" "rclcpp" "rclcpp_action" "rclcpp_components" ) rclcpp_components_register_node ( action_server plugin "custom_action_cpp::fibonacciactionserver" executable fibonacci_action_server ) install ( targets action_server archive destination lib library destination lib runtime destination bin ) and now we can compile the package. go to the top-level of the ros2_ws , and run: colcon build this should compile the entire workspace, including the fibonacci_action_server in the custom_action_cpp package. 2.3 running the action server ï now that we have the action server built, we can run it. source the workspace we just built ( ros2_ws ), and try to run the action server: ros2 run custom_action_cpp fibonacci_action_server 3 writing an action client ï 3.1 writing the action client code ï open up custom_action_cpp/src/fibonacci_action_client.cpp , and put the following code in: #include <functional> #include <future> #include <memory> #include <string> #include <sstream> #include "custom_action_interfaces/action/fibonacci.hpp" #include "rclcpp/rclcpp.hpp" #include "rclcpp_action/rclcpp_action.hpp" #include "rclcpp_components/register_node_macro.hpp" namespace custom_action_cpp { class fibonacciactionclient : public rclcpp :: node { public : using fibonacci = custom_action_interfaces :: action :: fibonacci ; using goalhandlefibonacci = rclcpp_action :: clientgoalhandle < fibonacci > ; explicit fibonacciactionclient ( const rclcpp :: nodeoptions & options ) : node ( "fibonacci_action_client" , options ) { this -> client_ptr_ = rclcpp_action :: create_client < fibonacci > ( this , "fibonacci" ); auto timer_callback_lambda = [ this ](){ return this -> send_goal (); }; this -> timer_ = this -> create_wall_timer ( std :: chrono :: milliseconds ( 500 ), timer_callback_lambda ); } void send_goal () { using namespace std :: placeholders ; this -> timer_ -> cancel (); if ( ! this -> client_ptr_ -> wait_for_action_server ()) { rclcpp_error ( this -> get_logger (), "action server not available after waiting" ); rclcpp :: shutdown (); } auto goal_msg = fibonacci :: goal (); goal_msg . order = 10 ; rclcpp_info ( this -> get_logger (), "sending goal" ); auto send_goal_options = rclcpp_action :: client < fibonacci >:: sendgoaloptions (); send_goal_options . goal_response_callback = [ this ]( const goalhandlefibonacci :: sharedptr & goal_handle ) { if ( ! goal_handle ) { rclcpp_error ( this -> get_logger (), "goal was rejected by server" ); } else { rclcpp_info ( this -> get_logger (), "goal accepted by server, waiting for result" ); } }; send_goal_options . feedback_callback = [ this ]( goalhandlefibonacci :: sharedptr , const std :: shared_ptr < const fibonacci :: feedback > feedback ) { std :: stringstream ss ; ss << "next number in sequence received: " ; for ( auto number : feedback -> partial_sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); }; send_goal_options . result_callback = [ this ]( const goalhandlefibonacci :: wrappedresult & result ) { switch ( result . code ) { case rclcpp_action :: resultcode :: succeeded : break ; case rclcpp_action :: resultcode :: aborted : rclcpp_error ( this -> get_logger (), "goal was aborted" ); return ; case rclcpp_action :: resultcode :: canceled : rclcpp_error ( this -> get_logger (), "goal was canceled" ); return ; default : rclcpp_error ( this -> get_logger (), "unknown result code" ); return ; } std :: stringstream ss ; ss << "result received: " ; for ( auto number : result . result -> sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); rclcpp :: shutdown (); }; this -> client_ptr_ -> async_send_goal ( goal_msg , send_goal_options ); } private : rclcpp_action :: client < fibonacci >:: sharedptr client_ptr_ ; rclcpp :: timerbase :: sharedptr timer_ ; }; // class fibonacciactionclient } // namespace custom_action_cpp rclcpp_components_register_node ( custom_action_cpp :: fibonacciactionclient ) the first few lines include all of the headers we need to compile. next we create a class that is a derived class of rclcpp::node : class fibonacciactionclient : public rclcpp :: node the constructor for the fibonacciactionclient class initializes the node name as fibonacci_action_client : explicit fibonacciactionclient ( const rclcpp :: nodeoptions & options ) : node ( "fibonacci_action_client" , options ) the constructor also instantiates a new action client: this -> client_ptr_ = rclcpp_action :: create_client < fibonacci > ( this , "fibonacci" ); an action client requires 3 things: the templated action type name: fibonacci . a ros 2 node to add the action client to: this . the action name: 'fibonacci' . we also instantiate a ros timer that will kick off the one and only call to send_goal : auto timer_callback_lambda = [ this ](){ return this -> send_goal (); }; this -> timer_ = this -> create_wall_timer ( std :: chrono :: milliseconds ( 500 ), timer_callback_lambda ); when the timer expires, it will call send_goal : void send_goal () { using namespace std :: placeholders ; this -> timer_ -> cancel (); if ( ! this -> client_ptr_ -> wait_for_action_server ()) { rclcpp_error ( this -> get_logger (), "action server not available after waiting" ); rclcpp :: shutdown (); } auto goal_msg = fibonacci :: goal (); goal_msg . order = 10 ; rclcpp_info ( this -> get_logger (), "sending goal" ); auto send_goal_options = rclcpp_action :: client < fibonacci >:: sendgoaloptions (); send_goal_options . goal_response_callback = [ this ]( const goalhandlefibonacci :: sharedptr & goal_handle ) { if ( ! goal_handle ) { rclcpp_error ( this -> get_logger (), "goal was rejected by server" ); } else { rclcpp_info ( this -> get_logger (), "goal accepted by server, waiting for result" ); } }; send_goal_options . feedback_callback = [ this ]( goalhandlefibonacci :: sharedptr , const std :: shared_ptr < const fibonacci :: feedback > feedback ) { std :: stringstream ss ; ss << "next number in sequence received: " ; for ( auto number : feedback -> partial_sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); }; send_goal_options . result_callback = [ this ]( const goalhandlefibonacci :: wrappedresult & result ) { switch ( result . code ) { case rclcpp_action :: resultcode :: succeeded : break ; case rclcpp_action :: resultcode :: aborted : rclcpp_error ( this -> get_logger (), "goal was aborted" ); return ; case rclcpp_action :: resultcode :: canceled : rclcpp_error ( this -> get_logger (), "goal was canceled" ); return ; default : rclcpp_error ( this -> get_logger (), "unknown result code" ); return ; } std :: stringstream ss ; ss << "result received: " ; for ( auto number : result . result -> sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); rclcpp :: shutdown (); }; this -> client_ptr_ -> async_send_goal ( goal_msg , send_goal_options ); } this function does the following: cancels the timer (so it is only called once). waits for the action server to come up. instantiates a new fibonacci::goal . sets the response, feedback, and result callbacks. sends the goal to the server. when the server receives and accepts the goal, it will send a response to the client. that response is handled by goal_response_callback : send_goal_options . goal_response_callback = [ this ]( const goalhandlefibonacci :: sharedptr & goal_handle ) { if ( ! goal_handle ) { rclcpp_error ( this -> get_logger (), "goal was rejected by server" ); } else { rclcpp_info ( this -> get_logger (), "goal accepted by server, waiting for result" ); } }; assuming the goal was accepted by the server, it will start processing. any feedback to the client will be handled by the feedback_callback : send_goal_options . feedback_callback = [ this ]( goalhandlefibonacci :: sharedptr , const std :: shared_ptr < const fibonacci :: feedback > feedback ) { std :: stringstream ss ; ss << "next number in sequence received: " ; for ( auto number : feedback -> partial_sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); }; when the server is finished processing, it will return a result to the client. the result is handled by the result_callback : send_goal_options . result_callback = [ this ]( const goalhandlefibonacci :: wrappedresult & result ) { switch ( result . code ) { case rclcpp_action :: resultcode :: succeeded : break ; case rclcpp_action :: resultcode :: aborted : rclcpp_error ( this -> get_logger (), "goal was aborted" ); return ; case rclcpp_action :: resultcode :: canceled : rclcpp_error ( this -> get_logger (), "goal was canceled" ); return ; default : rclcpp_error ( this -> get_logger (), "unknown result code" ); return ; } std :: stringstream ss ; ss << "result received: " ; for ( auto number : result . result -> sequence ) { ss << number << " " ; } rclcpp_info ( this -> get_logger (), ss . str (). c_str ()); rclcpp :: shutdown (); }; we now have a fully functioning action client. letâs get it built and running. 3.2 compiling the action client ï in the previous section we put the action client code into place. to get it to compile and run, we need to do a couple of additional things. first we need to setup the cmakelists.txt so that the action client is compiled. open up custom_action_cpp/cmakelists.txt , and add the following right after the find_package calls: add_library ( action_client shared src/fibonacci_action_client.cpp ) target_include_directories ( action_client private < build_interface:{cmake_current_source_dir}/include > < install_interface:include > ) target_compile_definitions ( action_client private "custom_action_cpp_building_dll" ) ament_target_dependencies ( action_client "custom_action_interfaces" "rclcpp" "rclcpp_action" "rclcpp_components" ) rclcpp_components_register_node ( action_client plugin "custom_action_cpp::fibonacciactionclient" executable fibonacci_action_client ) install ( targets action_client archive destination lib library destination lib runtime destination bin ) and now we can compile the package. go to the top-level of the ros2_ws , and run: colcon build this should compile the entire workspace, including the fibonacci_action_client in the custom_action_cpp package. 3.3 running the action client ï now that we have the action client built, we can run it. first make sure that an action server is running in a separate terminal. now source the workspace we just built ( ros2_ws ), and try to run the action client: ros2 run custom_action_cpp fibonacci_action_client you should see logged messages for the goal being accepted, feedback being printed, and the final result. summary ï in this tutorial, you put together a c++ action server and action client line by line, and configured them to exchange goals, feedback, and results. related content ï there are several ways you could write an action server and client in c++; check out the minimal_action_server and minimal_action_client packages in the ros2/examples repo. for more detailed information  ros actions,  refer to the design article . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling