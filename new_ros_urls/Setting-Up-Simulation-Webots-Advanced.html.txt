tutorials advanced simulators webots setting up a robot simulation (advanced) edit on github setting up a robot simulation (advanced) ï goal: extend a robot simulation with an obstacle avoider node. tutorial level: advanced time: 20 minutes background ï in this tutorial you will extend the package created in the first part of the tutorial: setting up a robot simulation (basic) . the aim is to implement a ros 2 node that avoids obstacles using the robotâs distance sensors. this tutorial focuses on using robot devices with the webots_ros2_driver interface. prerequisites ï this is a continuation of the first part of the tutorial: setting up a robot simulation (basic) . it is mandatory to start with the first part to set up the custom packages and necessary files. this tutorial is compatible with version 2023.1.0 of webots_ros2 and webots r2023b, as well as upcoming versions. tasks ï 1 updating my_robot.urdf ï as mentioned in setting up a robot simulation (basic) , webots_ros2_driver contains plugins to interface most of webots devices with ros 2 directly. these plugins can be loaded using the <device> tag in the urdf file of the robot. the reference attribute should match the webots device name parameter. the list of all existing interfaces and the corresponding parameters can be found on the devices reference page . for available devices that are not configured in the urdf file, the interface will be automatically created and default values will be used for ros parameters (e.g. update rate , topic name , and frame name ). in my_robot.urdf replace the whole contents with: python c++ <?xml version="1.0" ?> <robot name= "my robot" > <webots> <device reference= "ds0" type= "distancesensor" > <ros> <topicname> /left_sensor </topicname> <alwayson> true </alwayson> </ros> </device> <device reference= "ds1" type= "distancesensor" > <ros> <topicname> /right_sensor </topicname> <alwayson> true </alwayson> </ros> </device> <plugin type= "my_package.my_robot_driver.myrobotdriver" /> </webots> </robot> <?xml version="1.0" ?> <robot name= "my robot" > <webots> <device reference= "ds0" type= "distancesensor" > <ros> <topicname> /left_sensor </topicname> <alwayson> true </alwayson> </ros> </device> <device reference= "ds1" type= "distancesensor" > <ros> <topicname> /right_sensor </topicname> <alwayson> true </alwayson> </ros> </device> <plugin type= "my_robot_driver::myrobotdriver" /> </webots> </robot> in addition to your custom plugin, the webots_ros2_driver will parse the <device> tags referring to the distancesensor nodes and use the standard parameters in the <ros> tags to enable the sensors and name their topics. 2 creating a ros node to avoid obstacles ï python c++ the robot will use a standard ros node to detect the wall and send motor commands to avoid it. in the my_package/my_package/ folder, create a file named obstacle_avoider.py with this code: import rclpy from rclpy.node import node from sensor_msgs.msg import range from geometry_msgs.msg import twist max_range = 0.15 class obstacleavoider ( node ): def __init__ ( self ): super () . __init__ ( 'obstacle_avoider' ) self . __publisher = self . create_publisher ( twist , 'cmd_vel' , 1 ) self . create_ ( range , 'left_sensor' , self . __left_sensor_callback , 1 ) self . create_ ( range , 'right_sensor' , self . __right_sensor_callback , 1 ) def __left_sensor_callback ( self , message ): self . __left_sensor_value = message . range def __right_sensor_callback ( self , message ): self . __right_sensor_value = message . range command_message = twist () command_message . linear . x = 0.1 if self . __left_sensor_value < 0.9 * max_range or self . __right_sensor_value < 0.9 * max_range : command_message . angular . z = - 2.0 self . __publisher . publish ( command_message ) def main ( args = none ): rclpy . init ( args = args ) avoider = obstacleavoider () rclpy . spin ( avoider ) # destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) avoider . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () this node will create a publisher for the command and subscribe to the sensors topics here: self . __publisher = self . create_publisher ( twist , 'cmd_vel' , 1 ) self . create_ ( range , 'left_sensor' , self . __left_sensor_callback , 1 ) self . create_ ( range , 'right_sensor' , self . __right_sensor_callback , 1 ) when a measurement is received from the left sensor it will be copied to a member field: def __left_sensor_callback ( self , message ): self . __left_sensor_value = message . range finally, a message will be sent to the /cmd_vel topic when a measurement from the right sensor is received. the command_message will register at least a forward speed in linear.x in order to make the robot move when no obstacle is detected. if any of the two sensors detect an obstacle, command_message will also register a rotational speed in angular.z in order to make the robot turn right. def __right_sensor_callback ( self , message ): self . __right_sensor_value = message . range command_message = twist () command_message . linear . x = 0.1 if self . __left_sensor_value < 0.9 * max_range or self . __right_sensor_value < 0.9 * max_range : command_message . angular . z = - 2.0 self . __publisher . publish ( command_message ) the robot will use a standard ros node to detect the wall and send motor commands to avoid it. in the my_package/include/my_package folder, create a header file named obstacleavoider.hpp with this code: #include <memory> #include "geometry_msgs/msg/twist.hpp" #include "rclcpp/rclcpp.hpp" #include "sensor_msgs/msg/range.hpp" class obstacleavoider : public rclcpp :: node { public : explicit obstacleavoider (); private : void leftsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ); void rightsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ); rclcpp :: publisher < geometry_msgs :: msg :: twist >:: sharedptr publisher_ ; rclcpp ::  < sensor_msgs :: msg :: range >:: sharedptr left_sensor_sub_ ; rclcpp ::  < sensor_msgs :: msg :: range >:: sharedptr right_sensor_sub_ ; double left_sensor_value { 0.0 }; double right_sensor_value { 0.0 }; }; in the my_package/src folder, create a source file named obstacleavoider.cpp with this code: #include "my_package/obstacleavoider.hpp" #define max_range 0.15 obstacleavoider :: obstacleavoider () : node ( "obstacle_avoider" ) { publisher_ = create_publisher < geometry_msgs :: msg :: twist > ( "/cmd_vel" , 1 ); left_sensor_sub_ = create_ < sensor_msgs :: msg :: range > ( "/left_sensor" , 1 , [ this ]( const sensor_msgs :: msg :: range :: sharedptr msg ){ return this -> leftsensorcallback ( msg ); } ); right_sensor_sub_ = create_ < sensor_msgs :: msg :: range > ( "/right_sensor" , 1 , [ this ]( const sensor_msgs :: msg :: range :: sharedptr msg ){ return this -> rightsensorcallback ( msg ); } ); } void obstacleavoider :: leftsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ) { left_sensor_value = msg -> range ; } void obstacleavoider :: rightsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ) { right_sensor_value = msg -> range ; auto command_message = std :: make_unique < geometry_msgs :: msg :: twist > (); command_message -> linear . x = 0.1 ; if ( left_sensor_value < 0.9 * max_range || right_sensor_value < 0.9 * max_range ) { command_message -> angular . z = -2.0 ; } publisher_ -> publish ( std :: move ( command_message )); } int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); auto avoider = std :: make_shared < obstacleavoider > (); rclcpp :: spin ( avoider ); rclcpp :: shutdown (); return 0 ; } this node will create a publisher for the command and subscribe to the sensors topics here: publisher_ = create_publisher < geometry_msgs :: msg :: twist > ( "/cmd_vel" , 1 ); left_sensor_sub_ = create_ < sensor_msgs :: msg :: range > ( "/left_sensor" , 1 , [ this ]( const sensor_msgs :: msg :: range :: sharedptr msg ){ return this -> leftsensorcallback ( msg ); } ); right_sensor_sub_ = create_ < sensor_msgs :: msg :: range > ( "/right_sensor" , 1 , [ this ]( const sensor_msgs :: msg :: range :: sharedptr msg ){ return this -> rightsensorcallback ( msg ); } ); when a measurement is received from the left sensor it will be copied to a member field: void obstacleavoider::leftsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ) { left_sensor_value = msg -> range ; } finally, a message will be sent to the /cmd_vel topic when a measurement from the right sensor is received. the command_message will register at least a forward speed in linear.x in order to make the robot move when no obstacle is detected. if any of the two sensors detect an obstacle, command_message will also register a rotational speed in angular.z in order to make the robot turn right. void obstacleavoider::rightsensorcallback ( const sensor_msgs :: msg :: range :: sharedptr msg ) { right_sensor_value = msg -> range ; auto command_message = std :: make_unique < geometry_msgs :: msg :: twist > (); command_message -> linear . x = 0.1 ; if ( left_sensor_value < 0.9 * max_range || right_sensor_value < 0.9 * max_range ) { command_message -> angular . z = -2.0 ; } publisher_ -> publish ( std :: move ( command_message )); } 3 updating additional files ï you have to modify these two other files to launch your new node. python c++ edit setup.py and replace 'console_scripts' with: 'console_scripts' : [ 'my_robot_driver = my_package.my_robot_driver:main' , 'obstacle_avoider = my_package.obstacle_avoider:main' ], this will add an entry point for the obstacle_avoider node. edit cmakelists.txt and add the compilation and installation of the obstacle_avoider : cmake_minimum_required ( version 3.5 ) project ( my_package ) if ( not cmake_cxx_standard ) set ( cmake_cxx_standard 14 ) endif () # besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver` find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( std_msgs required ) find_package ( geometry_msgs required ) find_package ( pluginlib required ) find_package ( webots_ros2_driver required ) # export the plugin configuration file pluginlib_export_plugin_description_file ( webots_ros2_driver my_robot_driver.xml ) # obstacle avoider include_directories ( include ) add_executable ( obstacle_avoider src/obstacleavoider.cpp ) ament_target_dependencies ( obstacle_avoider rclcpp geometry_msgs sensor_msgs ) install ( targets obstacle_avoider destination lib/ { project_name } ) install ( directory include/ destination include ) # myrobotdriver library add_library ( { project_name } shared src/myrobotdriver.cpp ) target_include_directories ( { project_name } private include ) ament_target_dependencies ( { project_name } pluginlib rclcpp webots_ros2_driver ) install ( targets { project_name } archive destination lib library destination lib runtime destination bin ) # install additional directories. install ( directory launch resource worlds destination share/ { project_name } / ) ament_export_include_directories ( include ) ament_export_libraries ( { project_name } ) ament_package () go to the file robot_launch.py and replace it with: import os import launch from launch_ros.actions import node from launch import launchdescription from ament_index_python.packages import get_package_share_directory from webots_ros2_driver.webots_launcher import webotslauncher from webots_ros2_driver.webots_controller import webotscontroller def generate_launch_description (): package_dir = get_package_share_directory ( 'my_package' ) robot_description_path = os . path . join ( package_dir , 'resource' , 'my_robot.urdf' ) webots = webotslauncher ( world = os . path . join ( package_dir , 'worlds' , 'my_world.wbt' ) ) my_robot_driver = webotscontroller ( robot_name = 'my_robot' , parameters = [ { 'robot_description' : robot_description_path }, ] ) obstacle_avoider = node ( package = 'my_package' , executable = 'obstacle_avoider' , ) return launchdescription ([ webots , my_robot_driver , obstacle_avoider , launch . actions . registereventhandler ( event_handler = launch . event_handlers . onprocessexit ( target_action = webots , on_exit = [ launch . actions . emitevent ( event = launch . events . shutdown ())], ) ) ]) this will create an obstacle_avoider node that will be included in the launchdescription . 4 test the obstacle avoidance code ï launch the simulation from a terminal in your ros 2 workspace: linux windows macos from a terminal in your ros 2 workspace run: colcon build source install/local_setup.bash ros2 launch my_package robot_launch.py from a terminal in your wsl ros 2 workspace run: colcon build export webots_home=/mnt/c/program\ files/webots source install/local_setup.bash ros2 launch my_package robot_launch.py be sure to use the /mnt prefix in front of your path to the webots installation folder to access the windows file system from wsl. in a terminal of the host machine (not in the vm), if not done already, specify the webots installation folder (e.g. /applications/webots.app ) and start the server using the following commands: export webots_home=/applications/webots.app python3 local_simulation_server.py note that the server keeps running once the ros 2 nodes are ended. you donât need to restart it every time you want to launch a new simulation. from a terminal in the linux vm in your ros 2 workspace, build and launch your custom package with: cd ~/ros2_ws colcon build source install/local_setup.bash ros2 launch my_package robot_launch.py your robot should go forward and before hitting the wall it should turn clockwise. you can press ctrl+f10 in webots or go to the view menu, optional rendering and show distancesensor rays to display the range of the distance sensors of the robot. summary ï in this tutorial, you extended the basic simulation with a obstacle avoider ros 2 node that publishes velocity commands based on the distance sensor values of the robot. next steps ï you might want to improve the plugin or create new nodes to change the behavior of the robot. you can also implement a reset handler to automatically restart your ros nodes when the simulation is reset from the webots interface: setting up a reset handler . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling