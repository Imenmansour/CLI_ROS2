tutorials intermediate tf2 debugging edit on github debugging ï goal: learn how to use a systematic approach for debugging tf2 related problems. tutorial level: intermediate time: 10 minutes background ï this tutorial walks you through the steps to debug a typical tf2 problem. it will also use many of the tf2 debugging tools, such as tf2_echo , tf2_monitor , and view_frames . this tutorial assumes you have completed the learning tf2 tutorials. debugging example ï 1 setting and starting the example ï for this tutorial we will set up a demo application that has a number of problems. the goal of this tutorial is to apply a systematic approach to find and tackle these problems. first, letâs create the source file. go to the learning_tf2_cpp package we created in tf2 tutorials . inside the src directory make a copy of the source file turtle_tf2_listener.cpp and rename it to turtle_tf2_listener_debug.cpp . open the file using your preferred text editor, and change line 65 from std :: string toframerel = "turtle2" ; to std :: string toframerel = "turtle3" ; and change lookuptransform() call in lines 73-77 from try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , tf2 :: timepointzero ); } catch ( const tf2 :: transformexception & ex ) { to try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , this -> now ()); } catch ( const tf2 :: transformexception & ex ) { and save changes to the file. in order to run this demo, we need to create a launch file start_tf2_debug_demo_launch.py in the launch subdirectory of package learning_tf2_cpp : from launch import launchdescription from launch.actions import declarelaunchargument from launch.substitutions import launchconfiguration from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ declarelaunchargument ( 'target_frame' , default_value = 'turtle1' , description = 'target frame name.' ), node ( package = 'turtlesim' , executable = 'turtlesim_node' , name = 'sim' , output = 'screen' ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster1' , parameters = [ { 'turtlename' : 'turtle1' } ] ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_broadcaster' , name = 'broadcaster2' , parameters = [ { 'turtlename' : 'turtle2' } ] ), node ( package = 'learning_tf2_cpp' , executable = 'turtle_tf2_listener_debug' , name = 'listener_debug' , parameters = [ { 'target_frame' : launchconfiguration ( 'target_frame' )} ] ), ]) donât forget to add the turtle_tf2_listener_debug executable to the cmakelists.txt and build the package. now letâs run it to see what happens: ros2 launch learning_tf2_cpp start_tf2_debug_demo_launch.py you will now see that the turtlesim came up. at the same time, if you run the turtle_teleop_key in another terminal window, you can use the arrow keys to drive the turtle1 around. ros2 run turtlesim turtle_teleop_key you will also notice that there is a second turtle in the lower, left corner. if the demo would be working correctly, this second turtle should be following the turtle you can command with the arrow keys. however, it is not the case because we have to solve some problems first. you should notice the following message: [turtle_tf2_listener_debug-4] [info] [1630223454.942322623] [listener_debug]: could not transform turtle3 to turtle1: "turtle3" passed to lookuptransform argument target_frame does not exist 2 finding the tf2 request ï firstly, we need to find out what exactly we are asking tf2 to do. therefore, we go into the part of the code that is using tf2. open the src/turtle_tf2_listener_debug.cpp file, and take a look at line 65: std :: string to_frame_rel = "turtle3" ; and lines 73-77: try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , this -> now ()); } catch ( const tf2 :: transformexception & ex ) { here we do the actual request to tf2. the three arguments tell us directly what we are asking tf2: transform from frame turtle3 to frame turtle1 at time now . now, letâs take a look at why this request to tf2 is failing. 3 checking the frames ï firstly, to find out if tf2 knows  our transform between turtle3 and turtle1 , we will use tf2_echo tool. ros2 run tf2_ros tf2_echo turtle3 turtle1 the output tells us that frame turtle3 does not exist: [info] [1630223557.477636052] [tf2_echo]: waiting for transform turtle3 -> turtle1: invalid frame id "turtle3" passed to cantransform argument target_frame - frame does not exist then what frames do exist? if you like to get a graphical representation of this, use view_frames tool. ros2 run tf2_tools view_frames open the generated frames.pdf file to see the following output: so obviously the problem is that we are requesting transform from frame turtle3 , which does not exist. to fix this bug, just replace turtle3 with turtle2 in line 65. and now stop the running demo, build it, and run it again: ros2 launch turtle_tf2 start_debug_demo.launch.py and right away we run into the next problem: [turtle_tf2_listener_debug-4] [info] [1630223704.617382464] [listener_debug]: could not transform turtle2 to turtle1: lookup would require extrapolation into the future. requested time 1630223704.617054 but the latest data is at time 1630223704.616726, when looking up transform from frame [turtle1] to frame [turtle2] 4 checking the timestamp ï now that we solved the frame name problem, it is time to look at the timestamps. remember, we are trying to get the transform between turtle2 and turtle1 at the current time (i.e., now ). to get statistics on the timing, call tf2_monitor with corresponding frames. ros2 run tf2_ros tf2_monitor turtle2 turtle1 the result should look something like this: results: for turtle2 to turtle1 chain is: turtle1 net delay avg = 0.00287347: max = 0.0167241 frames: frame: turtle1, published by <no authority available>, average delay: 0.000295833, max delay: 0.000755072 all broadcasters: node: <no authority available> 125.246 hz, average delay: 0.000290237 max delay: 0.000786781 the key part here is the delay for the chain from turtle2 to turtle1 . the output shows there is an average delay of  3 milliseconds. this means that tf2 can only transform between the turtles after 3 milliseconds are passed. so, if we would be asking tf2 for the transformation between the turtles 3 milliseconds ago instead of now , tf2 would be able to give us an answer sometimes. letâs test this quickly by changing lines 73-77 to: try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , this -> now () - rclcpp :: duration :: from_seconds ( 0.1 )); } catch ( const tf2 :: transformexception & ex ) { in the new code we are asking for the transform between the turtles 100 milliseconds ago. it is usual to use a longer periods, just to make sure that the transform will arrive. stop the demo, build and run: ros2 launch turtle_tf2 start_debug_demo.launch.py and you should finally see the turtle move! that last fix we made is not really what you want to do, it was just to make sure that was our problem. the real fix would look like this: try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , tf2 :: timepointzero ); } catch ( const tf2 :: transformexception & ex ) { or like this: try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , tf2 :: timepoint ()); } catch ( const tf2 :: transformexception & ex ) { you can learn more  timeouts in the using time tutorial, and use them as below: try { t = tf_buffer_ -> lookuptransform ( toframerel , fromframerel , this -> now (), rclcpp :: duration :: from_seconds ( 0.05 )); } catch ( const tf2 :: transformexception & ex ) { summary ï in this tutorial you learned how to use a systematic approach for debugging tf2 related problems. you also learned how to use tf2 debugging tools, such as tf2_echo , tf2_monitor , and view_frames to help you debug those tf2 problems. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling