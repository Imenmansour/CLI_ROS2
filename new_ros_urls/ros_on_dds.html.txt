articles/020_ros_with_dds.md toggle navigation ros 2 design contribute login disabled for now ros on dds this article was written at a time before decisions were made to use dds and rtps as the underlying communication standards for ros 2. for details on how ros 2 has been implemented, see the core documentation this article makes the case for using dds as the middleware for ros, outlining the pros and cons of this approach, as well as considering the impact to the user experience and code api that using dds would have. the results of the ros_dds prototype are also summarized and used in the exploration of the issue. authors: william woodall date written: 2014-06 last modified: 2019-07 terminology: data distribution service (dds) real-time publish subscribe (rtps) the object management group (omg) omg interface description language (idl) formal description why consider dds when exploring options for the next generation communication system of ros, the initial options were to either improve the ros 1 transport or build a new middleware using component libraries such as zeromq , protocol buffers, and zeroconf (bonjour/avahi). however, in addition to those options, both of which involved us building a middleware from parts or scratch, other end-to-end middlewares were considered. during our research, one middleware that stood out was dds. an end-to-end middleware the benefit of using an end-to-end middleware, like dds, is that there is much less code to maintain and the behavior and exact specifications of the middleware have already been distilled into documentation. in addition to system-level documentation, dds also has recommended use cases and a software api. with this concrete specification, third parties can review, audit, and implement the middleware with varying degrees of interoperability. this is something that ros has never had, besides a few basic descriptions in a wiki and a reference implementation. additionally, this type of specification would need to be created anyway if a new middleware were to be built from existing libraries. the drawback of using an end-to-end middleware is that ros must work within that existing design. if the design did not target a relevant use case or is not flexible, it might be necessary to work around the design. on some level, adopting an end-to-end middleware includes adopting the philosophy and culture of that middleware, which should not be taken lightly. what is dds dds provides a publish-subscribe transport which is very similar to ross publish-subscribe transport. dds uses the interface description language (idl) as defined by the object management group (omg) for message definition and serialization. dds has a request-response style transport, which would be like ross service system, in beta 2 as of june 2016 (called dds-rpc ). the default discovery system provided by dds, which is required to use ddss publish-subscribe transport, is a distributed discovery system. this allows any two dds programs to communicate without the need for a tool like the ros master. this makes the system more fault tolerant and flexible. it is not required to use the dynamic discovery mechanism, however, as multiple dds vendors provide options for static discovery. where did dds come from dds got its start as a group of companies which had similar middleware frameworks and became a standard when common customers wanted to get better interoperability between the vendors. the dds standard was created by the object management group, which are the same people that brought us uml, corba, sysml, and other generic software related standards. now, depending on your perspective, this may be a positive endorsement or a negative endorsement. on the one hand you have a standards committee which is perennial and clearly has a huge influence on the software engineering community, but on the other hand you have a slow moving body which is slow to adapt to changes and therefore arguably doesnt always keep up with the latest trends in software engineering. dds was originally several similar middlewares which eventually became so close to one another that writing a standard to unify them made sense. so in this way, even though the dds specification has been written by a committee, it has evolved to its current form by reacting to the needs of its users. this type of organic evolution of the specification before it was ratified helps to alleviate the concern that the system was designed in a vacuum and that it does not perform well in real environments. there are some examples of committees coming up with well intentioned and well described specifications that nobody wants to use or that dont meet the needs of the community they serve, but this does not appear to be the case for dds. there is also a concern that dds is a static specification which was defined and is used in legacy systems, but has not kept current. this kind of stereotype comes from horror stories  things like uml and corba, which are also products of omg. on the contrary, dds seems to have an active and organic specification, which in the recent past has added, or is adding, more specifications for things like websockets, security over ssl, extensible types, request and response transport, and a new, more modern c++11 style api specification for the core api to replace the existing c++ interface. this type of evolution in the standard body for dds is an encouraging thing to observe, and even though the body is relatively slow, as compared to software engineering technology trends, it is evolving to meet demands of its users. technical credibility dds has an extensive list of varied installations which are typically mission critical. dds has been used in: battleships large utility installations like dams financial systems space systems flight systems train switchboard systems and many other equally important and varied scenarios. these successful use cases lend credibility to ddss design being both reliable and flexible. not only has dds met the needs of these use cases, but after talking with users of dds (in this case government and nasa employees who are also users of ros), they have all praised its reliability and flexibility. those same users will note that the flexibility of dds comes at the cost of complexity. the complexity of the api and configuration of dds is something that ros would need to address. the dds wire specification ( ddsi-rtps ) is extremely flexible, allowing it to be used for reliable, high level systems integration as well as real-time applications on embedded devices. several of the dds vendors have special implementations of dds for embedded systems which boast specs related to library size and memory footprint on the scale of tens or hundreds of kilobytes. since dds is implemented, by default, on udp, it does not depend on a reliable transport or hardware for communication. this means that dds has to reinvent the reliability wheel (basically tcp plus or minus some features), but in exchange dds gains portability and control over the behavior. control over several parameters of reliability, what dds calls quality of service (qos), gives maximum flexibility in controlling the behavior of communication. for example, if you are concerned  latency, like for soft real-time, you can basically tune dds to be just a udp blaster. in another scenario you might need something that behaves like tcp, but needs to be more tolerant to long dropouts, and with dds all of these things can be controlled by changing the qos parameters. though the default implementation of dds is over udp, and only requires that level of functionality from the transport, omg also added support for dds over tcp in version 1.2 of their specification. only looking briefly, two of the vendors (rti and adlink technologies) both support dds over tcp. from rtis website ( http://community.rti.com/kb/xml-qos-example-using-rti-connext-dds-tcp-transport ): by default, rti connext dds uses the udpv4 and shared memory transport to communicate with other dds applications. in some circumstances, the tcp protocol might be needed for discovery and data exchange. for more information on the rti tcp transport,  refer to the section in the rti core libraries and utilities user manual titled rti tcp transport. from adlinks website, they support tcp as of opensplice v6.4: https://www.adlinktech.com/en/data-distribution-service.aspx vendors and licensing the omg defined the dds specification with several companies which are now the main dds vendors. popular dds vendors include: rti adlink technologies twin oaks software amongst these vendors is an array of reference implementations with different strategies and licenses. the omg maintains an active list of dds vendors. in addition to vendors providing implementations of the dds specifications api, there are software vendors which provide an implementation with more direct access to the dds wire protocol, rtps. for example: eprosima these rtps-centric implementations are also of interest because they can be smaller in scope and still provide the needed functionality for implementing the necessary ros capabilities on top. rtis connext dds is available under a custom community infrastructure license, which is compatible with the ros communitys needs but requires further discussion with the community in order to determine its viability as the default dds vendor for ros. by compatible with the ros communitys needs, we mean that, though it is not an osi-approved license , research has shown it to be adequately permissive to allow ros to keep a bsd style license and for anyone in the ros community to redistribute it in source or binary form. rti also appears to be willing to negotiate on the license to meet the ros communitys needs, but it will take some iteration between the ros community and rti to make sure this would work. like the other vendors this license is available for the core set of functionality, basically the basic dds api, whereas other parts of their product like development and introspection tools are proprietary. rti seems to have the largest on-line presence and installation base. adlinks dds implementation, opensplice, is licensed under the lgpl, which is the same license used by many popular open source libraries, like glibc, zeromq, and qt. it is available on github : https://github.com/adlink-ist/opensplice adlinks implementation comes with a basic, functioning build system and was fairly easy to package. opensplice appears to be the number two dds implementation in use, but that is hard to tell for sure. twinoakss coredx dds implementation is proprietary only, but apparently they specialize in minimal implementations which are able to run on embedded devices and even bare metal. eprosimas fastrtps implementation is available on github and is lgpl licensed: https://github.com/eprosima/fast-rtps eprosima fast rtps is a relatively new, lightweight, and open source implementation of rtps. it allows direct access to the rtps protocol settings and features, which is not always possible with other dds implementations. eprosimas implementation also includes a minimum dds api, idl support, and automatic code generation and they are open to working with the ros community to meet their needs. given the relatively strong lgpl option and the encouraging but custom license from rti, it seems that depending on and even distributing dds as a dependency should be straightforward. one of the goals of this proposal would be to make ros 2 dds vendor agnostic. so, just as an example, if the default implementation is connext, but someone wants to use one of the lgpl options like opensplice or fastrtps, they simply need to recompile the ros source code with some options flipped and they can use the implementation of their choice. this is made possible because of the fact that dds defines an api in its specification. research has shown that making code which is vendor agnostic is possible if not a little painful since the apis of the different vendors is almost identical, but there are minor differences like return types (pointer versus shared_ptr like thing) and header file organization. ethos and community dds comes out of a set of companies which are decades old, was laid out by the omg which is an old-school software engineering organization, and is used largely by government and military users. so it comes as no surprise that the community for dds looks very different from the ros community and that of similar modern software projects like zeromq. though rti has a respectable on-line presence, the questions asked by community members are almost always answered by an employee of rti and though technically open source, neither rti nor opensplice has spent time to provide packages for ubuntu or homebrew or any other modern package manager. they do not have extensive user-contributed wikis or an active github repository. this staunch difference in ethos between the communities is one of the most concerning issues with depending on dds. unlike options like keeping tcpros or using zeromq, there isnt the feeling that there is a large community to fall back on with dds. however, the dds vendors have been very responsive to our inquiries during our research and it is hard to say if that will continue when it is the ros community which brings the questions. even though this is something which should be taken into consideration when making a decision  using dds, it should not disproportionately outweigh the technical pros and cons of the dds proposal. ros built on dds the goal is to make dds an implementation detail of ros 2. this means that all dds specific apis and message definitions would need to be hidden. dds provides discovery, message definition, message serialization, and publish-subscribe transport. therefore, dds would provide discovery, publish-subscribe transport, and at least the underlying message serialization for ros. ros 2 would provide a ros 1 like interface on top of dds which hides much of the complexity of dds for the majority of ros users, but then separately provides access to the underlying dds implementation for users that have extreme use cases or need to integrate with other, existing dds systems. dds and ros api layout accessing the dds implementation would require depending on an additional package which is not normally used. in this way you can tell if a package has tied itself to a particular dds vendor by just looking at the package dependencies. the goal of the ros api, which is on top of dds, should be to meet all the common needs for the ros community, because once a user taps into the underlying dds system, they will lose portability between dds vendors. portability among dds vendors is not intended to encourage people to frequently choose different vendors, but rather to enable power users to select the dds implementation that meets their specific requirements, as well as to future-proof ros against changes in the dds vendor options. there will be one recommended and best-supported default dds implementation for ros. discovery dds would completely replace the ros master based discovery system. ros would need to tap into the dds api to get information like a list of all nodes, a list of all topics, and how they are connected. accessing this information would be hidden behind a ros defined api, preventing the users from having to call into dds directly. the advantage of the dds discovery system is that, by default, it is completely distributed, so there is no central point of failure which is required for parts of the system to communicate with each other. dds also allows for user defined meta data in their discovery system, which will enable ros to piggyback higher level concepts onto publish-subscribe. publish-subscribe transport the ddsi-rtps (dds-interoperability real time publish subscribe) protocol would replace ross tcpros and udpros wire protocols for publish/subscribe. the dds api provides a few more actors to the typical publish-subscribe pattern of ros 1. in ros the concept of a node is most clearly paralleled to a graph participant in dds. a graph participant can have zero to many topics, which are very similar to the concept of topics in ros, but are represented as separate code objects in dds, and is neither a subscriber nor a publisher. then, from a dds topic, dds subscribers and publishers can be created, but again these are used to represent the subscriber and publisher concepts in dds, and not to directly read data from or write data to the topic. dds has, in addition to the topics, subscribers, and publishers, the concept of datareaders and datawriters which are created with a subscriber or publisher and then specialized to a particular message type before being used to read and write data for a topic. these additional layers of abstraction allow dds to have a high level of configuration, because you can set qos settings at each level of the publish-subscribe stack, providing the highest granularity of configuration possible. most of these levels of abstractions are not necessary to meet the current needs of ros. therefore, packaging common workflows under the simpler ros-like interface (node, publisher, and subscriber) will be one way ros 2 can hide the complexity of dds, while exposing some of its features. efficient transport alternatives in ros 1 there was never a standard shared-memory transport because it is negligibly faster than localhost tcp loop-back connections. it is possible to get non-trivial performance improvements from carefully doing zero-copy style shared-memory between processes, but anytime a task required faster than localhost tcp in ros 1, nodelets were used. nodelets allow publishers and subscribers to share data by passing around boost::shared_ptr s to messages. this intraprocess communication is almost certainly faster than any interprocess communication options and is orthogonal to the discussion of the network publish-subscribe implementation. in the context of dds, most vendors will optimize message traffic (even between processes) using shared-memory in a transparent way, only using the wire protocol and udp sockets when leaving the localhost. this provides a considerable performance increase for dds, whereas it did not for ros 1, because the localhost networking optimization happens at the call to send . for ros 1 the process was: serialize the message into one large buffer, call tcps send on the buffer once. for dds the process would be more like: serialize the message, break the message into potentially many udp packets, call udps send many times. in this way sending many udp datagrams does not benefit from the same speed up as one large tcp send . therefore, many dds vendors will short circuit this process for localhost messages and use a blackboard style shared-memory mechanism to communicate efficiently between processes. however, not all dds vendors are the same in this respect, so ros would not rely on this intelligent behavior for efficient intra process communication. additionally, if the ros message format is kept, which is discussed in the next section, it would not be possible to prevent a conversion to the dds message type for intraprocess topics. therefore a custom intraprocess communication system would need to be developed for ros which would never serialize nor convert messages, but instead would pass pointers (to shared in-process memory) between publishers and subscribers using dds topics. this same intraprocess communication mechanism would be needed for a custom middleware built on zeromq, for example. the point to take away here is that efficient intra process communication will be addressed regardless of the network/interprocess implementation of the middleware. messages there is a great deal of value in the current ros message definitions. the format is simple, and the messages themselves have evolved over years of use by the robotics community. much of the semantic contents of current ros code is driven by the structure and contents of these messages, so preserving the format and in-memory representation of the messages has a great deal of value. in order to meet this goal, and in order to make dds an implementation detail, ros 2 should preserve the ros 1 like message definitions and in-memory representation. therefore, the ros 1 .msg files would continue to be used and the .msg files would be converted into .idl files so that they could be used with the dds transport. language specific files would be generated for both the .msg files and the .idl files as well as conversion functions for converting between ros and dds in-memory instances. the ros 2 api would work exclusively with the .msg style message objects in memory and would convert them to .idl objects before publishing. at first, the idea of converting a message field-by-field into another object type for each call to publish seems like a huge performance problem, but experimentation has shown that the cost of this copy is insignificant when compared to the cost of serialization. this ratio between the cost of converting types and the cost of serialization, which was found to be at least one order of magnitude, holds true with every serialization library that we tried, except capn proto which doesnt have a serialization step. therefore, if a field-by-field copy will not work for your use case, neither will serializing and transporting over the network, at which point you will have to utilize an intraprocess or zero-copy interprocess communication. the intraprocess communication in ros would not use the dds in-memory representation so this field-by-field copy would not be used unless the data is going to the wire. because this conversion is only invoked in conjunction with a more expensive serialization step, the field-by-field copy seems to be a reasonable trade-off for the portability and abstraction provided by preserving the ros .msg files and in-memory representation. this does not preclude the option to improve the .msg file format with things like default values and optional fields. but this is a different trade-off which can be decided later. services and actions dds currently does not have a ratified or implemented standard for request-response style rpc which could be used to implement the concept of services in ros. there is currently an rpc specification being considered for ratification in the omg dds working group, and several of the dds vendors have a draft implementation of the rpc api. it is not clear, however, whether this standard will work for actions, but it could at least support non-preemptable version of ros services. ros 2 could either implement services and actions on top of publish-subscribe (this is more feasible in dds because of their reliable publish-subscribe qos setting) or it could use the dds rpc specification once it is finished for services and then build actions on top, again like it is in ros 1. either way actions will be a first class citizen in the ros 2 api and it may be the case that services just become a degenerate case of actions. language support dds vendors typically provide at least c, c++, and java implementations since apis for those languages are explicitly defined by the dds specification. there are not any well established versions of dds for python that research has uncovered. therefore, one goal of the ros 2 system will be to provide a first-class, feature complete c api. this will allow bindings for other languages to be made more easily and to enable more consistent behavior between client libraries, since they will use the same implementation. languages like python, ruby, and lisp can wrap the c api in a thin, language idiomatic implementation. the actual implementation of ros can either be in c, using the c dds api, or in c++ using the dds c++ api and then wrapping the c++ implementation in a c api for other languages. implementing in c++ and wrapping in c is a common pattern, for example zeromq does exactly this. the author of zeromq , however, did not do this in his new library, nanomsg , citing increased complexity and the bloat of the c++ stdlib as a dependency. since the c implementation of dds is typically pure c, it would be possible to have a pure c implementation for the ros c api all the way down through the dds implementation. however, writing the entire system in c might not be the first goal, and in the interest of getting a minimal viable product working, the implementation might be in c++ and wrapped in c to begin with and later the c++ can be replaced with c if it seems necessary. dds as a dependency one of the goals of ros 2 is to reuse as much code as possible (do not reinvent the wheel) but also minimize the number of dependencies to improve portability and to keep the build dependency list lean. these two goals are sometimes at odds, since it is often the choice between implementing something internally or relying on an outside source (dependency) for the implementation. this is a point where the dds implementations shine, because two of the three dds vendors under evaluation build on linux, os x, windows, and other more exotic systems with no external dependencies. the c implementation relies only on the system libraries, the c++ implementations only rely on a c++03 compiler, and the java implementation only needs a jvm and the java standard library. bundled as a binary (during prototyping) on both ubuntu and os x, the c, c++, java, and c# implementations of opensplice (lgpl) is less than three megabytes in size and has no other dependencies. as far as dependencies go, this makes dds very attractive because it significantly simplifies the build and run dependencies for ros. additionally, since the goal is to make dds an implementation detail, it can probably be removed as a transitive run dependency, meaning that it will not even need to be installed on a deployed system. the ros on dds prototype following the research into the feasibility of ros on dds, several questions were left, including but not limited to: can the ros 1 api and behavior be implemented on top of dds? is it practical to generate idl messages from ros msg messages and use them with dds? how hard is it to package (as a dependency) dds implementations? does the dds api specification actually make dds vendor portability a reality? how difficult is it to configure dds? in order to answer some of these questions a prototype and several experiments were created in this repository: https://github.com/osrf/ros_dds more questions and some of the results were captured as issues: https://github.com/osrf/ros_dds/issues?labels=task&page=1&state=closed the major piece of work in this repository is in the prototype folder and is a ros 1 like implementation of the node, publisher, and subscriber api using dds: https://github.com/osrf/ros_dds/tree/master/prototype specifically this prototype includes these packages: generation of dds idls from .msg files: https://github.com/osrf/ros_dds/tree/master/prototype/src/genidl generation of dds specific c++ code for each generated idl file: https://github.com/osrf/ros_dds/tree/master/prototype/src/genidlcpp minimal ros client library for c++ (rclcpp): https://github.com/osrf/ros_dds/tree/master/prototype/src/rclcpp talker and listener for pub-sub and service calls: https://github.com/osrf/ros_dds/tree/master/prototype/src/rclcpp_examples a branch of ros_tutorials in which turtlesim has been modified to build against the rclcpp library: https://github.com/ros/ros_tutorials/tree/ros_dds/turtlesim . this branch of turtlesim is not feature-complete (e.g., services and parameters are not supported), but the basics work, and it demonstrates that the changes required to transition from ros 1 roscpp to the prototype of ros 2 rclcpp are not dramatic. this is a rapid prototype which was used to answer questions, so it is not representative of the final product or polished at all. work on certain features was stopped cold once key questions had been answered. the examples in the rclcpp_example package showed that it was possible to implement the basic ros like api on top of dds and get familiar behavior. this is by no means a complete implementation and doesnt cover all of the features, but instead it was for educational purposes and addressed most of the doubts which were held with respect to using dds. generation of idl files proved to have some sticking points, but could ultimately be addressed, and implementing basic things like services proved to be tractable problems. in addition to the above basic pieces, a pull request was drafted which managed to completely hide the dds symbols from any publicly installed headers for rclcpp and std_msgs : https://github.com/osrf/ros_dds/pull/17 this pull request was ultimately not merged because it was a major refactoring of the structure of the code and other progress had been made in the meantime. however, it served its purpose in that it showed that the dds implementation could be hidden, though there is room for discussion on how to actually achieve that goal. conclusion after working with dds and having a healthy amount of skepticism  the ethos, community, and licensing, it is hard to come up with any real technical criticisms. while it is true that the community surrounding dds is very different from the ros community or the zeromq community, it appears that dds is just solid technology on which ros could safely depend. there are still many questions  exactly how ros would utilize dds, but they all seem like engineering exercises at this point and not potential deal breakers for ros. view source edit in github pull requests open closed  login to view pull requests  login to view pull requests contributors  login to view contributors