tutorials intermediate writing an action server and client (python) edit on github writing an action server and client (python) ï goal: implement an action server and client in python. tutorial level: intermediate time: 15 minutes background ï actions are a form of asynchronous communication in ros 2. action clients send goal requests to action servers . action servers send goal feedback and results to action clients . prerequisites ï you will need the custom_action_interfaces package and the fibonacci.action interface defined in the previous tutorial, creating an action . tasks ï 1 writing an action server ï letâs focus on writing an action server that computes the fibonacci sequence using the action we created in the creating an action tutorial. until now, youâve created packages and used ros2 run to run your nodes. to keep things simple in this tutorial, however, weâll scope the action server to a single file. if youâd like to see what a complete package for the actions tutorials looks like, check out action_tutorials . open a new file in your home directory, letâs call it fibonacci_action_server.py , and add the following code: import rclpy from rclpy.action import actionserver from rclpy.node import node from custom_action_interfaces.action import fibonacci class fibonacciactionserver ( node ): def __init__ ( self ): super () . __init__ ( 'fibonacci_action_server' ) self . _action_server = actionserver ( self , fibonacci , 'fibonacci' , self . execute_callback ) def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'executing goal...' ) result = fibonacci . result () return result def main ( args = none ): rclpy . init ( args = args ) fibonacci_action_server = fibonacciactionserver () rclpy . spin ( fibonacci_action_server ) if __name__ == '__main__' : main () line 8 defines a class fibonacciactionserver that is a subclass of node . the class is initialized by calling the node constructor, naming our node fibonacci_action_server : super () . __init__ ( 'fibonacci_action_server' ) in the constructor we also instantiate a new action server: self . _action_server = actionserver ( self , fibonacci , 'fibonacci' , self . execute_callback ) an action server requires four arguments: a ros 2 node to add the action client to: self . the type of the action: fibonacci (imported in line 5). the action name: 'fibonacci' . a callback function for executing accepted goals: self.execute_callback . this callback must return a result message for the action type. we also define an execute_callback method in our class: def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'executing goal...' ) result = fibonacci . result () return result this is the method that will be called to execute a goal once it is accepted. letâs try running our action server: linux macos windows python3 fibonacci_action_server.py python3 fibonacci_action_server.py python fibonacci_action_server.py in another terminal, we can use the command line interface to send a goal: ros2 action send_goal fibonacci custom_action_interfaces/action/fibonacci "{order: 5}" in the terminal that is running the action server, you should see a logged message âexecuting goalââ followed by a warning that the goal state was not set. by default, if the goal handle state is not set in the execute callback it assumes the aborted state. we can call succeed() on the goal handle to indicate that the goal was successful: def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'executing goal...' ) goal_handle . succeed () result = fibonacci . result () return result now if you restart the action server and send another goal, you should see the goal finished with the status succeeded . now letâs make our goal execution actually compute and return the requested fibonacci sequence: def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'executing goal...' ) sequence = [ 0 , 1 ] for i in range ( 1 , goal_handle . request . order ): sequence . append ( sequence [ i ] + sequence [ i - 1 ]) goal_handle . succeed () result = fibonacci . result () result . sequence = sequence return result after computing the sequence, we assign it to the result message field before returning. again, restart the action server and send another goal. you should see the goal finish with the proper result sequence. 1.2 publishing feedback ï one of the nice things  actions is the ability to provide feedback to an action client during goal execution. we can make our action server publish feedback for action clients by calling the goal handleâs publish_feedback() method. weâll replace the sequence variable, and use a feedback message to store the sequence instead. after every update of the feedback message in the for-loop, we publish the feedback message and sleep for dramatic effect: import time import rclpy from rclpy.action import actionserver from rclpy.node import node from custom_action_interfaces.action import fibonacci class fibonacciactionserver ( node ): def __init__ ( self ): super () . __init__ ( 'fibonacci_action_server' ) self . _action_server = actionserver ( self , fibonacci , 'fibonacci' , self . execute_callback ) def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'executing goal...' ) feedback_msg = fibonacci . feedback () feedback_msg . partial_sequence = [ 0 , 1 ] for i in range ( 1 , goal_handle . request . order ): feedback_msg . partial_sequence . append ( feedback_msg . partial_sequence [ i ] + feedback_msg . partial_sequence [ i - 1 ]) self . get_logger () . info ( 'feedback: {0} ' . format ( feedback_msg . partial_sequence )) goal_handle . publish_feedback ( feedback_msg ) time . sleep ( 1 ) goal_handle . succeed () result = fibonacci . result () result . sequence = feedback_msg . partial_sequence return result def main ( args = none ): rclpy . init ( args = args ) fibonacci_action_server = fibonacciactionserver () rclpy . spin ( fibonacci_action_server ) if __name__ == '__main__' : main () after restarting the action server, we can confirm that feedback is now published by using the command line tool with the --feedback option: ros2 action send_goal --feedback fibonacci custom_action_interfaces/action/fibonacci "{order: 5}" 2 writing an action client ï weâll also scope the action client to a single file. open a new file, letâs call it fibonacci_action_client.py , and add the following boilerplate code: import rclpy from rclpy.action import actionclient from rclpy.node import node from custom_action_interfaces.action import fibonacci class fibonacciactionclient ( node ): def __init__ ( self ): super () . __init__ ( 'fibonacci_action_client' ) self . _action_client = actionclient ( self , fibonacci , 'fibonacci' ) def send_goal ( self , order ): goal_msg = fibonacci . goal () goal_msg . order = order self . _action_client . wait_for_server () return self . _action_client . send_goal_async ( goal_msg ) def main ( args = none ): rclpy . init ( args = args ) action_client = fibonacciactionclient () future = action_client . send_goal ( 10 ) rclpy . spin_until_future_complete ( action_client , future ) if __name__ == '__main__' : main () weâve defined a class fibonacciactionclient that is a subclass of node . the class is initialized by calling the node constructor, naming our node fibonacci_action_client : super () . __init__ ( 'fibonacci_action_client' ) also in the class constructor, we create an action client using the custom action definition from the previous tutorial on creating an action : self . _action_client = actionclient ( self , fibonacci , 'fibonacci' ) we create an actionclient by passing it three arguments: a ros 2 node to add the action client to: self the type of the action: fibonacci the action name: 'fibonacci' our action client will be able to communicate with action servers of the same action name and type. we also define a method send_goal in the fibonacciactionclient class: def send_goal ( self , order ): goal_msg = fibonacci . goal () goal_msg . order = order self . _action_client . wait_for_server () return self . _action_client . send_goal_async ( goal_msg ) this method waits for the action server to be available, then sends a goal to the server. it returns a future that we can later wait on. after the class definition, we define a function main() that initializes ros 2 and creates an instance of our fibonacciactionclient node. it then sends a goal and waits until that goal has been completed. finally, we call main() in the entry point of our python program. letâs test our action client by first running the action server built earlier: linux macos windows python3 fibonacci_action_server.py python3 fibonacci_action_server.py python fibonacci_action_server.py in another terminal, run the action client: linux macos windows python3 fibonacci_action_client.py python3 fibonacci_action_client.py python fibonacci_action_client.py you should see messages printed by the action server as it successfully executes the goal: [ info ] [ fibonacci_action_server ] : executing goal... [ info ] [ fibonacci_action_server ] : feedback: array ( 'i' , [ 0 , 1 , 1 ]) [ info ] [ fibonacci_action_server ] : feedback: array ( 'i' , [ 0 , 1 , 1 , 2 ]) [ info ] [ fibonacci_action_server ] : feedback: array ( 'i' , [ 0 , 1 , 1 , 2 , 3 ]) [ info ] [ fibonacci_action_server ] : feedback: array ( 'i' , [ 0 , 1 , 1 , 2 , 3 , 5 ]) # etc. the action client should start up, and then quickly finish. at this point, we have a functioning action client, but we donât see any results or get any feedback. 2.1 getting a result ï so we can send a goal, but how do we know when it is completed? we can get the result information with a couple steps. first, we need to get a goal handle for the goal we sent. then, we can use the goal handle to request the result. hereâs the complete code for this example: import rclpy from rclpy.action import actionclient from rclpy.node import node from custom_action_interfaces.action import fibonacci class fibonacciactionclient ( node ): def __init__ ( self ): super () . __init__ ( 'fibonacci_action_client' ) self . _action_client = actionclient ( self , fibonacci , 'fibonacci' ) def send_goal ( self , order ): goal_msg = fibonacci . goal () goal_msg . order = order self . _action_client . wait_for_server () self . _send_goal_future = self . _action_client . send_goal_async ( goal_msg ) self . _send_goal_future . add_done_callback ( self . goal_response_callback ) def goal_response_callback ( self , future ): goal_handle = future . result () if not goal_handle . accepted : self . get_logger () . info ( 'goal rejected :(' ) return self . get_logger () . info ( 'goal accepted :)' ) self . _get_result_future = goal_handle . get_result_async () self . _get_result_future . add_done_callback ( self . get_result_callback ) def get_result_callback ( self , future ): result = future . result () . result self . get_logger () . info ( 'result: {0} ' . format ( result . sequence )) rclpy . shutdown () def main ( args = none ): rclpy . init ( args = args ) action_client = fibonacciactionclient () action_client . send_goal ( 10 ) rclpy . spin ( action_client ) if __name__ == '__main__' : main () the actionclient.send_goal_async() method returns a future to a goal handle. first we register a callback for when the future is complete: self . _send_goal_future . add_done_callback ( self . goal_response_callback ) note that the future is completed when an action server accepts or rejects the goal request. letâs look at the goal_response_callback in more detail. we can check to see if the goal was rejected and return early since we know there will be no result: def goal_response_callback ( self , future ): goal_handle = future . result () if not goal_handle . accepted : self . get_logger () . info ( 'goal rejected :(' ) return self . get_logger () . info ( 'goal accepted :)' ) now that weâve got a goal handle, we can use it to request the result with the method get_result_async() . similar to sending the goal, we will get a future that will complete when the result is ready. letâs register a callback just like we did for the goal response: self . _get_result_future = goal_handle . get_result_async () self . _get_result_future . add_done_callback ( self . get_result_callback ) in the callback, we log the result sequence and shutdown ros 2 for a clean exit: def get_result_callback ( self , future ): result = future . result () . result self . get_logger () . info ( 'result: {0} ' . format ( result . sequence )) rclpy . shutdown () with an action server running in a separate terminal, go ahead and try running our fibonacci action client! linux macos windows python3 fibonacci_action_client.py python3 fibonacci_action_client.py python fibonacci_action_client.py you should see logged messages for the goal being accepted and the final result. 2.2 getting feedback ï our action client can send goals. nice! but it would be great if we could get some feedback  the goals we send from the action server. hereâs the complete code for this example: import rclpy from rclpy.action import actionclient from rclpy.node import node from custom_action_interfaces.action import fibonacci class fibonacciactionclient ( node ): def __init__ ( self ): super () . __init__ ( 'fibonacci_action_client' ) self . _action_client = actionclient ( self , fibonacci , 'fibonacci' ) def send_goal ( self , order ): goal_msg = fibonacci . goal () goal_msg . order = order self . _action_client . wait_for_server () self . _send_goal_future = self . _action_client . send_goal_async ( goal_msg , feedback_callback = self . feedback_callback ) self . _send_goal_future . add_done_callback ( self . goal_response_callback ) def goal_response_callback ( self , future ): goal_handle = future . result () if not goal_handle . accepted : self . get_logger () . info ( 'goal rejected :(' ) return self . get_logger () . info ( 'goal accepted :)' ) self . _get_result_future = goal_handle . get_result_async () self . _get_result_future . add_done_callback ( self . get_result_callback ) def get_result_callback ( self , future ): result = future . result () . result self . get_logger () . info ( 'result: {0} ' . format ( result . sequence )) rclpy . shutdown () def feedback_callback ( self , feedback_msg ): feedback = feedback_msg . feedback self . get_logger () . info ( 'received feedback: {0} ' . format ( feedback . partial_sequence )) def main ( args = none ): rclpy . init ( args = args ) action_client = fibonacciactionclient () action_client . send_goal ( 10 ) rclpy . spin ( action_client ) if __name__ == '__main__' : main () hereâs the callback function for feedback messages: def feedback_callback ( self , feedback_msg ): feedback = feedback_msg . feedback self . get_logger () . info ( 'received feedback: {0} ' . format ( feedback . partial_sequence )) in the callback we get the feedback portion of the message and print the partial_sequence field to the screen. we need to register the callback with the action client. this is achieved by additionally passing the callback to the action client when we send a goal: self . _send_goal_future = self . _action_client . send_goal_async ( goal_msg , feedback_callback = self . feedback_callback ) weâre all set. if we run our action client, you should see feedback being printed to the screen. summary ï in this tutorial, you put together a python action server and action client line by line, and configured them to exchange goals, feedback, and results. related content ï there are several ways you could write an action server and client in python; check out the minimal_action_server and minimal_action_client packages in the ros2/examples repo. for more detailed information  ros actions,  refer to the design article . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling