tutorials intermediate tf2 writing a static broadcaster (c++) edit on github writing a static broadcaster (c++) ï goal: learn how to broadcast static coordinate frames to tf2. tutorial level: intermediate time: 15 minutes background ï publishing static transforms is useful to define the relationship between a robot base and its sensors or non-moving parts. for example, it is easiest to reason  laser scan measurements in a frame at the center of the laser scanner. this is a standalone tutorial covering the basics of static transforms, which consists of two parts. in the first part we will write code to publish static transforms to tf2. in the second part we will explain how to use the commandline static_transform_publisher executable tool in tf2_ros . in the next two tutorials we will write the code to reproduce the demo from the introduction to tf2 tutorial. after that, the following tutorials focus on extending the demo with more advanced tf2 features. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 create a package ï first we will create a package that will be used for this tutorial and the following ones. the package called learning_tf2_cpp will depend on geometry_msgs , rclcpp , tf2 , tf2_ros , and turtlesim . code for this tutorial is stored here . open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate to workspaceâs src folder and create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 --dependencies geometry_msgs rclcpp tf2 tf2_ros turtlesim -- learning_tf2_cpp your terminal will return a message verifying the creation of your package learning_tf2_cpp and all its necessary files and folders. 2 write the static broadcaster node ï letâs first create the source files. inside the src/learning_tf2_cpp/src directory download the example static broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/static_turtle_tf2_broadcaster.cpp wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/static_turtle_tf2_broadcaster.cpp in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/static_turtle_tf2_broadcaster.cpp -o static_turtle_tf2_broadcaster.cpp or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/static_turtle_tf2_broadcaster.cpp -o static_turtle_tf2_broadcaster.cpp open the file using your preferred text editor. #include <memory> #include "geometry_msgs/msg/transform_stamped.hpp" #include "rclcpp/rclcpp.hpp" #include "tf2/linearmath/quaternion.h" #include "tf2_ros/static_transform_broadcaster.h" class staticframepublisher : public rclcpp :: node { public : explicit staticframepublisher ( char * transformation []) : node ( "static_turtle_tf2_broadcaster" ) { tf_static_broadcaster_ = std :: make_shared < tf2_ros :: statictransformbroadcaster > ( this ); // publish static transforms once at startup this -> make_transforms ( transformation ); } private : void make_transforms ( char * transformation []) { geometry_msgs :: msg :: transformstamped t ; t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "world" ; t . child_frame_id = transformation [ 1 ]; t . transform . translation . x = atof ( transformation [ 2 ]); t . transform . translation . y = atof ( transformation [ 3 ]); t . transform . translation . z = atof ( transformation [ 4 ]); tf2 :: quaternion q ; q . setrpy ( atof ( transformation [ 5 ]), atof ( transformation [ 6 ]), atof ( transformation [ 7 ])); t . transform . rotation . x = q . x (); t . transform . rotation . y = q . y (); t . transform . rotation . z = q . z (); t . transform . rotation . w = q . w (); tf_static_broadcaster_ -> sendtransform ( t ); } std :: shared_ptr < tf2_ros :: statictransformbroadcaster > tf_static_broadcaster_ ; }; int main ( int argc , char * argv []) { auto logger = rclcpp :: get_logger ( "logger" ); // obtain parameters from command line arguments if ( argc != 8 ) { rclcpp_info ( logger , "invalid number of parameters \n usage: " " ros2 run learning_tf2_cpp static_turtle_tf2_broadcaster " "child_frame_name x y z roll pitch yaw" ); return 1 ; } // as the parent frame of the transform is `world`, it is // necessary to check that the frame name passed is different if ( strcmp ( argv [ 1 ], "world" ) == 0 ) { rclcpp_info ( logger , "your static turtle name cannot be 'world'" ); return 1 ; } // pass parameters and initialize node rclcpp :: init ( argc , argv ); rclcpp :: spin ( std :: make_shared < staticframepublisher > ( argv )); rclcpp :: shutdown (); return 0 ; } 2.1 examine the code ï now letâs look at the code that is relevant to publishing the static turtle pose to tf2. the first lines include the required header files. first we include geometry_msgs/msg/transform_stamped.hpp to access the transformstamped message type, which we will publish to the transformation tree. #include "geometry_msgs/msg/transform_stamped.hpp" afterward, rclcpp is included so its rclcpp::node class can be used. #include "rclcpp/rclcpp.hpp" tf2::quaternion is a class for a quaternion that provides convenient functions for converting euler angles to quaternions and vice versa. we also include tf2_ros/static_transform_broadcaster.h to use the statictransformbroadcaster to make the publishing of static transforms easy. #include "tf2/linearmath/quaternion.h" #include "tf2_ros/static_transform_broadcaster.h" the staticframepublisher class constructor initializes the node with the name static_turtle_tf2_broadcaster . then, statictransformbroadcaster is created, which will send one static transformation upon the startup. tf_static_broadcaster_ = std :: make_shared < tf2_ros :: statictransformbroadcaster > ( this ); this -> make_transforms ( transformation ); here we create a transformstamped object, which will be the message we will send over once populated. before passing the actual transform values we need to give it the appropriate metadata. we need to give the transform being published a timestamp and weâll just stamp it with the current time, this->get_clock()->now() then we need to set the name of the parent frame of the link weâre creating, in this case world finally, we need to set the name of the child frame of the link weâre creating geometry_msgs :: msg :: transformstamped t ; t . header . stamp = this -> get_clock () -> now (); t . header . frame_id = "world" ; t . child_frame_id = transformation [ 1 ]; here we populate the 6d pose (translation and rotation) of the turtle. t . transform . translation . x = atof ( transformation [ 2 ]); t . transform . translation . y = atof ( transformation [ 3 ]); t . transform . translation . z = atof ( transformation [ 4 ]); tf2 :: quaternion q ; q . setrpy ( atof ( transformation [ 5 ]), atof ( transformation [ 6 ]), atof ( transformation [ 7 ])); t . transform . rotation . x = q . x (); t . transform . rotation . y = q . y (); t . transform . rotation . z = q . z (); t . transform . rotation . w = q . w (); finally, we broadcast static transform using the sendtransform() function. tf_static_broadcaster_ -> sendtransform ( t ); 2.2 update package.xml ï navigate one level back to the src/learning_tf2_cpp directory, where the cmakelists.txt and package.xml files have been created for you. open package.xml with your text editor. as mentioned in the create a package tutorial, make sure to fill in the <description> , <maintainer> and <license> tags: <description> learning tf2 with rclcpp </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> make sure to save the file. 2.3 cmakelists.txt ï add the executable to the cmakelists.txt and name it static_turtle_tf2_broadcaster , which youâll use later with ros2 run . add_executable(static_turtle_tf2_broadcaster src/static_turtle_tf2_broadcaster.cpp) ament_target_dependencies( static_turtle_tf2_broadcaster geometry_msgs rclcpp tf2 tf2_ros ) finally, add the install(targetsâ) section so ros2 run can find your executable: install(targets static_turtle_tf2_broadcaster destination lib/{project_name}) 3 build ï itâs good practice to run rosdep in the root of your workspace to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your new package: linux macos windows colcon build --packages-select learning_tf2_cpp colcon build --packages-select learning_tf2_cpp colcon build --merge-install --packages-select learning_tf2_cpp open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 4 run ï now run the static_turtle_tf2_broadcaster node: ros2 run learning_tf2_cpp static_turtle_tf2_broadcaster mystaticturtle 0 0 1 0 0 0 this sets a turtle pose broadcast for mystaticturtle to float 1 meter above the ground. we can now check that the static transform has been published by echoing the tf_static topic ros2 topic echo /tf_static if everything went well you should see a single static transform transforms: - header: stamp: sec: 1622908754 nanosec: 208515730 frame_id: world child_frame_id: mystaticturtle transform: translation: x: 0.0 y: 0.0 z: 1.0 rotation: x: 0.0 y: 0.0 z: 0.0 w: 1.0 the proper way to publish static transforms ï this tutorial aimed to show how statictransformbroadcaster can be used to publish static transforms. in your real development process you shouldnât have to write this code yourself and should use the dedicated tf2_ros tool to do so. tf2_ros provides an executable named static_transform_publisher that can be used either as a commandline tool or a node that you can add to your launchfiles. the following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw in radians. in ros 2, roll/pitch/yaw refers to rotation  the x/y/z-axis, respectively. ros2 run tf2_ros static_transform_publisher --x x --y y --z z --yaw yaw --pitch pitch --roll roll --frame-id frame_id --child-frame-id child_frame_id the following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw as a quaternion. ros2 run tf2_ros static_transform_publisher --x x --y y --z z --qx qx --qy qy --qz qz --qw qw --frame-id frame_id --child-frame-id child_frame_id static_transform_publisher is designed both as a command-line tool for manual use, as well as for use within launch files for setting static transforms. for example: from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): return launchdescription([ node( package='tf2_ros', executable='static_transform_publisher', arguments = ['--x', '0', '--y', '0', '--z', '1', '--yaw', '0', '--pitch', '0', '--roll', '0', '--frame-id', 'world', '--child-frame-id', 'mystaticturtle'] ), ]) note that all arguments except for --frame-id and --child-frame-id are optional; if a particular option isnât specified, then the identity will be assumed. summary ï in this tutorial you learned how static transforms are useful to define static relationships between frames, like mystaticturtle in relation to the world frame. in addition, you learned how static transforms can be useful for understanding sensor data, such as from laser scanners, by relating the data to a common coordinate frame. finally, you wrote your own node to publish static transforms to tf2 and learned how to publish required static transformations using static_transform_publisher executable and launch files. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling