tutorials intermediate tf2 writing a static broadcaster (python) edit on github writing a static broadcaster (python) ï goal: learn how to broadcast static coordinate frames to tf2. tutorial level: intermediate time: 15 minutes background ï publishing static transforms is useful to define the relationship between a robot base and its sensors or non-moving parts. for example, it is easiest to reason  laser scan measurements in a frame at the center of the laser scanner. this is a standalone tutorial covering the basics of static transforms, which consists of two parts. in the first part we will write code to publish static transforms to tf2. in the second part we will explain how to use the commandline static_transform_publisher executable tool in tf2_ros . in the next two tutorials we will write the code to reproduce the demo from the introduction to tf2 tutorial. after that, the following tutorials focus on extending the demo with more advanced tf2 features. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 create a package ï first we will create a package that will be used for this tutorial and the following ones. the package called learning_tf2_py will depend on geometry_msgs , python3-numpy , rclpy , tf2_ros_py , and turtlesim . code for this tutorial is stored here . open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate to workspaceâs src folder and create a new package: ros2 pkg create --build-type ament_python --license apache-2.0 -- learning_tf2_py your terminal will return a message verifying the creation of your package learning_tf2_py and all its necessary files and folders. 2 write the static broadcaster node ï letâs first create the source files. inside the src/learning_tf2_py/learning_tf2_py directory download the example static broadcaster code by entering the following command: linux macos windows wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py in a windows command line prompt: curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py -o static_turtle_tf2_broadcaster.py or in powershell: curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py -o static_turtle_tf2_broadcaster.py now open the file called static_turtle_tf2_broadcaster.py using your preferred text editor. import math import sys from geometry_msgs.msg import transformstamped import numpy as np import rclpy from rclpy.node import node from tf2_ros.static_transform_broadcaster import statictransformbroadcaster def quaternion_from_euler ( ai , aj , ak ): ai /= 2.0 aj /= 2.0 ak /= 2.0 ci = math . cos ( ai ) si = math . sin ( ai ) cj = math . cos ( aj ) sj = math . sin ( aj ) ck = math . cos ( ak ) sk = math . sin ( ak ) cc = ci * ck cs = ci * sk sc = si * ck ss = si * sk q = np . empty (( 4 , )) q [ 0 ] = cj * sc - sj * cs q [ 1 ] = cj * ss + sj * cc q [ 2 ] = cj * cs - sj * sc q [ 3 ] = cj * cc + sj * ss return q class staticframepublisher ( node ): """ broadcast transforms that never change. this example publishes transforms from `world` to a static turtle frame. the transforms are only published once at startup, and are constant for all time. """ def __init__ ( self , transformation ): super () . __init__ ( 'static_turtle_tf2_broadcaster' ) self . tf_static_broadcaster = statictransformbroadcaster ( self ) # publish static transforms once at startup self . make_transforms ( transformation ) def make_transforms ( self , transformation ): t = transformstamped () t . header . stamp = self . get_clock () . now () . to_msg () t . header . frame_id = 'world' t . child_frame_id = transformation [ 1 ] t . transform . translation . x = float ( transformation [ 2 ]) t . transform . translation . y = float ( transformation [ 3 ]) t . transform . translation . z = float ( transformation [ 4 ]) quat = quaternion_from_euler ( float ( transformation [ 5 ]), float ( transformation [ 6 ]), float ( transformation [ 7 ])) t . transform . rotation . x = quat [ 0 ] t . transform . rotation . y = quat [ 1 ] t . transform . rotation . z = quat [ 2 ] t . transform . rotation . w = quat [ 3 ] self . tf_static_broadcaster . sendtransform ( t ) def main (): logger = rclpy . logging . get_logger ( 'logger' ) # obtain parameters from command line arguments if len ( sys . argv ) != 8 : logger . info ( 'invalid number of parameters. usage: \n ' ' ros2 run learning_tf2_py static_turtle_tf2_broadcaster' 'child_frame_name x y z roll pitch yaw' ) sys . exit ( 1 ) if sys . argv [ 1 ] == 'world' : logger . info ( 'your static turtle name cannot be "world"' ) sys . exit ( 2 ) # pass parameters and initialize node rclpy . init () node = staticframepublisher ( sys . argv ) try : rclpy . spin ( node ) except keyboardinterrupt : pass rclpy . shutdown () 2.1 examine the code ï now letâs look at the code that is relevant to publishing the static turtle pose to tf2. the first lines import required packages. first we import the transformstamped from the geometry_msgs , which provides us a template for the message that we will publish to the transformation tree. from geometry_msgs.msg import transformstamped afterward, rclpy is imported so its node class can be used. import rclpy from rclpy.node import node the tf2_ros package provides a statictransformbroadcaster to make the publishing of static transforms easy. to use the statictransformbroadcaster , we need to import it from the tf2_ros module. from tf2_ros.static_transform_broadcaster import statictransformbroadcaster the staticframepublisher class constructor initializes the node with the name static_turtle_tf2_broadcaster . then, statictransformbroadcaster is created, which will send one static transformation upon the startup. self . tf_static_broadcaster = statictransformbroadcaster ( self ) self . make_transforms ( transformation ) here we create a transformstamped object, which will be the message we will send over once populated. before passing the actual transform values we need to give it the appropriate metadata. we need to give the transform being published a timestamp and weâll just stamp it with the current time, self.get_clock().now() then we need to set the name of the parent frame of the link weâre creating, in this case world finally, we need to set the name of the child frame of the link weâre creating t = transformstamped () t . header . stamp = self . get_clock () . now () . to_msg () t . header . frame_id = 'world' t . child_frame_id = transformation [ 1 ] here we populate the 6d pose (translation and rotation) of the turtle. t . transform . translation . x = float ( transformation [ 2 ]) t . transform . translation . y = float ( transformation [ 3 ]) t . transform . translation . z = float ( transformation [ 4 ]) quat = quaternion_from_euler ( float ( transformation [ 5 ]), float ( transformation [ 6 ]), float ( transformation [ 7 ])) t . transform . rotation . x = quat [ 0 ] t . transform . rotation . y = quat [ 1 ] t . transform . rotation . z = quat [ 2 ] t . transform . rotation . w = quat [ 3 ] finally, we broadcast static transform using the sendtransform() function. self . tf_static_broadcaster . sendtransform ( t ) 2.2 update package.xml ï navigate one level back to the src/learning_tf2_py directory, where the setup.py , setup.cfg , and package.xml files have been created for you. open package.xml with your text editor. as mentioned in the create a package tutorial, make sure to fill in the <description> , <maintainer> and <license> tags: <description> learning tf2 with rclpy </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> after the lines above, add the following dependencies corresponding to your nodeâs import statements: <exec_depend> geometry_msgs </exec_depend> <exec_depend> python3-numpy </exec_depend> <exec_depend> rclpy </exec_depend> <exec_depend> tf2_ros_py </exec_depend> <exec_depend> turtlesim </exec_depend> this declares the required geometry_msgs , python3-numpy , rclpy , tf2_ros_py , and turtlesim dependencies when its code is executed. make sure to save the file. 2.3 add an entry point ï to allow the ros2 run command to run your node, you must add the entry point to setup.py (located in the src/learning_tf2_py directory). add the following line between the 'console_scripts': brackets: 'static_turtle_tf2_broadcaster = learning_tf2_py.static_turtle_tf2_broadcaster:main' , 3 build ï itâs good practice to run rosdep in the root of your workspace to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself rosdep only runs on linux, so you will need to install geometry_msgs and turtlesim dependencies yourself still in the root of your workspace, build your new package: linux macos windows colcon build --packages-select learning_tf2_py colcon build --packages-select learning_tf2_py colcon build --merge-install --packages-select learning_tf2_py open a new terminal, navigate to the root of your workspace, and source the setup files: linux macos windows . install/setup.bash . install/setup.bash # cmd call install\setup.bat # powershell .\install\setup.ps1 4 run ï now run the static_turtle_tf2_broadcaster node: ros2 run learning_tf2_py static_turtle_tf2_broadcaster mystaticturtle 0 0 1 0 0 0 this sets a turtle pose broadcast for mystaticturtle to float 1 meter above the ground. we can now check that the static transform has been published by echoing the tf_static topic ros2 topic echo /tf_static if everything went well you should see a single static transform transforms: - header: stamp: sec: 1622908754 nanosec: 208515730 frame_id: world child_frame_id: mystaticturtle transform: translation: x: 0.0 y: 0.0 z: 1.0 rotation: x: 0.0 y: 0.0 z: 0.0 w: 1.0 the proper way to publish static transforms ï this tutorial aimed to show how statictransformbroadcaster can be used to publish static transforms. in your real development process you shouldnât have to write this code yourself and should use the dedicated tf2_ros tool to do so. tf2_ros provides an executable named static_transform_publisher that can be used either as a commandline tool or a node that you can add to your launchfiles. the following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw in radians. in ros 2, roll/pitch/yaw refers to rotation  the x/y/z-axis, respectively. ros2 run tf2_ros static_transform_publisher --x x --y y --z z --yaw yaw --pitch pitch --roll roll --frame-id frame_id --child-frame-id child_frame_id the following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw as a quaternion. ros2 run tf2_ros static_transform_publisher --x x --y y --z z --qx qx --qy qy --qz qz --qw qw --frame-id frame_id --child-frame-id child_frame_id static_transform_publisher is designed both as a command-line tool for manual use, as well as for use within launch files for setting static transforms. for example: from launch import launchdescription from launch_ros.actions import node def generate_launch_description (): return launchdescription ([ node ( package = 'tf2_ros' , executable = 'static_transform_publisher' , arguments = [ '--x' , '0' , '--y' , '0' , '--z' , '1' , '--yaw' , '0' , '--pitch' , '0' , '--roll' , '0' , '--frame-id' , 'world' , '--child-frame-id' , 'mystaticturtle' ] ), ]) note that all arguments except for --frame-id and --child-frame-id are optional; if a particular option isnât specified, then the identity will be assumed. summary ï in this tutorial you learned how static transforms are useful to define static relationships between frames, like mystaticturtle in relation to the world frame. in addition, you learned how static transforms can be useful for understanding sensor data, such as from laser scanners, by relating the data to a common coordinate frame. finally, you wrote your own node to publish static transforms to tf2 and learned how to publish required static transformations using static_transform_publisher executable and launch files. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling