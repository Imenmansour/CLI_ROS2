how-to guides ides and debugging [community-contributed] edit on github ides and debugging [community-contributed] ï ros 2 is not made around a specific development environment and the main focus is on building / running from the command line. nonetheless integrated development environments (ides) can be used to develop, run and/or debug ros 2 nodes. below are listed some ides and instructions on how to use them with ros 2. general ï installed python code ï by default, when building workspaces with: colcon build the python code will be coped over into the build / install directories. so when attaching a debugger to a ros2 run command from within an ide, the code being run (from the build / install ) is not the same as the files opened in the ide project. there are 2 options to deal with this: open the source files from build / install directory and place breakpoints there. build the workspace with the âsymlink-install flag to colcon, which will symlink the source files to the build / install directory instead. visual studio code ï vscode is a versatile and free development environment. vscode is relatively easy to use with ros 2. simply activate your environment in a command line and start the vscode application from the same terminal and use as normal. so: create your ros workspace as you would normally. in a terminal, source both ros 2 and your install (if it was built already). start vscode from the same command line. the terminal will be blocked until the application is closed again. linux macos windows source /opt/ros/jazzy/setup.bash cd ~/dev_ws source ./install/setup.bash /usr/bin/code ./src/my_node/ . ~/ros2_install/ros2-osx/setup.bash cd ~/dev_ws . ./install/setup.bash /applications/visual studio code.app/contents/resources/app/bin/code ./src/my_node/ # for cmd: call c:\dev\ros2\local_setup.bat cd c:\dev_ws call .\install\local_setup.bat "c:\program files\microsoft vs code\code.exe" .\src\my_node\ # for powershell: c:\dev\ros2\local_setup.ps1 cd c:\dev_ws .\install\local_setup.ps1 & "c:\program files\microsoft vs code\code.exe" .\src\my_node\ vscode and any terminal created inside vscode will correctly inherit from the parent environment and should have ros and installed package available. note after adding packages or making major changes you might need to source your install again. the simplest way to do this is to close vscode and restart it as above. python ï in your workspace, verify the correct interpreter is used. through sourcing the basic command python should be correct, but vscode likes to resort to an absolute path for python. in the bottom right corner click on âselected python interpreterâ to change it. if your ros 2 python version is from a virtual environment, vscode will try to source it at each run command. but we already started vscode from a sourced environment, so this extra step is not necessary. you can disable this for the current workspace by finding âsettingsâ > âextensionsâ > âpythonâ > âactivate environmentâ and disabling the check. now simply run a file or create a configuration in launch.json . debugging a node is easiest by creating a configuration like a python ... command, instead of ros2 run/launch ... . an example of launch.json could be: { "version" : "0.2.0" , "configurations" : [ { "name" : "python: file" , "type" : "python" , "request" : "launch" , "program" : "my_node.py" }, ] } instead you could also create a configuration for attaching to a running process, under âattach using process idâ. see setup ros 2 with vscode and docker for full instructions on how to use vscode, in combination with docker. pycharm ï pycharm is an ide specifically for python. of course it can only be meaningfully used for nodes made in python. with pycharm you can either attach to an existing process (probably started by you via ros2 run ... or ros2 launch ... ) or run the node directly from python (equivalent to python [file.py] . integrate for code inspection ï you can setup your pycharm project such that it is fully aware of ros 2 code, allowing code completion and suggestion. linux ï open a terminal, source ros and start pycharm: source /opt/ros/humble/setup.bash cd path/to/dev_ws /opt/pycharm/bin/pycharm.sh after selecting the correct interpreter, everything should work. note this is untested. windows ï first sourcing ros and then starting pycharm from the command line seems to have no effect on windows. instead, some settings need to be tweaked. create your ros workspace as you would normally. start pycharm normally. open a project. this should be the root directory of the ros node youâre developing, e.g. c:\dev_ws\src\my_node . click âadd new interpreterâ > âadd local interpreterââ. select a system interpreter (or virtual environment if youâre using one) and select the executable of your ros python version (typically c:\python38\python.exe ). if you now open one of your code files, you will see warnings  missing imports. trying to run the file will confirm these issues. under the âpython interpretersâ window, find and select your ros interpreter. edit the name to something recognizable. more importantly, now click the âshow interpreter pathsâ button. in the new window, you will see the paths already associated with this interpreter. click the â+â button and add two more paths (according to your ros install): c:\dev\ros2_humble\bin c:\dev\ros2_humble\lib\site-packages pycharm will re-index and when finished it should correctly interpret your project, recognising the ros 2 system packages. you can navigate through code, get completion and read doc blurbs as expected. if there are dependencies built alongside with your package, they are probably not yet recognized and result in invalid ide warnings and runtime errors. resolve this by: making sure the path override in the run/debug configuration includes both the ros 2 install and your workspace, e.g.: c: \d ev \r os2_humble \l ocal_setup.ps1 c: \d ev_ws \i nstall \l ocal_setup.ps1 echo env :path adding the relevant folders from the install/ directory to your project sources. go to âsettingsââ and under âproject: â > âproject structureâ click âadd content rootâ. add all the relevant site-packages folders under install/lib/* . finally, make sure your run/debug configuration has the option âinclude content roots in pythonpathâ enabled. tip using the âmerge-install option with your colcon build will limit the number of depending directories, making it easier to configure pycharm. attach to process ï even without any configuration to pycharm, you can always just attach to a running python node. open your project source and simply run your node as usual: ros2 run my_node main then in pycharm select ârunâ > âattach to processââ. it might take a second, but a small window should show listing the currently running python instances, including your node. there can be multiple python processes, so there may be some trial-and-error to find the right one. after selecting an instance, the usual debugging tools are available. you can pause it or create breakpoints in the code and step through it. note the code in your project might not be the files being executed, see this . run/debug ï follow the steps for integration first. running your python file from pycharm will likely result in import errors. this is because pycharm extends the pythonpath environment variable, but it leaves path untouched. necessary library files in ros/bin are not found. edit the run/debug configuration for your file and under âenvironment variables:â add a new variable. it is currently not supported to extend the existing path , so we need to override it. from a sourced ros terminal, export the content of path with: echo env:path . copy the result. back in pycharm, paste it as path , apply changes and run or debug your node. it should work like any python project now, allowing easy additions of breakpoints and other debug methods. note on windows it seems the capitalization of the path variable under âenvironment variables:â must be âpathâ (all lowercase) in order to work. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling