tutorials advanced how to use ros2_tracing to trace and analyze an application edit on github how to use ros2_tracing to trace and analyze an application ï this tutorial shows how to use ros2_tracing to trace and analyze a ros 2 application. for this tutorial, the application will be performance_test . overview ï this tutorial covers: running and tracing a performance_test run analyzing the trace data using tracetools_analysis to plot the callback durations prerequisites ï this tutorial is aimed at real-time linux systems. see the real-time system setup tutorial . however, the tutorial will work if you are using a non-real-time linux system. installing and building ï install ros 2 on linux by following the installation instructions . note this tutorial should generally work with all supported linux distributions. however, you might need to adapt some commands. install babeltrace and ros2trace . sudo apt-get update sudo apt-get install -y babeltrace ros-jazzy-ros2trace ros-jazzy-tracetools-analysis source the ros 2 installation and verify that tracing is enabled: source /opt/ros/jazzy/setup.bash ros2 run tracetools status you should see tracing enabled in the output. then create a workspace, and clone performance_test and tracetools_analysis . cd ~/ mkdir -p tracing_ws/src cd tracing_ws/src/ git clone https://gitlab.com/apexai/performance_test.git git clone https://github.com/ros-tracing/tracetools_analysis.git -b jazzy cd .. install dependencies with rosdep. rosdep update rosdep install --from-paths src --ignore-src -y then build and configure performance_test for ros 2. see its documentation . colcon build --packages-select performance_test --cmake-args -dperformance_test_rclcpp_enabled = on next, we will run a performance_test experiment and trace it. tracing ï step 1: trace ï in one terminal, source the workspace and set up tracing. when running the command, a list of ros 2 userspace events will be printed. it will also print the path to the directory that will contain the resulting trace (under ~/.ros/tracing ). # terminal 1 cd ~/tracing_ws source install/setup.bash ros2 trace --session-name perf-test --list press enter to start tracing. step 2: run application ï in a second terminal, source the workspace. # terminal 2 cd ~/tracing_ws source install/setup.bash then run the performance_test experiment (or your own application). we simply create an experiment with a node publishing ~1 mb messages to another node as fast as possible for 60 seconds using the second highest real-time priority so that we donât interfere with critical kernel threads. we need to run performance_test as root to be able to use real-time priorities. # terminal 2 sudo ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m array1m --reliability reliable --max-runtime 60 --use-rt-prio 98 if that last command doesnât work for you (with an error like: âerror while loading shared librariesâ), run the slightly-different command below. this is because, for security reasons, we need to manually pass *path environment variables for some shared libraries to be found (see this explanation ). # terminal 2 sudo env path = " path " ld_library_path = " ld_library_path " ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m array1m --reliability reliable --max-runtime 60 --use-rt-prio 98 note if youâre not using a real-time kernel, simply run: # terminal 2 ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m array1m --reliability reliable --max-runtime 60 step 3: validate trace ï once the experiment is done, in the first terminal, press enter again to stop tracing. use babeltrace to quickly look at the resulting trace. babeltrace ~/.ros/tracing/perf-test | less the output of the above command is a human-readable version of the raw common trace format (ctf) data, which is a list of trace events. each event has a timestamp, an event type, some information on the process that generated the event, and the values of the fields of the given event type. use the arrow keys to scroll, or press q to exit. next, we will analyze the trace. analysis ï tracetools_analysis provides a python api to easily analyze traces. we can use it in a jupyter notebook with bokeh to plot the data. the tracetools_analysis repository contains a few sample notebooks , including one notebook to analyze  callback durations . for this tutorial, we will plot the durations of the  callback in the subscriber node. install jupyter notebook and bokeh, and then open the sample notebook. pip3 install bokeh jupyter notebook ~/tracing_ws/src/tracetools_analysis/tracetools_analysis/analysis/callback_duration.ipynb this will open the notebook in the browser. replace the value for the path variable in the second cell to the path to the trace directory: path = '~/.ros/tracing/perf-test' run the notebook by clicking the run button for each cell. running the cell that does the trace processing might take a few minutes on the first run, but subsequent runs will be much quicker. you should get a plot that looks similar to this: we can see that most of the callbacks take less than 0.01 ms, but there are some outliers taking over 0.02 or 0.03 ms. conclusion ï this tutorial showed how to install tracing-related tools. then it showed how to trace a performance_test experiment using ros2_tracing and plot the callback durations using tracetools_analysis . for more trace analyses, take a look at the other sample notebooks and the tracetools_analysis api documentation . the ros2_tracing design document also contains a lot of information. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling