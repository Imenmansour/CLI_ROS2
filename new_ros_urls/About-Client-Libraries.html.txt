concepts basic concepts client libraries edit on github client libraries ï overview ï client libraries are the apis that allow users to implement their ros 2 code. using client libraries, users gain access to ros 2 concepts such as nodes, topics, services, etc. client libraries come in a variety of programming languages so that users may write ros 2 code in the language that is best-suited for their application. for example, you might prefer to write visualization tools in python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in c++. nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ros 2 interface files in the respective language. in addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ros ârosâ. for example, here is a list of functionality that can typically be accessed through a client library: names and namespaces time (real or simulated) parameters console logging threading model intra-process communication supported client libraries ï the c++ client library ( rclcpp ) and the python client library ( rclpy ) are both client libraries which utilize common functionality in rcl . the rclcpp package ï the ros client library for c++ ( rclcpp ) is the user facing, c++ idiomatic interface which provides all of the ros client functionality like creating nodes, publishers, and s. rclcpp builds on top of rcl and the rosidl api , and it is designed to be used with the c++ messages generated by rosidl_generator_cpp . rclcpp makes use of all the features of c++ and c++17 to make the interface as easy to use as possible, but since it reuses the implementation in rcl it is able maintain a consistent behavior with the other client libraries that use the rcl api . the rclcpp repository is located on github at ros2/rclcpp and contains the package rclcpp . the generated api documentation is here: api/rclcpp/index.html the rclpy package ï the ros client library for python ( rclpy ) is the python counterpart to the c++ client library. like the c++ client library, rclpy also builds on top of the rcl c api for its implementation. the interface provides an idiomatic python experience that uses native python types and patterns like lists and context objects. by using the rcl api in the implementation, it stays consistent with the other client libraries in  of feature parity and behavior. in addition to providing python idiomatic bindings around the rcl api and python classes for each message, the python client library takes care of the execution model, using threading.thread or similar to run the functions in the rcl api . like c++ it generates custom python code for each ros message that the user interacts with, but unlike c++ it eventually converts the native python message object into the c version of the message. all operations happen on the python version of the messages until they need to be passed into the rcl layer, at which point they are converted into the plain c version of the message so it can be passed into the rcl c api . this is avoided if possible when communicating between publishers and s in the same process to cut down on the conversion into and out of python. the rclpy repository is located on github at ros2/rclpy and contains the package rclpy . the generated api documentation is here: api/rclpy/index.html community-maintained ï while the c++ and python client libraries are maintained by the core ros 2 team, members of the ros 2 community maintain additional client libraries: c rclc does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in c. see micro.ros.org for tutorials. jvm and android java and android bindings for ros 2. .net core, uwp and c# this is a collection of projects (bindings, code generator, examples and more) for writing ros 2 applications for .net core and .net standard. node.js rclnodejs is a node.js client for ros 2. it provides a simple and easy javascript api for ros 2 programming. rust this is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ros 2 applications in rust. older, unmaintained client libraries are: ada c# objective c and ios zig common functionality: rcl ï most of the functionality found in a client library is not specific to the programming language of the client library. for example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ros client library (rcl) interface that implements logic and behavior of ros concepts that is not language-specific. as a result, client libraries only need to wrap the common functionality in the rcl with foreign function interfaces. this keeps client libraries thinner and easier to develop. for this reason the common rcl functionality is exposed with c interfaces as the c language is typically the easiest language for client libraries to wrap. in addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. if any changes are made to the logic/behavior of the functionality in the core rcl â namespaces, for example â all client libraries that use the rcl will have these changes reflected. furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes. the api documentation for rcl can be found here . language-specific functionality ï client library concepts that require language-specific features/properties are not implemented in the rcl but instead are implemented in each client library. for example, threading models used by âspinâ functions will have implementations that are specific to the language of the client library. demo ï for a walkthrough of the message exchange between a publisher using rclpy and a  using rclcpp , we encourage you to watch this roscon talk starting at 17:25 ( see the slides here ). comparison to ros 1 ï in ros 1, all client libraries are developed âfrom the ground upâ. this allows for the ros 1 python client library to be implemented purely in python, for example, which brings benefits of such as not needing to compile code. however, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. udpros). summary ï by utilizing the common core ros client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling