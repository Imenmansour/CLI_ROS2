the ros 2 project contributing code style and language versions edit on github code style and language versions ï in order to achieve a consistent looking product we will all follow externally (if possible) defined style guidelines for each language. for other things like package layout or documentation layout we will need to come up with our own guidelines, drawing on current, popular styles in use now. additionally, wherever possible, developers should use integrated tools to allow them to check that these guidelines are followed in their editors. for example, everyone should have a pep8 checker built into their editor to cut down on review iterations related to style. also where possible, packages should check style as part of their unit tests to help with the automated detection of style issues (see ament_lint_auto ). c ï standard ï we will target c99. style ï we will use pythonâs pep7 for our c style guide, with some modifications and additions: we will target c99, as we do not need to support c89 (as pep7 recommends) rationale: among other things it allows us to use both // and /* */ style comments rationale: c99 is pretty much ubiquitous now c++ style // comments are allowed (optional) always place literals on the left-hand side of comparison operators, e.g. 0 == ret instead of ret == 0 rationale: ret == 0 too easily turns into ret = 0 by accident optional because when using -wall (or equivalent) modern compilers will warn you when this happens all of the following modifications only apply if we are not writing python modules: do not use py_ as a prefix for everything instead use a camelcase version of the package name or other appropriate prefix the stuff  documentation strings doesnât apply we can use the pep7 python module for style checking. the editor integration seems slim, we may need to look into automated checking for c in more detail. c++ ï standard ï jazzy targets c++17. style ï we will use the google c++ style guide , with some modifications: line length ï our maximum line length is 100 characters. file extensions ï header files should use the .hpp extension. rationale: allow tools to determine content of files, c++ or c. implementation files should use the .cpp extension. rationale: allow tools to determine content of files, c++ or c. variable naming ï for global variables use lowercase with underscores prefixed with g_ rationale: keep variable naming case consistent across the project rationale: easy to tell the scope of a variable at a glance consistency across languages function and method naming ï google style guide says camelcase , but the c++ std libraryâs style of snake_case is also allowed rationale: ros 2 core packages currently use snake_case reason: either an historical oversight or a personal preference that didnât get checked by the linter reason for not changing: retroactively changing would be too disruptive other considerations: cpplint.py does not check this case (hard to enforce other than with review) snake_case can result in more consistency across languages specific guidance: for existing projects, prefer the existing style for new projects, either is acceptable, but a preference for matching related existing projects is advised final decision is always developer discretion special cases like function pointers, callable types, etc. may require bending the rules note that classes should still use camelcase by default access control ï drop requirement for all class members to be private and therefore require accessors rationale: this is overly constraining for user api design we should prefer private members, only making them public when they are needed we should consider using accessors before choosing to allow direct member access we should have a good reason for allowing direct member access, other than because it is convenient for us exceptions ï exceptions are allowed rationale: this is a new codebase, so the legacy argument doesnât apply to us rationale: for user-facing apiâs it is more idiomatic c++ to have exceptions exceptions in destructors should be explicitly avoided we should consider avoiding exceptions if we intend to wrap the resulting api in c rationale: it will make it easier to wrap in c rationale: most of our dependencies in code we intend to wrap in c do not use exceptions anyways function-like objects ï no restrictions on lambdaâs or std::function or std::bind boost ï boost should be avoided unless absolutely required. comments and doc comments ï use /// and /** */ comments for documentation purposes and // style comments for notes and general comments class and function comments should use /// and /** */ style comments rationale: these are recommended for doxygen and sphinx in c/c++ rationale: mixing /* */ and // is convenient for block commenting out code which contains comments descriptions of how the code works or notes within classes and functions should use // style comments pointer syntax alignment ï use char * c; instead of char* c; or char *c; because of this scenario char* c, *d, *e; class  keywords ï do not put 1 space before public: , private: , or protected: , it is more consistent for all indentions to be a multiple of 2 rationale: most editors donât like indentions which are not a multiple of the (soft) tab size use zero spaces before public: , private: , or protected: , or 2 spaces if you use 2 spaces before, indent other class statements by 2 additional spaces prefer zero spaces, i.e. public: , private: , or protected: in the same column as the class nested templates ï never add whitespace to nested templates prefer set<list<string>> (c++11 feature) to set<list<string> > or set< list<string> > always use braces ï always use braces following if , else , do , while , and for , even when the body is a single line. rationale: less opportunity for visual ambiguity and for complications due to use of macros in the body open versus cuddled braces ï use open braces for function , class , enum , and struct definitions, but cuddle braces on if , else , while , for , etcâ exception: when an if (or while , etc.) condition is long enough to require line-wrapping, then use an open brace (i.e., donât cuddle). when a function call cannot fit on one line, wrap at the open parenthesis (not in between arguments) and start them on the next line with a 2-space indent. continue with the 2-space indent on subsequent lines for more arguments. (note that the google style guide is internally contradictory on this point.) same goes for if (and while , etc.) conditions that are too long to fit on one line. examples ï this is ok: int main ( int argc , char ** argv ) { if ( condition ) { return 0 ; } else { return 1 ; } } if ( this && that || both ) { ... } // long condition; open brace if ( this && that || both && this && that || both && this && that || both && this && that ) { ... } // short function call call_func ( foo , bar ); // long function call; wrap at the open parenthesis call_func ( foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar , foo , bar ); // very long function argument; separate it for readability call_func ( bang , fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo , bar , bat ); this is not ok: int main ( int argc , char ** argv ) { return 0 ; } if ( this && that || both ) { ... } use open braces rather than excessive indention, e.g. for distinguishing constructor code from constructor initializer lists this is ok: returntype longclassname::reallyreallyreallylongfunctionname ( type par_name1 , // 2 space indent type par_name2 , type par_name3 ) { dosomething (); // 2 space indent ... } myclass :: myclass ( int var ) : some_var_ ( var ), some_other_var_ ( var + 1 ) { ... dosomething (); ... } this is not ok, even weird (the google way?): returntype longclassname::reallyreallyreallylongfunctionname ( type par_name1 , // 4 space indent type par_name2 , type par_name3 ) { dosomething (); // 2 space indent ... } myclass :: myclass ( int var ) : some_var_ ( var ), // 4 space indent some_other_var_ ( var + 1 ) { // lined up ... dosomething (); ... } linters ï we check these styles with a combination of googleâs cpplint.py and uncrustify . we provide command line tools with custom configurations: ament_clang_format : configuration ament_cpplint ament_uncrustify : configuration some formatters such as ament_uncrustify and ament_clang_format support --reformat options to apply changes in place. we also run other tools to detect and eliminate as many warnings as possible. hereâs a non-exhaustive list of additional things we try to do on all of our packages: use compiler flags like -wall -wextra -wpedantic run static code analysis like cppcheck , which we have integrated in ament_cppcheck . python ï version ï we will target python 3 for our development. style ï we will use the pep8 guidelines for code format. we chose the following more precise rule where pep 8 leaves some freedom: we allow up to 100 characters per line (fifth paragraph) . we pick single quotes over double quotes as long as no escaping is necessary . we prefer hanging indents for continuation lines . tools like the (ament_)pycodestyle python package should be used in unit-test and/or editor integration for checking python code style. the pycodestyle configuration used in the linter is here . integration with editors: atom: https://atom.io/packages/linter-pycodestyle emacs: https://www.emacswiki.org/emacs/pythonprogramminginemacs sublime text: https://sublime.wbond.net/packages/sublimelinter-flake8 vim: https://github.com/nvie/vim-flake8 cmake ï version ï we will target cmake 3.8. style ï since there is not an existing cmake style guide we will define our own: use lowercase command names ( find_package , not find_package ). use snake_case identifiers (variables, functions, macros). use empty else() and end...() commands. no whitespace before ( âs. use two spaces of indention, do not use tabs. do not use aligned indentation for parameters of multi-line macro invocations. use two spaces only. prefer functions with set(parent_scope) to macros. when using macros prefix local variables with _ or a reasonable prefix. markdown / restructured text / docblocks ï style ï the following rules to format text is intended to increase readability as well as versioning. [.md, .rst only] each section title should be preceded by one empty line and succeeded by one empty line. rationale: it expedites to get an overview  the structure when screening the document. [.rst only] in restructured text the headings should follow the hierarchy described in the sphinx style guide : # with overline (only once, used for the document title) * with overline = - ^ " rationale: a consistent hierarchy expedites getting an idea  the nesting level when screening the document. [.md only] in markdown the headings should follow the atx-style described in the markdown syntax documentation atx-style headers use 1-6 hash characters ( # ) at the start of the line to denote header levels 1-6. a space between the hashes and the header title should be used (such as # heading 1 ) to make it easier to visually separate them. justification for the atx-style preference comes from the google markdown style guide rationale: atx-style headers are easier to search and maintain, and make the first two header levels consistent with the other levels. [any] each sentence must start on a new line. rationale: for longer paragraphs a single change in the beginning makes the diff unreadable since it carries forward through the whole paragraph. [any] each sentence can optionally be wrapped to keep each line short. [any] the lines should not have any trailing white spaces. [.md, .rst only] a code block must be preceded and succeeded by an empty line. rationale: whitespace is significant only directly before and directly after fenced code blocks. following these instructions will ensure that highlighting works properly and consistently. [.md, .rst only] a code block should specify a syntax (e.g. bash ). other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling