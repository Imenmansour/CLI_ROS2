concepts intermediate concepts logging and logger configuration edit on github logging and logger configuration ï overview ï the logging subsystem in ros 2 aims to deliver logging messages to a variety of targets, including: to the console (if one is attached) to log files on disk (if local storage is available) to the /rosout topic on the ros 2 network by default, log messages in ros 2 nodes will go out to the console (on stderr), to log files on disk, and to the /rosout topic on the ros 2 network. all of the targets can be individually enabled or disabled on a per-node basis. the rest of this document will go over some of the ideas behind the logging subsystem. severity level ï log messages have a severity level associated with them: debug , info , warn , error or fatal , in ascending order. a logger will only process log messages with severity at or higher than a specified level chosen for the logger. each node has a logger associated with it that automatically includes the nodeâs name and namespace. if the nodeâs name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name. non-node loggers can also be created that use a specific name. logger names represent a hierarchy. if the level of a logger named âabc.defâ is unset, it will defer to the level of its parent named âabcâ, and if that level is also unset, the default logger level will be used. when the level of logger âabcâ is changed, all of its descendants (e.g. âabc.defâ, âabc.ghi.jklâ) will have their level impacted unless their level has been explicitly set. apis ï these are the apis that end users of the ros 2 logging infrastructure should use, split up by client library. c++ python rclcpp_{debug,info,warn,error,fatal} - output the given printf-style message every time this line is hit rclcpp_{debug,info,warn,error,fatal}_once - output the given printf-style message only the first time this line is hit rclcpp_{debug,info,warn,error,fatal}_expression - output the given printf-style message only if the given expression is true rclcpp_{debug,info,warn,error,fatal}_function - output the given printf-style message only if the given function returns true rclcpp_{debug,info,warn,error,fatal}_skipfirst - output the given printf-style message all but the first time this line is hit rclcpp_{debug,info,warn,error,fatal}_throttle - output the given printf-style message no more than the given rate in integer milliseconds rclcpp_{debug,info,warn,error,fatal}_skipfirst_throttle - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first rclcpp_{debug,info,warn,error,fatal}_stream - output the given c++ stream-style message every time this line is hit rclcpp_{debug,info,warn,error,fatal}_stream_once - output the given c++ stream-style message only the first time this line is hit rclcpp_{debug,info,warn,error,fatal}_stream_expression - output the given c++ stream-style message only if the given expression is true rclcpp_{debug,info,warn,error,fatal}_stream_function - output the given c++ stream-style message only if the given function returns true rclcpp_{debug,info,warn,error,fatal}_stream_skipfirst - output the given c++ stream-style message all but the first time this line is hit rclcpp_{debug,info,warn,error,fatal}_stream_throttle - output the given c++ stream-style message no more than the given rate in integer milliseconds rclcpp_{debug,info,warn,error,fatal}_stream_skipfirst_throttle - output the given c++ stream-style message no more than the given rate in integer milliseconds, but skip the first each of the above apis takes an rclcpp::logger object as the first argument. this can be pulled from the node api by calling node->get_logger() (recommended), or by constructing a stand-alone rclcpp::logger object. rcutils_logging_set_logger_level - set the logging level for a particular logger name to the given severity level rcutils_logging_get_logger_effective_level - given a logger name, return the logger level (which may be unset) logger.{debug,info,warning,error,fatal} - output the given python string to the logging infrastructure. the calls accept the following keyword args to control behavior: throttle_duration_sec - if not none, the duration of the throttle interval in floating-point seconds skip_first - if true, output the message all but the first time this line is hit once - if true, only output the message the first time this line is hit rclpy.logging.set_logger_level - set the logging level for a particular logger name to the given severity level rclpy.logging.get_logger_effective_level - given a logger name, return the logger level (which may be unset) configuration ï since rclcpp and rclpy use the same underlying logging infrastructure, the configuration options are the same. environment variables ï the following environment variables control some aspects of the ros 2 loggers. for each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process. ros_log_dir - control the logging directory that is used for writing logging messages to disk (if that is enabled). if non-empty, use the exact directory as specified in this variable. if empty, use the contents of the ros_home environment variable to construct a path of the form ros_home/.log . in all cases, the ~ character is expanded to the userâs home directory. ros_home - control the home directory that is used for various ros files, including logging and config files. in the context of logging, this variable is used to construct a path to a directory for log files. if non-empty, use the contents of this variable for the ros_home path. in all cases, the ~ character is expanded to the usersâs home directory. rcutils_logging_use_stdout - control what stream output messages go to. if this is unset or 0, use stderr. if this is 1, use stdout. rcutils_logging_buffered_stream - control whether the logging stream (as configured in rcutils_logging_use_stdout ) should be line buffered or unbuffered. if this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr). if this is 0, force the stream to be unbuffered. if this is 1, force the stream to be line buffered. rcutils_colorized_output - control whether colors are used when outputting messages. if unset, automatically determine based on the platform and whether the console is a tty. if 0, force disable using colors for output. if 1, force enable using colors for output. rcutils_console_output_format - control the fields that are output for each log message. the available fields are: {severity} - the severity level. {name} - the name of the logger (may be empty). {message} - the log message (may be empty). {function_name} - the function name this was called from (may be empty). {file_name} - the file name this was called from (may be empty). {time} - the time in seconds since the epoch. {time_as_nanoseconds} - the time in nanoseconds since the epoch. {date_time_with_ms} - the time in iso format, e.g. 2024-06-11 09:29:19.304 {line_number} - the line number this was called from (may be empty). if no format is given, a default of [{severity}] [{time}] [{name}]: {message} is used. rcutils_console_output_format also supports the following escape character syntax. escape character syntax character represented \a alert \b backspace \n new line \r carriage return \t horizontal tab node creation ï when initializing a ros 2 node, it is possible to control some aspects of the behavior via node options. since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process. log_levels - the log level to use for a component within this particular node. this can be set with the following: ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=debug external_log_config_file - the external file to use to configure the backend logger. if it is null, the default configuration will be used. note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog). this can be set with the following: ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt log_stdout_disabled - whether to disable writing log messages to the console. this can be done with the following: ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs log_rosout_disabled - whether to disable writing log messages out to /rosout . this can significantly save on network bandwidth, but external observers will not be able to monitor logging. this can be done with the following: ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs log_ext_lib_disabled - whether to completely disable the use of an external logger. this may be faster in some cases, but means that logs will not be written to disk. this can be done with the following: ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs logging subsystem design ï the image below shows the five main pieces to the logging subsystem and how they interact. rcutils ï rcutils has a logging implementation that can format log messages according to a certain format (see configuration above), and output those log messages to a console. rcutils implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model. this will become more evident when we talk  the rcl layer below. note that this is a per-process logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes. rcl_logging_spdlog ï rcl_logging_spdlog implements the rcl_logging_interface api, and thus provides external logging services to the rcl layer. in particular, the rcl_logging_spdlog implementation takes formatted log messages and writes them out to log files on disk using the spdlog library, typically within ~/.ros/log (though this is configurable; see configuration above). rcl ï the logging subsystem in rcl uses rcutils and rcl_logging_spdlog to provide the bulk of the ros 2 logging services. when log messages come in, rcl decides where to send them. there are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled: to the console via the rcutils layer to disk via the rcl_logging_spdlog layer to the /rosout topic on the ros 2 network via the rmw layer rclcpp ï this is the main ros 2 c++ api which sits atop the rcl api. in the context of logging, rclcpp provides the rclcpp_ logging macros; see apis above for a complete list. when one of the rclcpp_ macros runs, it checks the current severity level of the node against the severity level of the macro. if the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. note that rclcpp uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded. rclpy ï this is the main ros 2 python api which sits atop the rcl api. in the context of logging, rclpy provides the logger.debug -style functions; see apis above for a complete list. when one of the logger.debug functions runs, it checks the current severity level of the node against the severity level of the macro. if the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. logging usage ï c++ python see the rclcpp logging demo for some simple examples. see the logging demo for example usage. see the rclpy examples for example usage of a nodeâs logger. see the rclpy tests for example usage of keyword arguments (e.g. skip_first , once ). other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling