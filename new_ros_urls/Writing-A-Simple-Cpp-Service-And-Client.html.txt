tutorials beginner: client libraries writing a simple service and client (c++) edit on github writing a simple service and client (c++) ï goal: create and run service and client nodes using c++. tutorial level: beginner time: 20 minutes background ï when nodes communicate using services , the node that sends a request for data is called the client node, and the one that responds to the request is the service node. the structure of the request and response is determined by a .srv file. the example used here is a simple integer addition system; one node requests the sum of two integers, and the other responds with the result. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate into the ros2_ws directory created in a previous tutorial . recall that packages should be created in the src directory, not the root of the workspace. navigate into ros2_ws/src and create a new package: ros2 pkg create --build-type ament_cmake --license apache-2.0 cpp_srvcli --dependencies rclcpp example_interfaces your terminal will return a message verifying the creation of your package cpp_srvcli and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml and cmakelists.txt . example_interfaces is the package that includes the .srv file you will need to structure your requests and responses: int64 a int64 b --- int64 sum the first two lines are the parameters of the request, and below the dashes is the response. 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml or cmakelists.txt . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> c++ client server tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 2 write the service node ï inside the ros2_ws/src/cpp_srvcli/src directory, create a new file called add_two_ints_server.cpp and paste the following code within: #include "rclcpp/rclcpp.hpp" #include "example_interfaces/srv/add_two_ints.hpp" #include <memory> void add ( const std :: shared_ptr < example_interfaces :: srv :: addtwoints :: request > request , std :: shared_ptr < example_interfaces :: srv :: addtwoints :: response > response ) { response -> sum = request -> a + request -> b ; rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "incoming request \n a: %ld" " b: %ld" , request -> a , request -> b ); rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "sending back response: [%ld]" , ( long int ) response -> sum ); } int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_two_ints_server" ); rclcpp :: service < example_interfaces :: srv :: addtwoints >:: sharedptr service = node -> create_service < example_interfaces :: srv :: addtwoints > ( "add_two_ints" , & add ); rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "ready to add two ints." ); rclcpp :: spin ( node ); rclcpp :: shutdown (); } 2.1 examine the code ï the first two #include statements are your package dependencies. the add function adds two integers from the request and gives the sum to the response, while notifying the console of its status using logs. void add ( const std :: shared_ptr < example_interfaces :: srv :: addtwoints :: request > request , std :: shared_ptr < example_interfaces :: srv :: addtwoints :: response > response ) { response -> sum = request -> a + request -> b ; rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "incoming request \n a: %ld" " b: %ld" , request -> a , request -> b ); rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "sending back response: [%ld]" , ( long int ) response -> sum ); } the main function accomplishes the following, line by line: initializes ros 2 c++ client library: rclcpp :: init ( argc , argv ); creates a node named add_two_ints_server : std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_two_ints_server" ); creates a service named add_two_ints for that node and automatically advertises it over the networks with the &add method: rclcpp :: service < example_interfaces :: srv :: addtwoints >:: sharedptr service = node -> create_service < example_interfaces :: srv :: addtwoints > ( "add_two_ints" , & add ); prints a log message when itâs ready: rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "ready to add two ints." ); spins the node, making the service available. rclcpp :: spin ( node ); 2.2 add executable ï the add_executable macro generates an executable you can run using ros2 run . add the following code block to cmakelists.txt to create an executable named server : add_executable(server src/add_two_ints_server.cpp) ament_target_dependencies(server rclcpp example_interfaces) so ros2 run can find the executable, add the following lines to the end of the file, right before ament_package() : install(targets server destination lib/{project_name}) you could build your package now, source the local setup files, and run it, but letâs create the client node first so you can see the full system at work. 3 write the client node ï inside the ros2_ws/src/cpp_srvcli/src directory, create a new file called add_two_ints_client.cpp and paste the following code within: #include "rclcpp/rclcpp.hpp" #include "example_interfaces/srv/add_two_ints.hpp" #include <chrono> #include <cstdlib> #include <memory> using namespace std :: chrono_literals ; int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); if ( argc != 3 ) { rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "usage: add_two_ints_client x y" ); return 1 ; } std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_two_ints_client" ); rclcpp :: client < example_interfaces :: srv :: addtwoints >:: sharedptr client = node -> create_client < example_interfaces :: srv :: addtwoints > ( "add_two_ints" ); auto request = std :: make_shared < example_interfaces :: srv :: addtwoints :: request > (); request -> a = atoll ( argv [ 1 ]); request -> b = atoll ( argv [ 2 ]); while ( ! client -> wait_for_service ( 1 s )) { if ( ! rclcpp :: ok ()) { rclcpp_error ( rclcpp :: get_logger ( "rclcpp" ), "interrupted while waiting for the service. exiting." ); return 0 ; } rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "service not available, waiting again..." ); } auto result = client -> async_send_request ( request ); // wait for the result. if ( rclcpp :: spin_until_future_complete ( node , result ) == rclcpp :: futurereturncode :: success ) { rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "sum: %ld" , result . get () -> sum ); } else { rclcpp_error ( rclcpp :: get_logger ( "rclcpp" ), "failed to call service add_two_ints" ); } rclcpp :: shutdown (); return 0 ; } 3.1 examine the code ï similar to the service node, the following lines of code create the node and then create the client for that node: std :: shared_ptr < rclcpp :: node > node = rclcpp :: node :: make_shared ( "add_two_ints_client" ); rclcpp :: client < example_interfaces :: srv :: addtwoints >:: sharedptr client = node -> create_client < example_interfaces :: srv :: addtwoints > ( "add_two_ints" ); next, the request is created. its structure is defined by the .srv file mentioned earlier. auto request = std :: make_shared < example_interfaces :: srv :: addtwoints :: request > (); request -> a = atoll ( argv [ 1 ]); request -> b = atoll ( argv [ 2 ]); the while loop gives the client 1 second to search for service nodes in the network. if it canât find any, it will continue waiting. rclcpp_info ( rclcpp :: get_logger ( "rclcpp" ), "service not available, waiting again..." ); if the client is canceled (e.g. by you entering ctrl+c into the terminal), it will return an error log message stating it was interrupted. rclcpp_error ( rclcpp :: get_logger ( "rclcpp" ), "interrupted while waiting for the service. exiting." ); then the client sends its request, and the node spins until it receives its response, or fails. 3.2 add executable ï return to cmakelists.txt to add the executable and target for the new node. after removing some unnecessary boilerplate from the automatically generated file, your cmakelists.txt should look like this: cmake_minimum_required(version 3.5) project(cpp_srvcli) find_package(ament_cmake required) find_package(rclcpp required) find_package(example_interfaces required) add_executable(server src/add_two_ints_server.cpp) ament_target_dependencies(server rclcpp example_interfaces) add_executable(client src/add_two_ints_client.cpp) ament_target_dependencies(client rclcpp example_interfaces) install(targets server client destination lib/{project_name}) ament_package() 4 build and run ï itâs good practice to run rosdep in the root of your workspace ( ros2_ws ) to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you can skip ahead to next step. rosdep only runs on linux, so you can skip ahead to next step. navigate back to the root of your workspace, ros2_ws , and build your new package: linux macos windows colcon build --packages-select cpp_srvcli colcon build --packages-select cpp_srvcli colcon build --merge-install --packages-select cpp_srvcli open a new terminal, navigate to ros2_ws , and source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the service node: ros2 run cpp_srvcli server the terminal should return the following message, and then wait: [info] [rclcpp]: ready to add two ints. open another terminal, source the setup files from inside ros2_ws again. start the client node, followed by any two integers separated by a space: ros2 run cpp_srvcli client 2 3 if you chose 2 and 3 , for example, the client would receive a response like this: [info] [rclcpp]: sum: 5 return to the terminal where your service node is running. you will see that it published log messages when it received the request and the data it received, and the response it sent back: [info] [rclcpp]: incoming request a: 2 b: 3 [info] [rclcpp]: sending back response: [5] enter ctrl+c in the server terminal to stop the node from spinning. summary ï you created two nodes to request and respond to data over a service. you added their dependencies and executables to the package configuration files so that you could build and run them, and see a service/client system at work. next steps ï in the last few tutorials youâve been utilizing interfaces to pass data across topics and services. next, youâll learn how to create custom interfaces . related content ï there are several ways you could write a service and client in c++; check out the minimal_service and minimal_client packages in the ros2/examples repo. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling