tutorials beginner: cli tools understanding services edit on github understanding services ï goal: learn  services in ros 2 using command line tools. tutorial level: beginner time: 10 minutes background ï services are another method of communication for nodes in the ros graph. services are based on a call-and-response model versus the publisher-subscriber model of topics. while topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. prerequisites ï some concepts mentioned in this tutorial, like nodes and topics , were covered in previous tutorials in the series. you will need the turtlesim package . as always, donât forget to source ros 2 in every new terminal you open . tasks ï 1 setup ï start up the two turtlesim nodes, /turtlesim and /teleop_turtle . open a new terminal and run: ros2 run turtlesim turtlesim_node open another terminal and run: ros2 run turtlesim turtle_teleop_key 2 ros2 service list ï running the ros2 service list command in a new terminal will return a list of all the services currently active in the system: /clear /kill /reset /spawn /teleop_turtle/describe_parameters /teleop_turtle/get_parameter_types /teleop_turtle/get_parameters /teleop_turtle/list_parameters /teleop_turtle/set_parameters /teleop_turtle/set_parameters_atomically /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/describe_parameters /turtlesim/get_parameter_types /turtlesim/get_parameters /turtlesim/list_parameters /turtlesim/set_parameters /turtlesim/set_parameters_atomically you will see that both nodes have the same six services with parameters in their names. nearly every node in ros 2 has these infrastructure services that parameters are built off of. there will be more  parameters in the next tutorial. in this tutorial, the parameter services will be omitted from the discussion. for now, letâs focus on the turtlesim-specific services, /clear , /kill , /reset , /spawn , /turtle1/set_pen , /turtle1/teleport_absolute , and /turtle1/teleport_relative . you may recall interacting with some of these services using rqt in the use turtlesim, ros2, and rqt tutorial. 3 ros2 service type ï services have types that describe how the request and response data of a service is structured. service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response. to find out the type of a service, use the command: ros2 service type <service_name> letâs take a look at turtlesimâs /clear service. in a new terminal, enter the command: ros2 service type /clear which should return: std_srvs/srv/empty the empty type means the service call sends no data when making a request and receives no data when receiving a response. 3.1 ros2 service list -t ï to see the types of all the active services at the same time, you can append the --show-types option, abbreviated as -t , to the list command: ros2 service list -t which will return: /clear [std_srvs/srv/empty] /kill [turtlesim/srv/kill] /reset [std_srvs/srv/empty] /spawn [turtlesim/srv/spawn] ... /turtle1/set_pen [turtlesim/srv/setpen] /turtle1/teleport_absolute [turtlesim/srv/teleportabsolute] /turtle1/teleport_relative [turtlesim/srv/teleportrelative] ... 4 ros2 service info ï to see information of a particular service, use the command: ros2 service info <service_name> this returns the service type and the count of service clients and servers. for example, you can find the count of clients and servers for the /clear service: ros2 service info /clear which will return: type: std_srvs/srv/empty clients count: 0 services count: 1 5 ros2 service find ï if you want to find all the services of a specific type, you can use the command: ros2 service find <type_name> for example, you can find all the empty typed services like this: ros2 service find std_srvs/srv/empty which will return: /clear /reset 6 ros2 interface show ï you can call services from the command line, but first you need to know the structure of the input arguments. ros2 interface show <type_name> try this on the /clear serviceâs type, empty : ros2 interface show std_srvs/srv/empty which will return: --- the --- separates the request structure (above) from the response structure (below). but, as you learned earlier, the empty type doesnât send or receive any data. so, naturally, its structure is blank. letâs introspect a service with a type that sends and receives data, like /spawn . from the results of ros2 service list -t , we know /spawn âs type is turtlesim/srv/spawn . to see the request and response arguments of the /spawn service, run the command: ros2 interface show turtlesim/srv/spawn which will return: float32 x float32 y float32 theta string name # optional. a unique name will be created and returned if this is empty --- string name the information above the --- line tells us the arguments needed to call /spawn . x , y and theta determine the 2d pose of the spawned turtle, and name is clearly optional. the information below the line isnât something you need to know in this case, but it can help you understand the data type of the response you get from the call. 7 ros2 service call ï now that you know what a service type is, how to find a serviceâs type, and how to find the structure of that typeâs arguments, you can call a service using: ros2 service call <service_name> <service_type> <arguments> the <arguments> part is optional. for example, you know that empty typed services donât have any arguments: ros2 service call /clear std_srvs/srv/empty this command will clear the turtlesim window of any lines your turtle has drawn. now letâs spawn a new turtle by calling /spawn and setting arguments. input <arguments> in a service call from the command-line need to be in yaml syntax. enter the command: ros2 service call /spawn turtlesim/srv/spawn "{x: 2, y: 2, theta: 0.2, name: ''}" you will get this method-style view of whatâs happening, and then the service response: requester: making request: turtlesim.srv.spawn_request(x=2.0, y=2.0, theta=0.2, name='') response: turtlesim.srv.spawn_response(name='turtle2') your turtlesim window will update with the newly spawned turtle right away: 8 ros2 service echo ï to see the data communication between a service client and a service server you can echo the service using: ros2 service echo <service_name | service_type> <arguments> ros2 service echo depends on service introspection of a service client and server, that is disabled by default. to enable it, users must call configure_introspection after creating a server client or server. start up the introspection_client and introspection_service service introspection demo. ros2 launch demo_nodes_cpp introspect_services_launch.py open another terminal and run the following to enable service introspection for introspection_client and introspection_service . ros2 param set /introspection_service service_configure_introspection contents ros2 param set /introspection_client client_configure_introspection contents now we are able to see the service communication between introspection_client and introspection_service via ros2 service echo . ros2 service echo --flow-style /add_two_ints info: event_type: request_sent stamp: sec: 1709408301 nanosec: 423227292 client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 21, 3] sequence_number: 618 request: [{a: 2, b: 3}] response: [] --- info: event_type: request_received stamp: sec: 1709408301 nanosec: 423601471 client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 20, 4] sequence_number: 618 request: [{a: 2, b: 3}] response: [] --- info: event_type: response_sent stamp: sec: 1709408301 nanosec: 423900744 client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 20, 4] sequence_number: 618 request: [] response: [{sum: 5}] --- info: event_type: response_received stamp: sec: 1709408301 nanosec: 424153133 client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 21, 3] sequence_number: 618 request: [] response: [{sum: 5}] --- summary ï nodes can communicate using services in ros 2. unlike a topic - a one way communication pattern where a node publishes information that can be consumed by one or more subscribers - a service is a request/response pattern where a client makes a request to a node providing the service and the service processes the request and generates a response. you generally donât want to use a service for continuous calls; topics or even actions would be better suited. in this tutorial you used command line tools to identify, introspect, and call services. next steps ï in the next tutorial, understanding parameters , you will learn  configuring node settings. related content ï check out this tutorial ; itâs an excellent realistic application of ros services using a robotis robot arm. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling