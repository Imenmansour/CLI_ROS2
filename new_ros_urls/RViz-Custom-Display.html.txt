tutorials intermediate rviz building a custom rviz display edit on github building a custom rviz display ï background ï there are many types of data that have existing visualizations in rviz. however, if there is a message type that does not yet have a plugin to display it, there are two choices to see it in rviz. convert the message to another type, such as visualization_msgs/marker . write a custom rviz display. with the first option, there is more network traffic and limitations to how the data can be represented. it is also quick and flexible. the latter option is explained in this tutorial. it takes a bit of work, but can lead to much richer visualizations. all of the code for this tutorial can be found in this repository . in order to see the incremental progress of the plugin written in this tutorial, the repository has different branches ( step2 , step3 â) that can each be compiled and run as you go. point2d message ï weâll be playing with a toy message defined in the rviz_plugin_tutorial_msgs package: point2d.msg : std_msgs / header header float64 x float64 y boilerplate for basic plugin ï strap in, thereâs a lot of code. you can view the full version of this code with the branch name step1 . header file ï here are the contents of point_display.hpp #ifndef rviz_plugin_tutorial__point_display_hpp_ #define rviz_plugin_tutorial__point_display_hpp_ #include <rviz_common/message_filter_display.hpp> #include <rviz_plugin_tutorial_msgs/msg/point2_d.hpp> namespace rviz_plugin_tutorial { class pointdisplay : public rviz_common :: messagefilterdisplay < rviz_plugin_tutorial_msgs :: msg :: point2d > { q_object protected : void processmessage ( const rviz_plugin_tutorial_msgs :: msg :: point2d :: constsharedptr msg ) override ; }; } // namespace rviz_plugin_tutorial #endif // rviz_plugin_tutorial__point_display_hpp_ weâre implementing the messagefilterdisplay class which can be used with any message with a std_msgs/header . the class is templated with our point2d message type. for reasons outside the scope of this tutorial , you need the q_object macro in there to get the qt parts of the gui to work. processmessage is the only method that needs to be implemented, which weâll do in the cpp file. source file ï point_display.cpp #include <rviz_plugin_tutorial/point_display.hpp> #include <rviz_common/logging.hpp> namespace rviz_plugin_tutorial { void pointdisplay::processmessage ( const rviz_plugin_tutorial_msgs :: msg :: point2d :: constsharedptr msg ) { rviz_common_log_info_stream ( "we got a message with frame " << msg -> header . frame_id ); } } // namespace rviz_plugin_tutorial #include <pluginlib/class_list_macros.hpp> pluginlib_export_class ( rviz_plugin_tutorial :: pointdisplay , rviz_common :: display ) the logging is not strictly necessary, but helps with debugging. in order for rviz to find our plugin, we need this pluginlib invocation in our code (as well as other things below). package.xml ï we need the following three dependencies in our package.xml: <depend> pluginlib </depend> <depend> rviz_common </depend> <depend> rviz_plugin_tutorial_msgs </depend> rviz_common_plugins.xml ï <library path= "point_display" > <class type= "rviz_plugin_tutorial::pointdisplay" base_class_type= "rviz_common::display" > <description></description> </class> </library> this is standard pluginlib code. the library path is the name of the library weâll as the cmake. the class should match the pluginlib invocation from above. weâll come back to the description later, i promise. cmakelists.txt ï add the following lines to the top of the standard boilerplate. find_package ( ament_cmake_ros required ) find_package ( pluginlib required ) find_package ( rviz_common required ) find_package ( rviz_plugin_tutorial_msgs required ) set ( cmake_automoc on ) qt5_wrap_cpp ( moc_files include/rviz_plugin_tutorial/point_display.hpp ) add_library ( point_display src/point_display.cpp { moc_files } ) target_include_directories ( point_display public < build_interface:{cmake_current_source_dir}/include > < install_interface:include > ) ament_target_dependencies ( point_display pluginlib rviz_common rviz_plugin_tutorial_msgs ) install ( targets point_display export export_rviz_plugin_tutorial archive destination lib library destination lib runtime destination bin ) install ( directory include/ destination include ) install ( files rviz_common_plugins.xml destination share/ { project_name } ) ament_export_include_directories ( include ) ament_export_targets ( export_rviz_plugin_tutorial ) pluginlib_export_plugin_description_file ( rviz_common rviz_common_plugins.xml ) to generate the proper qt files, we need to turn cmake_automoc on. wrap the headers by calling qt5_wrap_cpp with each header that has q_object in it. include the moc_files in the library alongside our other cpp files. note that if you do not wrap your header files, you may get an error message when attempting to load the plugin at runtime, along the lines of: [rviz2]: pluginlibfactory: the plugin for class 'rviz_plugin_tutorial::pointdisplay' failed to load. error: failed to load library /home/ros/ros2_ws/install/rviz_plugin_tutorial/lib/libpoint_display.so. make sure that you are calling the pluginlib_export_class macro in the library code, and that names are consistent between this macro and your xml. error string: could not load library loadlibrary error: /home/ros/ros2_ws/install/rviz_plugin_tutorial/lib/libpoint_display.so: undefined symbol: _ztvn20rviz_plugin_tutorial12pointdisplaye, at /tmp/binarydeb/ros-foxy-rcutils-1.1.4/src/shared_library.c:84 a lot of the other code ensures that the plugin portion works. namely, calling pluginlib_export_plugin_description_file is essential to getting rviz to find your new plugin. testing it out ï compile your code and run rviz2 . you should be able to add your new plugin by clicking add in the bottom left, and then selecting your package/plugin. initially, the display will be in an error state because you have yet to assign a topic. if we put the topic /point in, it should load fine but not display anything. you can publish messages with the following command: ros2 topic pub /point rviz_plugin_tutorial_msgs/msg/point2d "{header: {frame_id: map}, x: 1, y: 2}" -r 0 .5 that should result in the âwe got a messageâ logging to appear in the stdout of rviz. actual visualization ï you can view the full version of this step with the branch name step2 . first, you need to add a dependency in cmakelists.txt and package.xml on the package rviz_rendering . we need to add three lines to the header file: #include <rviz_rendering/objects/shape.hpp> - thereâs lots of options in the rviz_rendering package for objects to build your visualization on. here weâre using a simple shape. in the class, weâll add a new protected virtual method: void oninitialize() override; we also add a pointer to our shape object: std::unique_ptr<rviz_rendering::shape> point_shape_; then in the cpp file, we define the oninitialize method: void pointdisplay::oninitialize () { mfdclass :: oninitialize (); point_shape_ = std :: make_unique < rviz_rendering :: shape > ( rviz_rendering :: shape :: type :: cube , scene_manager_ , scene_node_ ); } mfdclass is aliased to the templated parent class for convenience. the shape object must be constructed here in the oninitialize method rather than the constructor because otherwise scene_manager_ and scene_node_ would not be ready. we also update our processmessage method: void pointdisplay::processmessage ( const rviz_plugin_tutorial_msgs :: msg :: point2d :: constsharedptr msg ) { rviz_common_log_info_stream ( "we got a message with frame " << msg -> header . frame_id ); ogre :: vector3 position ; ogre :: quaternion orientation ; if ( ! context_ -> getframemanager () -> gettransform ( msg -> header , position , orientation )) { rviz_common_log_debug_stream ( "error transforming from frame '" << msg -> header . frame_id << "' to frame '" << qprintable ( fixed_frame_ ) << "'" ); } scene_node_ -> setposition ( position ); scene_node_ -> setorientation ( orientation ); ogre :: vector3 point_pos ; point_pos . x = msg -> x ; point_pos . y = msg -> y ; point_shape_ -> setposition ( point_pos ); } we need to get the proper frame for our message and transform the scene_node_ accordingly. this ensures that the visualization does not always appear relative to the fixed frame. the actual visualization that weâve been building up to is in the last four lines: we set the position of the visualization to match the messageâs position. the result should look like this: if the box does not appear in that location, it might be because: you are not publishing the topic at this time the message hasnât been published in the last 2 seconds. you did not properly set the topic in rviz. itâs nice to have options. ï if you want to allow users to customize different properties of the visualization, you need to add rviz_common::property objects . you can view the full version of this step with the branch name step3 . header updates ï include the header file for color properties: #include <rviz_common/properties/color_property.hpp> . color is but one of many properties you can set. add in the prototype for updatestyle , which is called whenever the gui is changed via qtâs signal/slot framework: private q_slots : void updatestyle (); add in a new property to store the property itself: std::unique_ptr<rviz_common::properties::colorproperty> color_property_; cpp updates ï #include <rviz_common/properties/parse_color.hpp> - contains helper function to convert property to ogre color. to our oninitialize we add color_property_ = std :: make_unique < rviz_common :: properties :: colorproperty > ( "point color" , qcolor ( 36 , 64 , 142 ), "color to draw the point." , this , slot ( updatestyle ())); updatestyle (); this constructs the object with its name, default value, description and the callback. we call updatestyle directly so that the color is set at the beginning even before the property is changed. then we define the callback. void pointdisplay::updatestyle () { ogre :: colourvalue color = rviz_common :: properties :: qttoogre ( color_property_ -> getcolor ()); point_shape_ -> setcolor ( color ); } the result should look like this: ooh, pink! status report ï you can view the full version of this step with the branch name step4 . you can also set the status of the display. as an arbitrary example, letâs make our display show a warning when the x coordinate is negative, because why not? in processmessage : if ( msg -> x < 0 ) { setstatus ( statusproperty :: warn , "message" , "i will complain  points with negative x values." ); } else { setstatus ( statusproperty :: ok , "message" , "ok" ); } weâre assuming a previous using rviz_common::properties::statusproperty; declaration. think of the status as key/value pairs, with the key being some string (here weâre using "message" ) and the values are the status level (error/warn/ok) and the description (some other string). cleanup ï now its time to clean it up a bit. this makes things look nicer and be a little easier to use, but arenât strictly required. you can view the full version of this step with the branch name step5 . first, we update the plugin declaration. <library path= "point_display" > <class name= "point2d" type= "rviz_plugin_tutorial::pointdisplay" base_class_type= "rviz_common::display" > <description> tutorial to display a point </description> <message_type> rviz_plugin_tutorial_msgs/msg/point2d </message_type> </class> </library> we add the name field to the class tag. this changes the name that is displayed in rviz. in code, it makes sense to call it a pointdisplay but in rviz, we want to simplify. we put actual text into the description. donât be lazy. by declaring the specific message type here, when you attempt to add a display by topic, it will suggest this plugin for the topics of that type. we also add an icon for the plugin at icons/classes/point2d.png . the folder is hardcoded, and the filename should match the name from the plugin declaration (or the name of the class if not specified). [icon source] we need to install the image file in the cmake. install ( files icons/classes/point2d.png destination share/ { project_name } /icons/classes ) now when you add the display, it should show up with an icon and description. here is the display when attempting to add by topic: and finally, hereâs the icon in the standard interface: note, if you change the plugins name, previous rviz configurations will no longer work. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling