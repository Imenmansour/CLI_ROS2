concepts basic concepts parameters edit on github parameters ï overview ï parameters in ros 2 are associated with individual nodes. parameters are used to configure nodes at startup (and during runtime), without changing the code. the lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart). parameters are addressed by node name, node namespace, parameter name, and parameter namespace. providing a parameter namespace is optional. each parameter consists of a key, a value, and a descriptor. the key is a string and the value is one of the following types: bool , int64 , float64 , string , byte[] , bool[] , int64[] , float64[] or string[] . by default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints. for a hands-on tutorial with ros parameters see understanding parameters . parameters background ï declaring parameters ï by default, a node needs to declare all of the parameters that it will accept during its lifetime. this is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. see using parameters in a class (c++) or using parameters in a class (python) for tutorials on declaring and using parameters from a node. for some types of nodes, not all of the parameters will be known ahead of time. in these cases, the node can be instantiated with allow_undeclared_parameters set to true , which will allow parameters to be get and set on the node even if they havenât been declared. parameter types ï each parameter on a ros 2 node has one of the pre-defined parameter types as mentioned in the overview. by default, attempts to change the type of a declared parameter at runtime will fail. this prevents common mistakes, such as putting a boolean value into an integer parameter. if a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. when the parameter is declared, it should be declared using a parameterdescriptor with the dynamic_typing member variable set to true . parameter callbacks ï a ros 2 node can register three different types of callbacks to be informed when changes are happening to parameters. all three of the callbacks are optional. the first is known as a âpre set parameterâ callback, and can be set by calling add_pre_set_parameters_callback from the node api. this callback is passed a list of the parameter objects that are being changed, and returns nothing. when it is called, it can modify the parameter list to change, add, or remove entries. as an example, if parameter2 should change anytime that parameter1 changes, that can be implemented with this callback. the second is known as a âset parameterâ callback, and can be set by calling add_on_set_parameters_callback from the node api. the callback is passed a list of immutable parameter objects, and returns an rcl_interfaces/msg/setparametersresult . the main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change. note it is important that âset parameterâ callbacks have no side-effects. since multiple âset parameterâ callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. if the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. to get a callback after a parameter has been successfully changed, see the next type of callback below. the third type of callback is known as an âpost set parameterâ callback, and can be set by calling add_post_set_parameters_callback from the node api. the callback is passed a list of immutable parameter objects, and returns nothing. the main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted. the ros 2 demos have an example of all of these callbacks in use. interacting with parameters ï ros 2 nodes can perform parameter operations through node apis as described in using parameters in a class (c++) or using parameters in a class (python) . external processes can perform parameter operations via parameter services that are created by default when a node is instantiated. the services that are created by default are: /node_name/describe_parameters : uses a service type of rcl_interfaces/srv/describeparameters . given a list of parameter names, returns a list of descriptors associated with the parameters. /node_name/get_parameter_types : uses a service type of rcl_interfaces/srv/getparametertypes . given a list of parameter names, returns a list of parameter types associated with the parameters. /node_name/get_parameters : uses a service type of rcl_interfaces/srv/getparameters . given a list of parameter names, returns a list of parameter values associated with the parameters. /node_name/list_parameters : uses a service type of rcl_interfaces/srv/listparameters . given an optional list of parameter prefixes, returns a list of the available parameters with that prefix. if the prefixes are empty, returns all parameters. /node_name/set_parameters : uses a service type of rcl_interfaces/srv/setparameters . given a list of parameter names and values, attempts to set the parameters on the node. returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed. /node_name/set_parameters_atomically : uses a service type of rcl_interfaces/srv/setparametersatomically . given a list of parameter names and values, attempts to set the parameters on the node. returns a single result from trying to set all parameters, so if one failed, all of them failed. setting initial parameter values when running a node ï initial parameter values can be set when running the node either through individual command-line arguments, or through yaml files. see setting parameters directly from the command line for examples on how to set initial parameter values. setting initial parameter values when launching nodes ï initial parameter values can also be set when running the node through the ros 2 launch facility. see this document for information on how to specify parameters via launch. manipulating parameter values at runtime ï the ros2 param command is the general way to interact with parameters for nodes that are already running. ros2 param uses the parameter service api as described above to perform the various operations. see this how-to guide for details on how to use ros2 param . migrating from ros 1 ï the launch file migration guide explains how to migrate param and rosparam launch tags from ros 1 to ros 2. the yaml parameter file migration guide explains how to migrate parameter files from ros 1 to ros 2. in ros 1, the roscore acted like a global parameter blackboard where all nodes could get and set parameters. since there is no central roscore in ros 2, that functionality no longer exists. the recommended approach in ros 2 is to use per-node parameters that are closely tied to the nodes that use them. if a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ros 2 ships with one in the ros-jazzy-demo-nodes-cpp package called parameter_blackboard ; it can be run with: ros2 run demo_nodes_cpp parameter_blackboard the code for the parameter_blackboard is here . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling