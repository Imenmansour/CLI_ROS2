tutorials beginner: client libraries writing a simple service and client (python) edit on github writing a simple service and client (python) ï goal: create and run service and client nodes using python. tutorial level: beginner time: 20 minutes background ï when nodes communicate using services , the node that sends a request for data is called the client node, and the one that responds to the request is the service node. the structure of the request and response is determined by a .srv file. the example used here is a simple integer addition system; one node requests the sum of two integers, and the other responds with the result. prerequisites ï in previous tutorials, you learned how to create a workspace and create a package . tasks ï 1 create a package ï open a new terminal and source your ros 2 installation so that ros2 commands will work. navigate into the ros2_ws directory created in a previous tutorial . recall that packages should be created in the src directory, not the root of the workspace. navigate into ros2_ws/src and create a new package: ros2 pkg create --build-type ament_python --license apache-2.0 py_srvcli --dependencies rclpy example_interfaces your terminal will return a message verifying the creation of your package py_srvcli and all its necessary files and folders. the --dependencies argument will automatically add the necessary dependency lines to package.xml . example_interfaces is the package that includes the .srv file you will need to structure your requests and responses: int64 a int64 b --- int64 sum the first two lines are the parameters of the request, and below the dashes is the response. 1.1 update package.xml ï because you used the --dependencies option during package creation, you donât have to manually add dependencies to package.xml . as always, though, make sure to add the description, maintainer  and name, and license information to package.xml . <description> python client server tutorial </description> <maintainer = "you@.com" > your name </maintainer> <license> apache-2.0 </license> 1.2 update setup.py ï add the same information to the setup.py file for the maintainer , maintainer_ , description and license fields: maintainer = 'your name' , maintainer_ = 'you@.com' , description = 'python client server tutorial' , license = 'apache-2.0' , 2 write the service node ï inside the ros2_ws/src/py_srvcli/py_srvcli directory, create a new file called service_member_function.py and paste the following code within: from example_interfaces.srv import addtwoints import rclpy from rclpy.node import node class minimalservice ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_service' ) self . srv = self . create_service ( addtwoints , 'add_two_ints' , self . add_two_ints_callback ) def add_two_ints_callback ( self , request , response ): response . sum = request . a + request . b self . get_logger () . info ( 'incoming request \n a: %d b: %d ' % ( request . a , request . b )) return response def main (): rclpy . init () minimal_service = minimalservice () rclpy . spin ( minimal_service ) rclpy . shutdown () if __name__ == '__main__' : main () 2.1 examine the code ï the first import statement imports the addtwoints service type from the example_interfaces package. the following import statement imports the ros 2 python client library, and specifically the node class. from example_interfaces.srv import addtwoints import rclpy from rclpy.node import node the minimalservice class constructor initializes the node with the name minimal_service . then, it creates a service and defines the type, name, and callback. def __init__ ( self ): super () . __init__ ( 'minimal_service' ) self . srv = self . create_service ( addtwoints , 'add_two_ints' , self . add_two_ints_callback ) the definition of the service callback receives the request data, sums it, and returns the sum as a response. def add_two_ints_callback ( self , request , response ): response . sum = request . a + request . b self . get_logger () . info ( 'incoming request \n a: %d b: %d ' % ( request . a , request . b )) return response finally, the main class initializes the ros 2 python client library, instantiates the minimalservice class to create the service node and spins the node to handle callbacks. 2.2 add an entry point ï to allow the ros2 run command to run your node, you must add the entry point to setup.py (located in the ros2_ws/src/py_srvcli directory). add the following line between the 'console_scripts': brackets: 'service = py_srvcli.service_member_function:main' , 3 write the client node ï inside the ros2_ws/src/py_srvcli/py_srvcli directory, create a new file called client_member_function.py and paste the following code within: import sys from example_interfaces.srv import addtwoints import rclpy from rclpy.node import node class minimalclientasync ( node ): def __init__ ( self ): super () . __init__ ( 'minimal_client_async' ) self . cli = self . create_client ( addtwoints , 'add_two_ints' ) while not self . cli . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . req = addtwoints . request () def send_request ( self , a , b ): self . req . a = a self . req . b = b return self . cli . call_async ( self . req ) def main (): rclpy . init () minimal_client = minimalclientasync () future = minimal_client . send_request ( int ( sys . argv [ 1 ]), int ( sys . argv [ 2 ])) rclpy . spin_until_future_complete ( minimal_client , future ) response = future . result () minimal_client . get_logger () . info ( 'result of add_two_ints: for %d + %d = %d ' % ( int ( sys . argv [ 1 ]), int ( sys . argv [ 2 ]), response . sum )) minimal_client . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () 3.1 examine the code ï as with the service code, we first import the necessary libraries. import sys from example_interfaces.srv import addtwoints import rclpy from rclpy.node import node the minimalclientasync class constructor initializes the node with the name minimal_client_async . the constructor definition creates a client with the same type and name as the service node. the type and name must match for the client and service to be able to communicate. the while loop in the constructor checks if a service matching the type and name of the client is available once a second. finally it creates a new addtwoints request object. def __init__ ( self ): super () . __init__ ( 'minimal_client_async' ) self . cli = self . create_client ( addtwoints , 'add_two_ints' ) while not self . cli . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . req = addtwoints . request () below the constructor is the send_request method, which will send the request and return a future that can be passed to spin_until_future_complete : def send_request ( self , a , b ): self . req . a = a self . req . b = b return self . cli . call_async ( self . req ) finally we have the main method, which constructs a minimalclientasync object, sends the request using the passed-in command-line arguments, calls spin_until_future_complete , and logs the results: def main (): rclpy . init () minimal_client = minimalclientasync () future = minimal_client . send_request ( int ( sys . argv [ 1 ]), int ( sys . argv [ 2 ])) rclpy . spin_until_future_complete ( minimal_client , future ) response = future . result () minimal_client . get_logger () . info ( 'result of add_two_ints: for %d + %d = %d ' % ( int ( sys . argv [ 1 ]), int ( sys . argv [ 2 ]), response . sum )) minimal_client . destroy_node () rclpy . shutdown () 3.2 add an entry point ï like the service node, you also have to add an entry point to be able to run the client node. the entry_points field of your setup.py file should look like this: entry_points = { 'console_scripts' : [ 'service = py_srvcli.service_member_function:main' , 'client = py_srvcli.client_member_function:main' , ], }, 4 build and run ï itâs good practice to run rosdep in the root of your workspace ( ros2_ws ) to check for missing dependencies before building: linux macos windows rosdep install -i --from-path src --rosdistro jazzy -y rosdep only runs on linux, so you can skip ahead to next step. rosdep only runs on linux, so you can skip ahead to next step. navigate back to the root of your workspace, ros2_ws , and build your new package: colcon build --packages-select py_srvcli open a new terminal, navigate to ros2_ws , and source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the service node: ros2 run py_srvcli service the node will wait for the clientâs request. open another terminal and source the setup files from inside ros2_ws again. start the client node, followed by any two integers separated by a space: ros2 run py_srvcli client 2 3 if you chose 2 and 3 , for example, the client would receive a response like this: [info] [minimal_client_async]: result of add_two_ints: for 2 + 3 = 5 return to the terminal where your service node is running. you will see that it published log messages when it received the request: [info] [minimal_service]: incoming request a: 2 b: 3 enter ctrl+c in the server terminal to stop the node from spinning. summary ï you created two nodes to request and respond to data over a service. you added their dependencies and executables to the package configuration files so that you could build and run them, allowing you to see a service/client system at work. next steps ï in the last few tutorials youâve been utilizing interfaces to pass data across topics and services. next, youâll learn how to create custom interfaces . related content ï there are several ways you could write a service and client in python; check out the minimal_client and minimal_service packages in the ros2/examples repo. in this tutorial, you used the call_async() api in your client node to call the service. there is another service call api available for python called synchronous calls. we do not recommend using synchronous calls, but if youâd like to learn more  them, read the guide to synchronous vs. asynchronous clients . other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling