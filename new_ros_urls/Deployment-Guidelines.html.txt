tutorials advanced security deployment guidelines edit on github deployment guidelines ï goal: understand the best practices when deploying security artifacts into production systems. tutorial level: advanced time: 20 minutes background ï typical deployment scenarios often involve shipping containerized applications, or packages, into remote systems. special attention should be payed when deploying security enabled applications, requiring users to reason  the sensitivity of packaged files. complying with the dds security standard , the sros2 package provides a collection of utilities for managing security under ros 2 environments in a highly modular and flexible fashion. basic core guidelines on how to organize the different certificates, keys and directories remains a critical factor to avoid compromising the security of the system. this includes protection-awareness and criteria for selecting the minimum set of necessary files to be deployed upon remote production systems for minimizing security exposure. prerequisites ï a docker installation with the compose plugin.  refer to the installation steps detailed in docker installation and compose plugin . (recommended) a basic understanding on ros 2 security design . (recommended) previous security tutorials completion. in particular: setting up security understanding the security keystore setting access controls general guidelines ï ros 2 leverages dds security extensions to ensure security on message exchanges within the same enclave. the different signed files and certificates within an enclave are generated from the private keys and certificates of a certificate authority (ca) trusted entity. in fact, two different caâs can be selected for identity and permissions, per enclave. those ca artifacts are stored inside private/ and public/ sub-directories of a keystore with the following folder structure: keystore âââ enclaves â âââ ... â âââ ... âââ private â âââ ... âââ public âââ ... a good practice for the creation and usage of a certain certificate authority on a typical deployment for a production system, is to: create it within the organization system intended for internal use only. generate/modify desired enclaves bearing in mind that: not all the generated enclaves should be deployed to all target devices. a reasonable way to proceed would be having one enclave per application, allowing for a separation of concerns. ship public/ alongside with corresponding enclaves/ into the different remote production devices during setup. keep and protect private/ keys and/or certification requests in the organization. it is important to note that if private/ files are lost, it wonât be possible to change access permissions, add or modify security profiles anymore. in addition, further practices may be taken into consideration: granting read-only permissions to the enclaves/ directory contents. if a pkcs#11 compliant uri is given for generating enclaveâs private keys, a hardware security module (hsm) could be used to store them. the following table depicts a summary of the previous statements relating the keystore directory with the recommended location: directory / location organization target device material sensitivity public â â low private â â high enclaves â â medium building a deployment scenario ï to illustrate a simple deployment scenario, a new docker image will be built on top of the one provided by ros:<distro> . starting from the image, three containers will be created with the aim of: initializing the keystore in a local hostâs shared volume. simulating two deployed remote devices that interact with each other in a secure way. in this example, the local host serves as the organizationâs system. let us start by creating a workspace folder: mkdir ~/security_gd_tutorial cd ~/security_gd_tutorial generating the docker image ï in order to build a new docker image, a dockerfile is required. the one proposed for this tutorial can be retrieved with the following command: # download the dockerfile wget https://raw.githubusercontent.com/ros2/ros2_documentation/jazzy/source/tutorials/advanced/security/resources/deployment_gd/dockerfile now, build the docker image with the command: # build the base image docker build -t ros2_security/deployment_tutorial --build-arg ros_distro = jazzy . understanding the compose file ï a compose configration file takes an image to create containers as services. in this tutorial, three services are defined within the configuration: keystore-creator : that, similarly to previous tutorials, it internally initializes a new keystore tree directory. this will create enclaves/ public/ and private/ , which are explained in more detail in ros 2 security enclaves . the keystore directory is configured to be a shared volume across containers. listener and talker : act as the remote device actors in this tutorial. required security environment variables are sourced as well as the necessary keystore files from the shared volume. the compose configuration yaml file can be downloaded with: # download the compose file wget https://raw.githubusercontent.com/ros2/ros2_documentation/jazzy/source/tutorials/advanced/security/resources/deployment_gd/compose.deployment.yaml running the example ï in the same working directory ~/security_gd_tutorial , run: # start the example docker compose -f compose.deployment.yaml up this should result in the following output: tutorial-listener-1 : found security directory: /keystore/enclaves/talker_listener/listener tutorial-talker-1 : found security directory: /keystore/enclaves/talker_listener/talker tutorial-listener-1 : publishing: 'hello world: <number>' tutorial-talker-1 : i heard: [hello world: <number>] examining the containers ï while having the containers running that simulate the two remote devices for this tutorial, attach to each of them by opening two different terminals and enter: # terminal 1 docker exec -it tutorial-listener-1 bash cd keystore tree # terminal 2 docker exec -it tutorial-talker-1 bash cd keystore tree a similar output to the one depicted below should be obtained: # terminal 1 keystore âââ enclaves â â â âââ governance.p7s â â â âââ governance.xml â â â âââ talker_listener â â â âââ listener â â â âââ cert.pem â â â âââ governance.p7s â â â âââ identity_ca.cert.pem â â â âââ key.pem â â â âââ permissions_ca.cert.pem â â â âââ permissions.p7s â â â âââ permissions.xml âââ public âââ ca.cert.pem âââ identity_ca.cert.pem âââ permissions_ca.cert.pem # terminal 2 keystore âââ enclaves â â â âââ governance.p7s â â â âââ governance.xml â â â âââ talker_listener â â â âââ talker â â â âââ cert.pem â â â âââ governance.p7s â â â âââ identity_ca.cert.pem â â â âââ key.pem â â â âââ permissions_ca.cert.pem â â â âââ permissions.p7s â â â âââ permissions.xml âââ public âââ ca.cert.pem âââ identity_ca.cert.pem âââ permissions_ca.cert.pem note that: private/ folder is not moved but left in the local host (organization). each one of the deployed devices contain its own minimum enclave required for its application. note for the sake of simplicity, the same ca is used within this enclave for both identity and permissions. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling