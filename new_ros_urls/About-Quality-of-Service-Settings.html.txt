concepts intermediate concepts quality of service settings edit on github quality of service settings ï overview ï ros 2 offers a rich variety of quality of service (qos) policies that allow you to tune communication between nodes. with the right set of quality of service policies, ros 2 can be as reliable as tcp or as best-effort as udp, with many, many possible states in between. unlike ros 1, which primarily only supported tcp, ros 2 benefits from the flexibility of the underlying dds transport in environments with lossy wireless networks where a âbest effortâ policy would be more suitable, or in real-time computing systems where the right quality of service profile is needed to meet deadlines. a set of qos âpoliciesâ combine to form a qos âprofileâ. given the complexity of choosing the correct qos policies for a given scenario, ros 2 provides a set of predefined qos profiles for common use cases (e.g. sensor data). at the same time, developers are given the flexibility to control specific policies of the qos profiles. qos profiles can be specified for publishers, s, service servers and clients. a qos profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages. qos policies ï the base qos profile currently includes settings for the following policies: history keep last : only store up to n samples, configurable via the queue depth option. keep all : store all samples, subject to the configured resource limits of the underlying middleware. depth queue size : only honored if the âhistoryâ policy was set to âkeep lastâ. reliability best effort : attempt to deliver samples, but may lose them if the network is not robust. reliable : guarantee that samples are delivered, may retry multiple times. durability transient local : the publisher becomes responsible for persisting samples for âlate-joiningâ s. volatile : no attempt is made to persist samples. deadline duration : the expected maximum amount of time between subsequent messages being published to a topic lifespan duration : the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received). liveliness automatic : the system will consider all of the nodeâs publishers to be alive for another âlease durationâ when any one of its publishers has published a message. manual by topic : the system will consider the publisher to be alive for another âlease durationâ if it manually asserts that it is still alive (via a call to the publisher api). lease duration duration : the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure). for each of the policies that is not a duration, there is also the option of âsystem defaultâ, which uses the default of the underlying middleware. for each of the policies that is a duration, there also exists a âdefaultâ option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration. comparison to ros 1 ï the âhistoryâ and âdepthâ policies in ros 2 combine to provide functionality akin to the queue size in ros 1. the âreliabilityâ policy in ros 2 is akin to the use of either udpros (only in roscpp ) for âbest effortâ, or tcpros (ros 1 default) for âreliableâ. note however that even the reliable policy in ros 2 is implemented using udp, which allows for multicasting if appropriate. the âdurabilityâ policy âtransient localâ, combined with any depth, provides functionality similar to that of âlatchingâ publishers. the remaining policies in ros 2 are not akin to anything that is available in ros 1, meaning that ros 2 is more featureful than ros 1 in this respect. it is possible that in the future, even more qos policies will be available in ros 2. qos profiles ï profiles allow developers to focus on their applications without worrying  every qos setting possible. a qos profile defines a set of policies that are expected to go well together for a particular use case. the currently defined qos profiles are: default qos settings for publishers and s in order to make the transition from ros 1 to ros 2 easier, exercising a similar network behavior is desirable. by default, publishers and s in ros 2 have âkeep lastâ for history with a queue size of 10, âreliableâ for reliability, âvolatileâ for durability, and âsystem defaultâ for liveliness. deadline, lifespan, and lease durations are also all set to âdefaultâ. services in the same vein as publishers and s, services are reliable. it is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. while the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests. sensor data for sensor data, in most cases itâs more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. that is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. for that reason the sensor data profile uses best effort reliability and a smaller queue size. parameters parameters in ros 2 are based on services, and as such have a similar profile. the difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server. system default this uses the rmw implementationâs default values for all of the policies. different rmw implementations may have different defaults. click here for the specific policies in use for the above profiles. the settings in these profiles are subject to further tweaks, based on the feedback from the community. qos compatibilities ï note: this section refers to publishers and s but the content applies to service servers and clients in the same manner. qos profiles may be configured for publishers and s independently. a connection between a publisher and a  is only made if the pair has compatible qos profiles. qos profile compatibility is determined based on a ârequest vs offeredâ model. s request a qos profile that is the âminimum qualityâ that it is willing to accept, and publishers offer a qos profile that is the âmaximum qualityâ that it is able to provide. connections are only made if every policy of the requested qos profile is not more stringent than that of the offered qos profile. multiple s can be connected to a single publisher simultaneously even if their requested qos profiles are different. the compatibility between a publisher and a  is unaffected by the presence of other publishers and s. the following tables show the compatibility of the different policy settings and the result: compatibility of reliability qos policies: publisher  compatible best effort best effort yes best effort reliable no reliable best effort yes reliable reliable yes compatibility of durability qos policies: publisher  compatible result volatile volatile yes new messages only volatile transient local no no communication transient local volatile yes new messages only transient local transient local yes new and old messages to achieve a âlatchedâ topic that is visible to late subscribers, both the publisher and subscriber must agree to use âtransient localâ. compatibility of deadline qos policies: assume x and y are arbitrary valid duration values. publisher  compatible default default yes default x no x default yes x x yes x y (where y > x ) yes x y (where y < x ) no compatibility of liveliness qos policies: publisher  compatible automatic automatic yes automatic manual by topic no manual by topic automatic yes manual by topic manual by topic yes compatibility of lease duration qos policies: assume x and y are arbitrary valid duration values. publisher  compatible default default yes default x no x default yes x x yes x y (where y > x ) yes x y (where y < x ) no in order for a connection to be made, all of the policies that affect compatibility must be compatible. for example, even if a requested and offered qos profile pair has compatible reliability qos policies, but they have incompatible durability qos policies, a connection will still not be made. when connections are not made, no messages will be passed between the publisher and . there are mechanisms to detect this situation, which will be covered in a later section. comparison to ros 1 ï historically in ros 1, any publisher and subscriber with the same message type on the same topic would be connected. the possibility of incompatible requested and offered qos profiles is something new to be aware of when using ros 2. qos events ï some qos policies have possible events related to them. developers may provide each publisher and  with callback functions that are triggered by these qos events and handle them in a way they see fit, similar to how messages received on a topic are handled. developers may subscribe to the following qos events that are associated with a publisher: offered deadline missed the publisher has not published a message within the expected duration that was set out by the deadline qos policy. liveliness lost the publisher has failed to indicate its liveliness within the lease duration. offered incompatible qos the publisher has encountered a  on the same topic that is requesting a qos profile that the offered qos profile cannot satisfy, resulting in no connection between the publisher and that . developers may subscribe to the following qos events that are associated with a : requested deadline missed the  has not received a message within the expected duration that was set out by the deadline qos policy. liveliness changed the  has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration. requested incompatible qos the  has encountered a publisher on the same topic that is offering a qos profile that does not satisfy the requested qos profile, resulting in no connection between the  and that publisher. matched events ï in addition to qos events, matched events can be generated when any publisher and  establishes or drops the connection between them. developers may provide each publisher and  with callback functions that are triggered by matched events and handle them in a way they see fit, similar to how messages received on a topic are handled. developers can subscribe to this event with a publisher or a . publisher: this event happens when it finds a  which matches the topic and has compatible qos or a connected  is disconnected : this event happens when it finds a publisher which matches the topic and has compatible qos or a connected publisher is disconnected there are demos showing how to use the event: rclcpp: demo code rclpy: demo code other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling