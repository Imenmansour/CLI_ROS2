tutorials beginner: client libraries creating and using plugins (c++) edit on github creating and using plugins (c++) ï goal: learn to create and load a simple plugin using pluginlib . tutorial level: beginner time: 20 minutes background ï this tutorial is derived from http://wiki.ros.org/pluginlib and writing and using a simple plugin tutorial . pluginlib is a c++ library for loading and unloading plugins from within a ros package. plugins are dynamically loadable classes that are loaded from a runtime library (i.e. shared object, dynamically linked library). with pluginlib, you do not have to explicitly link your application against the library containing the classes â instead pluginlib can open a library containing exported classes at any point without the application having any prior awareness of the library or the header file containing the class definition. plugins are useful for extending/modifying application behavior without needing the application source code. prerequisites ï this tutorial assumes basic c++ knowledge and that you have successfully installed ros 2 . tasks ï in this tutorial, you will create two new packages, one that defines the base class, and another that provides the plugins. the base class will define a generic polygon class, and then our plugins will define specific shapes. 1 create the base class package ï create a new empty package in your ros2_ws/src folder with the following command: ros2 pkg create --build-type ament_cmake --license apache-2.0 --dependencies pluginlib --node-name area_node polygon_base open your favorite editor, edit ros2_ws/src/polygon_base/include/polygon_base/regular_polygon.hpp , and paste the following inside of it: #ifndef polygon_base_regular_polygon_hpp #define polygon_base_regular_polygon_hpp namespace polygon_base { class regularpolygon { public : virtual void initialize ( double side_length ) = 0 ; virtual double area () = 0 ; virtual ~ regularpolygon (){} protected : regularpolygon (){} }; } // namespace polygon_base #endif // polygon_base_regular_polygon_hpp the code above creates an abstract class called regularpolygon . one thing to notice is the presence of the initialize method. with pluginlib , a constructor without parameters is required, so if any parameters to the class are needed, we use the initialize method to pass them to the object. we need to make this header available to other classes, so open ros2_ws/src/polygon_base/cmakelists.txt for editing. add the following lines after the ament_target_dependencies command: install ( directory include/ destination include ) and add this command before the ament_package command: ament_export_include_directories ( include ) we will return to this package later to write our test node. 2 create the plugin package ï now weâre going to write two non-virtual implementations of our abstract class. create a second empty package in your ros2_ws/src folder with the following command: ros2 pkg create --build-type ament_cmake --license apache-2.0 --dependencies polygon_base pluginlib --library-name polygon_plugins polygon_plugins 2.1 source code for the plugins ï open ros2_ws/src/polygon_plugins/src/polygon_plugins.cpp for editing, and paste the following inside of it: #include <polygon_base/regular_polygon.hpp> #include <cmath> namespace polygon_plugins { class square : public polygon_base :: regularpolygon { public : void initialize ( double side_length ) override { side_length_ = side_length ; } double area () override { return side_length_ * side_length_ ; } protected : double side_length_ ; }; class triangle : public polygon_base :: regularpolygon { public : void initialize ( double side_length ) override { side_length_ = side_length ; } double area () override { return 0.5 * side_length_ * getheight (); } double getheight () { return sqrt (( side_length_ * side_length_ ) - (( side_length_ / 2 ) * ( side_length_ / 2 ))); } protected : double side_length_ ; }; } #include <pluginlib/class_list_macros.hpp> pluginlib_export_class ( polygon_plugins :: square , polygon_base :: regularpolygon ) pluginlib_export_class ( polygon_plugins :: triangle , polygon_base :: regularpolygon ) the implementation of the square and triangle classes is fairly straightforward: save the side length, and use it to calculate the area. the only piece that is pluginlib specific is the last three lines, which invokes some magical macros that register the classes as actual plugins. letâs go through the arguments to the pluginlib_export_class macro: the fully-qualified type of the plugin class, in this case, polygon_plugins::square . the fully-qualified type of the base class, in this case, polygon_base::regularpolygon . 2.2 plugin declaration xml ï the steps above enable plugin instances to be created when the containing library is loaded, but the plugin loader still needs a way to find that library and to know what to reference within that library. to this end, weâll also create an xml file that, along with a special export line in the package manifest, makes all the necessary information  our plugins available to the ros toolchain. create ros2_ws/src/polygon_plugins/plugins.xml with the following code: <library path= "polygon_plugins" > <class type= "polygon_plugins::square" base_class_type= "polygon_base::regularpolygon" > <description> this is a square plugin. </description> </class> <class type= "polygon_plugins::triangle" base_class_type= "polygon_base::regularpolygon" > <description> this is a triangle plugin. </description> </class> </library> a couple things to note: the library tag gives the relative path to a library that contains the plugins that we want to export. in ros 2, that is just the name of the library. in ros 1, it contained the prefix lib or sometimes lib/lib (i.e. lib/libpolygon_plugins ), but here it is simpler. the class tag declares a plugin that we want to export from our library. letâs go through its parameters: type : the fully qualified type of the plugin. for us, thatâs polygon_plugins::square . base_class : the fully qualified base class type for the plugin. for us, thatâs polygon_base::regularpolygon . description : a description of the plugin and what it does. 2.3 cmake plugin declaration ï the last step is to export your plugins via cmakelists.txt . this is a change from ros 1, where the exporting was done via package.xml . add the following line to your ros2_ws/src/polygon_plugins/cmakelists.txt after the line reading find_package(pluginlib required) : pluginlib_export_plugin_description_file ( polygon_base plugins.xml ) the arguments to the pluginlib_export_plugin_description_file command are: the package with the base class, i.e. polygon_base . the relative path to the plugin declaration xml, i.e. plugins.xml . 3 use the plugins ï now itâs time to use the plugins. this can be done in any package, but here weâre going to do it in the base package. edit ros2_ws/src/polygon_base/src/area_node.cpp to contain the following: #include <pluginlib/class_loader.hpp> #include <polygon_base/regular_polygon.hpp> int main ( int argc , char ** argv ) { // to avoid unused parameter warnings ( void ) argc ; ( void ) argv ; pluginlib :: classloader < polygon_base :: regularpolygon > poly_loader ( "polygon_base" , "polygon_base::regularpolygon" ); try { std :: shared_ptr < polygon_base :: regularpolygon > triangle = poly_loader . createsharedinstance ( "polygon_plugins::triangle" ); triangle -> initialize ( 10.0 ); std :: shared_ptr < polygon_base :: regularpolygon > square = poly_loader . createsharedinstance ( "polygon_plugins::square" ); square -> initialize ( 10.0 ); printf ( "triangle area: %.2f \n " , triangle -> area ()); printf ( "square area: %.2f \n " , square -> area ()); } catch ( pluginlib :: pluginlibexception & ex ) { printf ( "the plugin failed to load for some reason. error: %s \n " , ex . what ()); } return 0 ; } the classloader is the key class to understand, defined in the class_loader.hpp header file : it is templated with the base class, i.e. polygon_base::regularpolygon . the first argument is a string for the package name of the base class, i.e. polygon_base . the second argument is a string with the fully qualified base class type for the plugin, i.e. polygon_base::regularpolygon . there are a number of ways to instantiate an instance of the class. in this example, weâre using shared pointers. we just need to call createsharedinstance with the fully-qualified type of the plugin class, in this case, polygon_plugins::square . important note: the polygon_base package in which this node is defined does not depend on the polygon_plugins class. the plugins will be loaded dynamically without any dependency needing to be declared. furthermore, weâre instantiating the classes with hardcoded plugin names, but you can also do so dynamically with parameters, etc. 4 build and run ï navigate back to the root of your workspace, ros2_ws , and build your new packages: colcon build --packages-select polygon_base polygon_plugins from ros2_ws , be sure to source the setup files: linux macos windows source install/setup.bash . install/setup.bash call install/setup.bat now run the node: ros2 run polygon_base area_node it should print: triangle area: 43.30 square area: 100.00 summary ï congratulations! youâve just written and used your first plugins. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling