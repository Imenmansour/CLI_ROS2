how-to guides migrating from ros 1 to ros 2 migrating c++ packages edit on github migrating c++ packages ï build tool ï instead of using catkin_make , catkin_make_isolated or catkin build ros 2 uses the command line tool colcon to build and install a set of packages. see the beginner tutorial to get started with colcon . build system ï the build system in ros 2 is called ament . ament is built on cmake: ament_cmake provides cmake functions to make writing cmakelists.txt files easier. update the cmakelists.txt to use ament_cmake ï apply the following changes to use ament_cmake instead of catkin : set the build type in the package.xml file export section: <export> <build_type> ament_cmake </build_type> </export> replace the find_package invocation with catkin and the components with: find_package ( ament_cmake required ) find_package ( component1 required ) # ... find_package ( componentn required ) move and update the catkin_package invocation with: invoke ament_package instead but after all targets have been registered. the only valid argument for ament_package is config_extras . all other arguments are covered by separate functions which all need to be invoked before ament_package : instead of passing catkin_depends ... call ament_export_dependencies(...) before. instead of passing include_dirs ... call ament_export_include_directories(...) before. instead of passing libraries ... call ament_export_libraries(...) before. replace the invocation of add_message_files , add_service_files and generate_messages with rosidl_generate_interfaces . the first argument is the target_name . if youâre building just one library itâs {project_name} followed by the list of message filenames, relative to the package root. if you will be using the list of filenames multiple times, it is recommended to compose a list of message files and pass the list to the function for clarity. the final multi-value-keyword argument fpr generate_messages is dependencies which requires the list of dependent message packages. rosidl_generate_interfaces ( { project_name } { msg_files } dependencies std_msgs ) remove any occurrences of the devel space . related cmake variables like catkin_devel_prefix do not exist anymore. the catkin_depends and depends arguments are passed to the new function ament_export_dependencies . catkin_global_bin_destination : bin catkin_global_include_destination : include catkin_global_lib_destination : lib catkin_global_libexec_destination : lib catkin_global_share_destination : share catkin_package_bin_destination : lib/{project_name} catkin_package_include_destination : include/{project_name} catkin_package_lib_destination : lib catkin_package_share_destination : share/{project_name} unit tests ï if you are using gtest: replace catkin_enable_testing with build_testing . replace catkin_add_gtest with ament_add_gtest . - if (catkin_enable_testing) - find_package(gtest required) # or rostest - include_directories({gtest_include_dirs}) - catkin_add_gtest({project_name}-some-test src/test/some_test.cpp) - target_link_libraries({project_name}-some-test - {project_name}_some_dependency - {catkin_libraries} - {gtest_libraries}) - endif() + if (build_testing) + find_package(ament_cmake_gtest required) + ament_add_gtest({project_name}-some-test src/test/test_something.cpp) + ament_target_dependencies({project_name)-some-test + "rclcpp" + "std_msgs") + target_link_libraries({project_name}-some-test + {project_name}_some_dependency) + endif() add <test_depend>ament_cmake_gtest</test_depend> to your package.xml . - <test_depend>rostest</test_depend> + <test_depend>ament_cmake_gtest</test_depend> linters ï in ros 2 we are working to maintain clean code using linters. the styles for different languages are defined in our developer guide . if you are starting a project from scratch it is recommended to follow the style guide and turn on the automatic linter unit tests by adding these lines just below if(build_testing) : find_package ( ament_lint_auto required ) ament_lint_auto_find_test_dependencies () you will also need to add the following dependencies to your package.xml : <test_depend> ament_lint_auto </test_depend> <test_depend> ament_lint_common </test_depend> update source code ï messages, services, and actions ï the namespace of ros 2 messages, services, and actions use a subnamespace ( msg , srv , or action , respectively) after the package name. therefore an include looks like: #include <my_interfaces/msg/my_message.hpp> . the c++ type is then named: my_interfaces::msg::mymessage . shared pointer types are provided as typedefs within the message structs: my_interfaces::msg::mymessage::sharedptr as well as my_interfaces::msg::mymessage::constsharedptr . for more details  see the article  the generated c++ interfaces . the migration requires includes to change by: inserting the subfolder msg between the package name and message datatype changing the included filename from camelcase to underscore separation changing from *.h to *.hpp // ros 1 style is in comments, ros 2 follows, uncommented. // # include <geometry_msgs/pointstamped.h> #include <geometry_msgs/msg/point_stamped.hpp> // geometry_msgs::pointstamped point_stamped; geometry_msgs :: msg :: pointstamped point_stamped ; the migration requires code to insert the msg namespace into all instances. use of service objects ï service callbacks in ros 2 do not have boolean return values. instead of returning false on failures, throwing exceptions is recommended. // ros 1 style is in comments, ros 2 follows, uncommented. // #include "nav_msgs/getmap.h" #include "nav_msgs/srv/get_map.hpp" // bool service_callback( // nav_msgs::getmap::request & request, // nav_msgs::getmap::response & response) void service_callback ( const std :: shared_ptr < nav_msgs :: srv :: getmap :: request > request , std :: shared_ptr < nav_msgs :: srv :: getmap :: response > response ) { // ... // return true; // or false for failure } usages of ros::time ï for usages of ros::time : replace all instances of ros::time with rclcpp::time if your messages or code makes use of std_msgs::time: convert all instances of std_msgs::time to builtin_interfaces::msg::time convert all #include "std_msgs/time.h to #include "builtin_interfaces/msg/time.hpp" convert all instances using the std_msgs::time field nsec to the builtin_interfaces::msg::time field nanosec usages of ros::rate ï there is an equivalent type rclcpp::rate object which is basically a drop in replacement for ros::rate . boost ï much of the functionality previously provided by boost has been integrated into the c++ standard library. as such we would like to take advantage of the new core features and avoid the dependency on boost where possible. shared pointers ï to switch shared pointers from boost to standard c++ replace instances of: #include <boost/shared_ptr.hpp> with #include <memory> boost::shared_ptr with std::shared_ptr there may also be variants such as weak_ptr which you want to convert as well. also it is recommended practice to use using instead of typedef . using has the ability to work better in templated logic. for details see here thread/mutexes ï another common part of boost used in ros codebases are mutexes in boost::thread . replace boost::mutex::scoped_lock with std::unique_lock<std::mutex> replace boost::mutex with std::mutex replace #include <boost/thread/mutex.hpp> with #include <mutex> unordered map ï replace: #include <boost/unordered_map.hpp> with #include <unordered_map> boost::unordered_map with std::unordered_map function ï replace: #include <boost/function.hpp> with #include <functional> boost::function with std::function example: converting an existing ros 1 package to ros 2 ï letâs say that we have simple ros 1 package called talker that uses roscpp in one node, called talker . this package is in a catkin workspace, located at ~/ros1_talker . the ros 1 code ï hereâs the directory layout of our catkin workspace:  cd ~/ros1_talker  find . . ./src ./src/talker ./src/talker/package.xml ./src/talker/cmakelists.txt ./src/talker/talker.cpp here is the content of those three files: src/talker/package.xml : <package> <name> talker </name> <version> 0.0.0 </version> <description> talker </description> <maintainer = "gerkey@osrfoundation.org" > brian gerkey </maintainer> <license> apache-2.0 </license> <buildtool_depend> catkin </buildtool_depend> <build_depend> roscpp </build_depend> <build_depend> std_msgs </build_depend> <run_depend> roscpp </run_depend> <run_depend> std_msgs </run_depend> </package> src/talker/cmakelists.txt : cmake_minimum_required ( version 2.8.3 ) project ( talker ) find_package ( catkin required components roscpp std_msgs ) catkin_package () include_directories ( { catkin_include_dirs } ) add_executable ( talker talker.cpp ) target_link_libraries ( talker { catkin_libraries } ) install ( targets talker runtime destination { catkin_package_bin_destination } ) src/talker/talker.cpp : #include <sstream> #include "ros/ros.h" #include "std_msgs/string.h" int main ( int argc , char ** argv ) { ros :: init ( argc , argv , "talker" ); ros :: nodehandle n ; ros :: publisher chatter_pub = n . advertise < std_msgs :: string > ( "chatter" , 1000 ); ros :: rate loop_rate ( 10 ); int count = 0 ; std_msgs :: string msg ; while ( ros :: ok ()) { std :: stringstream ss ; ss << "hello world " << count ++ ; msg . data = ss . str (); ros_info ( "%s" , msg . data . c_str ()); chatter_pub . publish ( msg ); ros :: spinonce (); loop_rate . sleep (); } return 0 ; } building the ros 1 code ï we source an environment setup file (in this case for noetic using bash), then we build our package using catkin_make install : . /opt/ros/noetic/setup.bash cd ~/ros1_talker catkin_make install running the ros 1 node ï if thereâs not already one running, we start a roscore , first sourcing the setup file from our catkin install tree (the system setup file at /opt/ros/noetic/setup.bash would also work here): . ~/ros1_talker/install/setup.bash roscore in another shell, we run the node from the catkin install space using rosrun , again sourcing the setup file first (in this case it must be the one from our workspace): . ~/ros1_talker/install/setup.bash rosrun talker talker migrating to ros 2 ï letâs start by creating a new workspace in which to work: mkdir ~/ros2_talker cd ~/ros2_talker weâll copy the source tree from our ros 1 package into that workspace, where we can modify it: mkdir src cp -a ~/ros1_talker/src/talker src now weâll modify the c++ code in the node. the ros 2 c++ library, called rclcpp , provides a different api from that provided by roscpp . the concepts are very similar between the two libraries, which makes the changes reasonably straightforward to make. included headers ï in place of ros/ros.h , which gave us access to the roscpp library api, we need to include rclcpp/rclcpp.hpp , which gives us access to the rclcpp library api: //#include "ros/ros.h" #include "rclcpp/rclcpp.hpp" to get the std_msgs/string message definition, in place of std_msgs/string.h , we need to include std_msgs/msg/string.hpp : //#include "std_msgs/string.h" #include "std_msgs/msg/string.hpp" changing c++ library calls ï instead of passing the nodeâs name to the library initialization call, we do the initialization, then pass the node name to the creation of the node object: // ros::init(argc, argv, "talker"); // ros::nodehandle n; rclcpp :: init ( argc , argv ); auto node = rclcpp :: node :: make_shared ( "talker" ); the creation of the publisher and rate objects looks pretty similar, with some changes to the names of namespace and methods. // ros::publisher chatter_pub = n.advertise<std_msgs::string>("chatter", 1000); // ros::rate loop_rate(10); auto chatter_pub = node -> create_publisher < std_msgs :: msg :: string > ( "chatter" , 1000 ); rclcpp :: rate loop_rate ( 10 ); to further control how message delivery is handled, a quality of service ( qos ) profile could be passed in. the default profile is rmw_qos_profile_default . for more details, see the design document and concept overview . the creation of the outgoing message is different in the namespace: // std_msgs::string msg; std_msgs :: msg :: string msg ; in place of ros::ok() , we call rclcpp::ok() : // while (ros::ok()) while ( rclcpp :: ok ()) inside the publishing loop, we access the data field as before: msg . data = ss . str (); to print a console message, instead of using ros_info() , we use rclcpp_info() and its various cousins. the key difference is that rclcpp_info() takes a logger object as the first argument. // ros_info("%s", msg.data.c_str()); rclcpp_info ( node -> get_logger (), "%s \n " , msg . data . c_str ()); publishing the message is the same as before: chatter_pub -> publish ( msg ); spinning (i.e., letting the communications system process any pending incoming/outgoing messages) is different in that the call now takes the node as an argument: // ros::spinonce(); rclcpp :: spin_some ( node ); sleeping using the rate object is unchanged. putting it all together, the new talker.cpp looks like this: #include <sstream> // #include "ros/ros.h" #include "rclcpp/rclcpp.hpp" // #include "std_msgs/string.h" #include "std_msgs/msg/string.hpp" int main ( int argc , char ** argv ) { // ros::init(argc, argv, "talker"); // ros::nodehandle n; rclcpp :: init ( argc , argv ); auto node = rclcpp :: node :: make_shared ( "talker" ); // ros::publisher chatter_pub = n.advertise<std_msgs::string>("chatter", 1000); // ros::rate loop_rate(10); auto chatter_pub = node -> create_publisher < std_msgs :: msg :: string > ( "chatter" , 1000 ); rclcpp :: rate loop_rate ( 10 ); int count = 0 ; // std_msgs::string msg; std_msgs :: msg :: string msg ; // while (ros::ok()) while ( rclcpp :: ok ()) { std :: stringstream ss ; ss << "hello world " << count ++ ; msg . data = ss . str (); // ros_info("%s", msg.data.c_str()); rclcpp_info ( node -> get_logger (), "%s \n " , msg . data . c_str ()); chatter_pub -> publish ( msg ); // ros::spinonce(); rclcpp :: spin_some ( node ); loop_rate . sleep (); } return 0 ; } changing the package.xml ï ros 2 uses a newer version of catkin , called ament_cmake , which we specify in the buildtool_depend tag: <!-- <buildtool_depend>catkin</buildtool_depend> --> <buildtool_depend> ament_cmake </buildtool_depend> in our build dependencies, instead of roscpp we use rclcpp , which provides the c++ api that we use. <!-- <build_depend>roscpp</build_depend> --> <build_depend> rclcpp </build_depend> we make the same addition in the run dependencies and also update from the run_depend tag to the exec_depend tag (part of the upgrade to version 2 of the package format): <!-- <run_depend>roscpp</run_depend> --> <exec_depend> rclcpp </exec_depend> <!-- <run_depend>std_msgs</run_depend> --> <exec_depend> std_msgs </exec_depend> in ros 1, we use <depend> to simplify specifying dependencies for both compile-time and runtime. we can do the same in ros 2: <depend> rclcpp </depend> <depend> std_msgs </depend> we also need to tell the build tool what kind of package we are, so that it knows how to build us. because weâre using ament and cmake, we add the following lines to declare our build type to be ament_cmake : <export> <build_type> ament_cmake </build_type> </export> putting it all together, our package.xml now looks like this: <!-- <package> --> <package format= "2" > <name> talker </name> <version> 0.0.0 </version> <description> talker </description> <maintainer = "gerkey@osrfoundation.org" > brian gerkey </maintainer> <license> apache-2.0 </license> <!-- <buildtool_depend>catkin</buildtool_depend> --> <buildtool_depend> ament_cmake </buildtool_depend> <!-- <build_depend>roscpp</build_depend> --> <!-- <run_depend>roscpp</run_depend> --> <!-- <run_depend>std_msgs</run_depend> --> <depend> rclcpp </depend> <depend> std_msgs </depend> <export> <build_type> ament_cmake </build_type> </export> </package> changing the cmake code ï ros 2 relies on a higher version of cmake: #cmake_minimum_required(version 2.8.3) cmake_minimum_required ( version 3 .5 ) ros 2 relies on the c++17 standard. depending on what compiler youâre using, support for c++17 might not be enabled by default. enable c++17 support explicitly by adding this line near the top of the file: set ( cmake_cxx_standard 17 ) the preferred way to work on all platforms is this: if ( not cmake_cxx_standard ) set ( cmake_cxx_standard 17 ) endif () if ( cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang" ) add_compile_options ( -wall -wextra -wpedantic ) endif () using catkin , we specify the packages we want to build against by passing them as components arguments when initially finding catkin itself. with ament_cmake , we find each package individually, starting with ament_cmake : #find_package(catkin required components roscpp std_msgs) find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( std_msgs required ) system dependencies can be found as before: find_package ( boost required components system filesystem thread ) we call catkin_package() to auto-generate things like cmake configuration files for other packages that use our package. whereas that call happens before specifying targets to build, we now call the analogous ament_package() after the targets: # catkin_package() # at the bottom of the file: ament_package () the only directories that need to be manually included are local directories and dependencies that are not ament packages: #include_directories({catkin_include_dirs}) include_directories ( include { boost_include_dirs } ) a better alternative is to specify include directories for each target individually, rather than including all the directories for all targets: target_include_directories ( target public include { boost_include_dirs } ) similar to how we found each dependent package separately, we need to link each one to the build target. to link with dependent packages that are ament packages, instead of using target_link_libraries() , ament_target_dependencies() is a more concise and more thorough way of handling build flags. it automatically handles both the include directories defined in _include_dirs and linking libraries defined in _libraries . #target_link_libraries(talker {catkin_libraries}) ament_target_dependencies ( talker rclcpp std_msgs ) to link with packages that are not ament packages, such as system dependencies like boost , or a library being built in the same cmakelists.txt , use target_link_libraries() : target_link_libraries ( target { boost_libraries } ) for installation, catkin defines variables like catkin_package_bin_destination . with ament_cmake , we just give a path relative to the installation root: #install(targets talker # runtime destination {catkin_package_bin_destination}) install ( targets talker destination lib/ { project_name } ) optionally, we can install and export the included directories for downstream packages: install ( directory include/ destination include ) ament_export_include_directories ( include ) optionally, we can export dependencies for downstream packages: ament_export_dependencies ( std_msgs ) putting it all together, the new cmakelists.txt looks like this: #cmake_minimum_required(version 2.8.3) cmake_minimum_required ( version 3.5 ) project ( talker ) if ( not cmake_cxx_standard ) set ( cmake_cxx_standard 17 ) endif () if ( cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang" ) add_compile_options ( -wall -wextra -wpedantic ) endif () #find_package(catkin required components roscpp std_msgs) find_package ( ament_cmake required ) find_package ( rclcpp required ) find_package ( std_msgs required ) #catkin_package() #include_directories({catkin_include_dirs}) include_directories ( include ) add_executable ( talker talker.cpp ) #target_link_libraries(talker {catkin_libraries}) ament_target_dependencies ( talker rclcpp std_msgs ) #install(targets talker # runtime destination {catkin_package_bin_destination}) install ( targets talker destination lib/ { project_name } ) install ( directory include/ destination include ) ament_export_include_directories ( include ) ament_export_dependencies ( std_msgs ) ament_package () building the ros 2 code ï we source an environment setup file (in this case the one generated by following the ros 2 installation tutorial, which builds in ~/ros2_ws , then we build our package using colcon build : . ~/ros2_ws/install/setup.bash cd ~/ros2_talker colcon build running the ros 2 node ï because we installed the talker executable into the correct directory, after sourcing the setup file, from our install tree, we can invoke it by running: . ~/ros2_ws/install/setup.bash ros2 run talker talker other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling