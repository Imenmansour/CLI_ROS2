tutorials intermediate tf2 quaternion fundamentals edit on github quaternion fundamentals ï goal: learn the basics of quaternion usage in ros 2. tutorial level: intermediate time: 10 minutes background ï a quaternion is a 4-tuple representation of orientation, which is more concise than a rotation matrix. quaternions are very efficient for analyzing situations where rotations in three dimensions are involved. quaternions are used widely in robotics, quantum mechanics, computer vision, and 3d animation. you can learn more  the underlying mathematical concept on wikipedia . you can also take a look at an explorable video series visualizing quaternions made by 3blue1brown . in this tutorial, you will learn how quaternions and conversion methods work in ros 2. prerequisites ï however, this is not a hard requirement and you can stick to any other geometric transfromation library that suit you best. you can take a look at libraries like transforms3d , scipy.spatial.transform , pytransform3d , numpy-quaternion or blender.mathutils . components of a quaternion ï ros 2 uses quaternions to track and apply rotations. a quaternion has 4 components (x, y, z, w) . in ros 2, w is last, but in some libraries like eigen, w can be placed at the first position. the commonly-used unit quaternion that yields no rotation  the x/y/z axes is (0, 0, 0, 1) , and can be created in a following way: #include <tf2/linearmath/quaternion.h> ... tf2 :: quaternion q ; // create a quaternion from roll/pitch/yaw in radians (0, 0, 0) q . setrpy ( 0 , 0 , 0 ); // print the quaternion components (0, 0, 0, 1) rclcpp_info ( this -> get_logger (), "%f %f %f %f" , q . x (), q . y (), q . z (), q . w ()); the magnitude of a quaternion should always be one. if numerical errors cause a quaternion magnitude other than one, ros 2 will print warnings. to avoid these warnings, normalize the quaternion: q . normalize (); quaternion types in ros 2 ï ros 2 uses two quaternion datatypes: tf2::quaternion and its equivalent geometry_msgs::msg::quaternion . to convert between them in c++, use the methods of tf2_geometry_msgs . c++ #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp> ... tf2 :: quaternion tf2_quat , tf2_quat_from_msg ; tf2_quat . setrpy ( roll , pitch , yaw ); // convert tf2::quaternion to geometry_msgs::msg::quaternion geometry_msgs :: msg :: quaternion msg_quat = tf2 :: tomsg ( tf2_quat ); // convert geometry_msgs::msg::quaternion to tf2::quaternion tf2 :: convert ( msg_quat , tf2_quat_from_msg ); // or tf2 :: frommsg ( msg_quat , tf2_quat_from_msg ); python from geometry_msgs.msg import quaternion ... # create a list of floats, which is compatible with tf2 # quaternion methods quat_tf = [ 0.0 , 1.0 , 0.0 , 0.0 ] # convert a list to geometry_msgs.msg.quaternion msg_quat = quaternion ( x = quat_tf [ 0 ], y = quat_tf [ 1 ], z = quat_tf [ 2 ], w = quat_tf [ 3 ]) quaternion operations ï 1 think in rpy then convert to quaternion ï itâs easy for us to think of rotations  axes, but hard to think in  of quaternions. a suggestion is to calculate target rotations in  of roll ( an x-axis), pitch ( the y-axis), and yaw ( the z-axis), and then convert to a quaternion. # quaternion_from_euler method is available in turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py q = quaternion_from_euler ( 1.5707 , 0 , - 1.5707 ) print ( f 'the quaternion representation is x: { q [ 0 ] } y: { q [ 1 ] } z: { q [ 2 ] } w: { q [ 3 ] } .' ) 2 applying a quaternion rotation ï to apply the rotation of one quaternion to a pose, simply multiply the previous quaternion of the pose by the quaternion representing the desired rotation. the order of this multiplication matters. c++ #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp> ... tf2 :: quaternion q_orig , q_rot , q_new ; q_orig . setrpy ( 0.0 , 0.0 , 0.0 ); // rotate the previous pose by 180*  x q_rot . setrpy ( 3.14159 , 0.0 , 0.0 ); q_new = q_rot * q_orig ; q_new . normalize (); python q_orig = quaternion_from_euler ( 0 , 0 , 0 ) # rotate the previous pose by 180*  x q_rot = quaternion_from_euler ( 3.14159 , 0 , 0 ) q_new = quaternion_multiply ( q_rot , q_orig ) 3 inverting a quaternion ï an easy way to invert a quaternion is to negate the w-component: q [ 3 ] = - q [ 3 ] 4 relative rotations ï say you have two quaternions from the same frame, q_1 and q_2 . you want to find the relative rotation, q_r , that converts q_1 to q_2 in a following manner: q_2 = q_r * q_1 you can solve for q_r similarly to solving a matrix equation. invert q_1 and right-multiply both sides. again, the order of multiplication is important: q_r = q_2 * q_1_inverse hereâs an example to get the relative rotation from the previous robot pose to the current robot pose in python: def quaternion_multiply ( q0 , q1 ): """ multiplies two quaternions. input :param q0: a 4 element array containing the first quaternion (q01, q11, q21, q31) :param q1: a 4 element array containing the second quaternion (q02, q12, q22, q32) output :return: a 4 element array containing the final quaternion (q03,q13,q23,q33) """ # extract the values from q0 w0 = q0 [ 0 ] x0 = q0 [ 1 ] y0 = q0 [ 2 ] z0 = q0 [ 3 ] # extract the values from q1 w1 = q1 [ 0 ] x1 = q1 [ 1 ] y1 = q1 [ 2 ] z1 = q1 [ 3 ] # computer the product of the two quaternions, term by term q0q1_w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1 q0q1_x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1 q0q1_y = w0 * y1 - x0 * z1 + y0 * w1 + z0 * x1 q0q1_z = w0 * z1 + x0 * y1 - y0 * x1 + z0 * w1 # create a 4 element array containing the final quaternion final_quaternion = np . array ([ q0q1_w , q0q1_x , q0q1_y , q0q1_z ]) # return a 4 element array containing the final quaternion (q02,q12,q22,q32) return final_quaternion q1_inv [ 0 ] = prev_pose . pose . orientation . x q1_inv [ 1 ] = prev_pose . pose . orientation . y q1_inv [ 2 ] = prev_pose . pose . orientation . z q1_inv [ 3 ] = - prev_pose . pose . orientation . w # negate for inverse q2 [ 0 ] = current_pose . pose . orientation . x q2 [ 1 ] = current_pose . pose . orientation . y q2 [ 2 ] = current_pose . pose . orientation . z q2 [ 3 ] = current_pose . pose . orientation . w qr = quaternion_multiply ( q2 , q1_inv ) summary ï in this tutorial, you learned  the fundamental concepts of a quaternion and its related mathematical operations, like inversion and rotation. you also learned  its usage examples in ros 2 and conversion methods between two separate quaternion classes. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling