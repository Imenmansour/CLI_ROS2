how-to guides using callback groups edit on github using callback groups ï when running a node in a multi-threaded executor, ros 2 offers callback groups as a tool for controlling the execution of different callbacks. this page is meant as a guide on how to use callback groups efficiently. it is assumed that the reader has a basic understanding  the concept of executors . basics of callback groups ï when running a node in a multi-threaded executor, ros 2 offers two different types of callback groups for controlling execution of callbacks: mutually exclusive callback group reentrant callback group these callback groups restrict the execution of their callbacks in different ways. in short: mutually exclusive callback group prevents its callbacks from being executed in parallel - essentially making it as if the callbacks in the group were executed by a singlethreadedexecutor. reentrant callback group allows the executor to schedule and execute the groupâs callbacks in any way it sees fit, without restrictions. this means that, in addition to different callbacks being run parallel to each other, different instances of the same callback may also be executed concurrently. callbacks belonging to different callback groups (of any type) can always be executed parallel to each other. it is also important to keep in mind that different ros 2 entities relay their callback group to all callbacks they spawn. for example, if one assigns a callback group to an action client, all callbacks created by the client will be assigned to that callback group. callback groups can be created by a nodeâs create_callback_group function in rclcpp and by calling the constructor of the group in rclpy. the callback group can then be passed as argument/option when creating a , timer, etc. c++ python my_callback_group = create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); rclcpp :: options options ; options . callback_group = my_callback_group ; my_ = create_ < int32 > ( "/topic" , rclcpp :: sensordataqos (), callback , options ); my_callback_group = mutuallyexclusivecallbackgroup () my_ = self . create_ ( int32 , "/topic" , self . callback , qos_profile = 1 , callback_group = my_callback_group ) if the user does not specify any callback group when creating a , timer, etc., this entity will be assigned to the nodeâs default callback group. the default callback group is a mutually exclusive callback group and it can be queried via nodebaseinterface::get_default_callback_group() in rclcpp and via node.default_callback_group in rclpy.  callbacks ï in the context of ros 2 and executors, a callback means a function whose scheduling and execution is handled by an executor. examples of callbacks in this context are  callbacks (receiving and handling data from a topic), timer callbacks, service callbacks (for executing service requests in a server), different callbacks in action servers and clients, done-callbacks of futures. below are a couple important points  callbacks that should be kept in mind when working with callback groups. almost everything in ros 2 is a callback! every function that is run by an executor is, by definition, a callback. the non-callback functions in a ros 2 system are found mainly at the edge of the system (user and sensor inputs etc). sometimes the callbacks are hidden and their presence may not be obvious from the user/developer api. this is the case especially with any kind of âsynchronousâ call to a service or an action (in rclpy). for example, the synchronous call client.call(request) to a service adds a futureâs done-callback that needs to be executed during the execution of the function call, but this callback is not directly visible to the user. controlling execution ï in order to control execution with callback groups, one can consider the following guidelines. for the interaction of an individual callback with itself: register it to a reentrant callback group if it should be executed in parallel to itself. an example case could be an action/service server that needs to be able to process several action calls in parallel to each other. register it to a mutually exclusive callback group if it should never be executed in parallel to itself. an example case could be a timer callback that runs a control loop that publishes control commands. for the interaction of different callbacks with each other: register them to the same mutually exclusive callback group if they should never be executed in parallel. an example case could be that the callbacks are accessing shared critical and non-thread-safe resources. if they should be executed in parallel, you have two options, depending on whether the individual callbacks should be able to overlap themselves or not: register them to different mutually exclusive callback groups (no overlap of the individual callbacks) register them to a reentrant callback group (overlap of the individual callbacks) an example case of running different callbacks in parallel is a node that has a synchronous service client and a timer calling this service. see the detailed example below. avoiding deadlocks ï setting up callback groups of a node incorrectly can lead to deadlocks (or other unwanted behavior), especially if one desires to use synchronous calls to services or actions. indeed, even the api documentation of ros 2 mentions that synchronous calls to actions or services should not be done in callbacks, because it can lead to deadlocks. while using asynchronous calls is indeed safer in this regard, synchronous calls can also be made to work. on the other hand, synchronous calls also have their advantages, such as making the code simpler and easier to understand. hence, this section provides some guidelines on how to set up a nodeâs callback groups correctly in order to avoid deadlocks. first thing to note here is that every nodeâs default callback group is a mutually exclusive callback group. if the user does not specify any other callback group when creating a timer, , client etc., any callbacks created then or later by these entities will use the nodeâs default callback group. furthermore, if everything in a node uses the same mutually exclusive callback group, that node essentially acts as if it was handled by a single-threaded executor, even if a multi-threaded one is specified! thus, whenever one decides to use a multi-threaded executor, some callback group(s) should always be specified in order for the executor choice to make sense. with the above in mind, here are a couple guidelines to help avoid deadlocks: if you make a synchronous call in any type of a callback, this callback and the client making the call need to belong to different callback groups (of any type), or a reentrant callback group. if the above configuration is not possible due to other requirements - such as thread-safety and/or blocking of other callbacks while waiting for the result (or if you want to make absolutely sure that there is never a possibility of a deadlock), use asynchronous calls. failing the first point will always cause a deadlock. an example of such a case would be making a synchronous service call in a timer callback (see the next section for an example). examples ï let us look at some simple examples of different callback group setups. the following demo code considers calling a service synchronously in a timer callback. demo code ï we have two nodes - one providing a simple service: c++ python #include <memory> #include "rclcpp/rclcpp.hpp" #include "std_srvs/srv/empty.hpp" using namespace std :: placeholders ; namespace cb_group_demo { class servicenode : public rclcpp :: node { public : servicenode () : node ( "service_node" ) { auto service_callback = [ this ]( const std :: shared_ptr < rmw_request_id_t > request_header , const std :: shared_ptr < std_srvs :: srv :: empty :: request > request , const std :: shared_ptr < std_srvs :: srv :: empty :: response > response ) { ( void ) request_header ; ( void ) request ; ( void ) response ; rclcpp_info ( this -> get_logger (), "received request, responding..." ); }; service_ptr_ = this -> create_service < std_srvs :: srv :: empty > ( "test_service" , service_callback ); } private : rclcpp :: service < std_srvs :: srv :: empty >:: sharedptr service_ptr_ ; }; // class servicenode } // namespace cb_group_demo int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); auto service_node = std :: make_shared < cb_group_demo :: servicenode > (); rclcpp_info ( service_node -> get_logger (), "starting server node, shut down with ctrl-c" ); rclcpp :: spin ( service_node ); rclcpp_info ( service_node -> get_logger (), "keyboard interrupt, shutting down. \n " ); rclcpp :: shutdown (); return 0 ; } import rclpy from rclpy.node import node from std_srvs.srv import empty class servicenode ( node ): def __init__ ( self ): super () . __init__ ( 'service_node' ) self . srv = self . create_service ( empty , 'test_service' , callback = self . service_callback ) def service_callback ( self , request , result ): self . get_logger () . info ( 'received request, responding...' ) return result if __name__ == '__main__' : rclpy . init () node = servicenode () try : node . get_logger () . info ( "starting server node, shut down with ctrl-c" ) rclpy . spin ( node ) except keyboardinterrupt : node . get_logger () . info ( 'keyboard interrupt, shutting down. \n ' ) node . destroy_node () rclpy . shutdown () and another containing a client to the service along with a timer for making service calls: c++ python note: the api of service client in rclcpp does not offer a synchronous call method similar to the one in rclpy, so we wait on the future object to simulate the effect of a synchronous call. #include <chrono> #include <memory> #include "rclcpp/rclcpp.hpp" #include "std_srvs/srv/empty.hpp" using namespace std :: chrono_literals ; namespace cb_group_demo { class demonode : public rclcpp :: node { public : demonode () : node ( "client_node" ) { client_cb_group_ = nullptr ; timer_cb_group_ = nullptr ; client_ptr_ = this -> create_client < std_srvs :: srv :: empty > ( "test_service" , rmw_qos_profile_services_default , client_cb_group_ ); auto timer_callback = [ this ](){ rclcpp_info ( this -> get_logger (), "sending request" ); auto request = std :: make_shared < std_srvs :: srv :: empty :: request > (); auto result_future = client_ptr_ -> async_send_request ( request ); std :: future_status status = result_future . wait_for ( 10 s ); // timeout to guarantee a graceful finish if ( status == std :: future_status :: ready ) { rclcpp_info ( this -> get_logger (), "received response" ); } }; timer_ptr_ = this -> create_wall_timer ( 1 s , timer_callback , timer_cb_group_ ); } private : rclcpp :: callbackgroup :: sharedptr client_cb_group_ ; rclcpp :: callbackgroup :: sharedptr timer_cb_group_ ; rclcpp :: client < std_srvs :: srv :: empty >:: sharedptr client_ptr_ ; rclcpp :: timerbase :: sharedptr timer_ptr_ ; }; // class demonode } // namespace cb_group_demo int main ( int argc , char * argv []) { rclcpp :: init ( argc , argv ); auto client_node = std :: make_shared < cb_group_demo :: demonode > (); rclcpp :: executors :: multithreadedexecutor executor ; executor . add_node ( client_node ); rclcpp_info ( client_node -> get_logger (), "starting client node, shut down with ctrl-c" ); executor . spin (); rclcpp_info ( client_node -> get_logger (), "keyboard interrupt, shutting down. \n " ); rclcpp :: shutdown (); return 0 ; } import rclpy from rclpy.executors import multithreadedexecutor from rclpy.callback_groups import mutuallyexclusivecallbackgroup , reentrantcallbackgroup from rclpy.node import node from std_srvs.srv import empty class callbackgroupdemo ( node ): def __init__ ( self ): super () . __init__ ( 'client_node' ) client_cb_group = none timer_cb_group = none self . client = self . create_client ( empty , 'test_service' , callback_group = client_cb_group ) self . call_timer = self . create_timer ( 1 , self . _timer_cb , callback_group = timer_cb_group ) def _timer_cb ( self ): self . get_logger () . info ( 'sending request' ) _ = self . client . call ( empty . request ()) self . get_logger () . info ( 'received response' ) if __name__ == '__main__' : rclpy . init () node = callbackgroupdemo () executor = multithreadedexecutor () executor . add_node ( node ) try : node . get_logger () . info ( 'beginning client, shut down with ctrl-c' ) executor . spin () except keyboardinterrupt : node . get_logger () . info ( 'keyboard interrupt, shutting down. \n ' ) node . destroy_node () rclpy . shutdown () the client nodeâs constructor contains options for setting the callback groups of the service client and the timer. with the default setting above (both being nullptr / none ), both the timer and the client will use the nodeâs default mutually exclusive callback group. the problem ï since we are making service calls with a 1 second timer, the expected outcome is that the service gets called once a second, the client always gets a response and prints received response . if we try running the server and client nodes in terminals, we get the following outputs. client server [info] [1653034371.758739131] [client_node]: starting client node, shut down with ctrl-c [info] [1653034372.755865649] [client_node]: sending request ^c[info] [1653034398.161674869] [client_node]: keyboard interrupt, shutting down. [info] [1653034355.308958238] [service_node]: starting server node, shut down with ctrl-c [info] [1653034372.758197320] [service_node]: received request, responding... ^c[info] [1653034416.021962246] [service_node]: keyboard interrupt, shutting down. so, it turns out that instead of the service being called repeatedly, the response of the first call is never received, after which the client node seemingly gets stuck and does not make further calls. that is, the execution stopped at a deadlock! the reason for this is that the timer callback and the client are using the same mutually exclusive callback group (the nodeâs default). when the service call is made, the client then passes its callback group to the future object (hidden inside the call-method in the python version) whose done-callback needs to execute for the result of the service call to be available. but because this done-callback and the timer callback are in the same mutually exclusive group and the timer callback is still executing (waiting for the result of the service call), the done-callback never gets to execute. the stuck timer callback also blocks any other executions of itself, so the timer does not fire for a second time. solution ï we can fix this easily - for example - by asg the timer and client to different callback groups. thus, let us change the first two lines of the client nodeâs constructor to be as follows (everything else shall stay the same): c++ python client_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); timer_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); client_cb_group = mutuallyexclusivecallbackgroup () timer_cb_group = mutuallyexclusivecallbackgroup () now we get the expected result, i.e. the timer fires repeatedly and each service call gets the result as it should: client server [info] [1653067523.431731177] [client_node]: starting client node, shut down with ctrl-c [info] [1653067524.431912821] [client_node]: sending request [info] [1653067524.433230445] [client_node]: received response [info] [1653067525.431869330] [client_node]: sending request [info] [1653067525.432912803] [client_node]: received response [info] [1653067526.431844726] [client_node]: sending request [info] [1653067526.432893954] [client_node]: received response [info] [1653067527.431828287] [client_node]: sending request [info] [1653067527.432848369] [client_node]: received response ^c[info] [1653067528.400052749] [client_node]: keyboard interrupt, shutting down. [info] [1653067522.052866001] [service_node]: starting server node, shut down with ctrl-c [info] [1653067524.432577720] [service_node]: received request, responding... [info] [1653067525.432365009] [service_node]: received request, responding... [info] [1653067526.432300261] [service_node]: received request, responding... [info] [1653067527.432272441] [service_node]: received request, responding... ^c[info] [1653034416.021962246] [service_node]: keyboardinterrupt, shutting down. one might consider if just avoiding the nodeâs default callback group is enough. this is not the case: replacing the default group by a different mutually exclusive group changes nothing. thus, the following configuration also leads to the previously discovered deadlock. c++ python client_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); timer_cb_group_ = client_cb_group_ ; client_cb_group = mutuallyexclusivecallbackgroup () timer_cb_group = client_cb_group in fact, the exact condition with which everything works in this case is that the timer and client must not belong to the same mutually exclusive group. hence, all of the following configurations (and some others as well) produce the desired outcome where the timer fires repeatedly and service calls are completed. c++ python client_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: reentrant ); timer_cb_group_ = client_cb_group_ ; or client_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); timer_cb_group_ = nullptr ; or client_cb_group_ = nullptr ; timer_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: mutuallyexclusive ); or client_cb_group_ = this -> create_callback_group ( rclcpp :: callbackgrouptype :: reentrant ); timer_cb_group_ = nullptr ; client_cb_group = reentrantcallbackgroup () timer_cb_group = client_cb_group or client_cb_group = mutuallyexclusivecallbackgroup () timer_cb_group = none or client_cb_group = none timer_cb_group = mutuallyexclusivecallbackgroup () or client_cb_group = reentrantcallbackgroup () timer_cb_group = none other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling