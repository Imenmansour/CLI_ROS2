the ros 2 project contributing windows tips and tricks edit on github windows tips and tricks ï ros 2 supports windows 10 as a tier 1 platform, which means that all code that goes into the ros 2 core must support windows. for those used to traditional development on linux or other unix-like systems, developing on windows can be a bit of a challenge. this document aims to lay out some of those differences. maximum path length ï by default, windows has a maximum path length of 260 characters. practically speaking, 4 of those characters are always used by the drive letter, colon, initial backslash, and final null character. that means that only 256 characters are available for the sum of all parts of the path. this has two practical consequences for ros 2: some of the ros 2 internal path names are fairly long. because of this, we always recommend using a short path name for the root of your ros 2 directory, like c:\dev . when building ros 2 from source, the default isolated build mode of colcon can generate very long path names. to avoid these very long path names, use --merge-install when building on windows. note : it is possible to change windows to have much longer maximum path lengths. see this article for more information. symbol visibility ï the microsoft visual c++ compiler (msvc) exposes symbols from a dynamic link library (dll) only if they are explicitly exported. the clang and gcc compilers have an option to do the same, but it is off by default. as a result, when a library previously built on linux is built on windows, other libraries may be unable to resolve the external symbols. below are examples of common error messages which can be caused by symbols not being exposed: error c2448: '__attribute__': function-style initializer appears to be a function definition 'visibility': identifier not found cmake error at c:/ws_ros2/install/random_numbers/share/random_numbers/cmake/ament_cmake_export_libraries-extras.cmake:48 (message): package 'random_numbers' exports the library 'random_numbers' which couldn't be found symbol visibility also impacts binary loading. if you are finding that a composable node does not run or a qt visualizer isnât working, it may be that the hosting process can not find an expected symbol export from the binary. to diagnose this on windows, the windows developer tools includes a program called gflags to enable various options. one of those options is called loader snaps which enables you to detect load failures while debugging.  visit the microsoft documentation for more information on gflags and loaders snaps . two solutions to export symbols on windows are visibility control headers and the windows_export_all_symbols property. microsoft recommends ros developers use visibility control headers to control the export of symbols from a binary. visibility control headers provide more control over the symbol export macro and offer other benefits including smaller binary size and reduced link times. visibility control headers ï the purpose of visibility control headers headers is to define a macro for each shared library which correctly declares symbols as dllimport or dllexport. this is decided based on whether the library is being consumed or being built itself. the logic in the macro also takes the compiler into account and includes logic to select the appropriate syntax. the gcc visibility documentation includes step by step instructions for adding explicit symbol visibility to a library âyielding the highest quality code with the greatest reductions in binary size, load times and link timesâ. a header named visibility_control.h can be placed in the includes folder for each library as shown in the example below. the example below shows how a visibility control header would be added for a my_lib library with a class called example_class . add a visibility header to the include folder for the library. the boiler plate logic is used with the library name used in the macro to make it unique in the project. in another library, my_lib would be replaced with the library name. #ifndef my_lib__visibility_control_h_ #define my_lib__visibility_control_h_ #if defined _win32 || defined __cygwin__ #ifdef __gnuc__ #define my_lib_export __attribute__ ((dllexport)) #define my_lib_import __attribute__ ((dllimport)) #else #define my_lib_export __declspec(dllexport) #define my_lib_import __declspec(dllimport) #endif #ifdef my_lib_building_library #define my_lib_public my_lib_export #else #define my_lib_public my_lib_import #endif #define my_lib_public_type my_lib_public #define my_lib_local #else // linux visibility settings #define my_lib_public_type #endif #endif // my_lib__visibility_control_h_ for a complete example of this header, see rviz_rendering . to use the macro, add my_lib_public before symbols which need to be visible to external libraries. for example: class my_lib_public example_class {} my_lib_public void example_function (){} in order to build your library with correctly exported symbols, you will need to add the following to your cmakelists.txt file: target_compile_definitions ( { project_name } private "my_lib_building_library" ) windows_export_all_symbols target property ï cmake implements the windows_export_all_symbols property on windows, which causes function symbols to be automatically exported. more detail of how it works can be found in the windows_export_all_symbols cmake documentation . the property can be implemented by adding the following to the cmakelists file: set_target_properties ( { lib_name } properties windows_export_all_symbols true ) if there is more than one library in a cmakelists file you will need to call set_target_properties on each of them separately. note that a binary on windows can only export 65,536 symbols. if a binary exports more than that, you will get an error and should use the visibility_control headers. there is an exception to this method in the case of global data symbols. for example, a global static data member like the one below. class example_class { public : static const int global_data_num ; in these cases dllimprort/dllexport must be applied explicitly. this can be done using generate_export_header as described in the following article: create dlls on windows without declspec() using new cmake export all feature . finally, it is important that the header file that exports the symbols be included into at least one of the .cpp files in the package so that the macros will get expanded and placed into the resulting binary. otherwise the symbols will still not be callable. debug builds ï when building in debug mode on windows, several very important things change. the first is that all dlls get _d automatically appended to the library name. so if the library is called libfoo.dll , in debug mode it will be libfoo_d.dll . the dynamic linker on windows also knows to look for libraries of that form, so it will not find libraries without the _d prefix. additionally, windows turns on a whole set of compile-time and run-time checks in debug mode that is far more strict than release builds. for these reasons, it is a good idea to run a windows debug build and test on many pull requests. forward-slash vs. back-slash ï in windows the default path separator is a backslash ( \ ), which differs from the forward-slash ( / ) used in linux and macos. most of the windows apis can deal with either as a path separator, but this is not universally true. for instance, the cmd.exe shell can only do tab-completion when using the backslash character, not the forward-slash. for maximum compatibility on windows, a backslash should always be used as the path separator on windows. patching vendored packages ï when vendoring a package in ros 2, it is often necessary to apply a patch to fix a bug, add a feature, etc. the typical way to do this is to modify the externalproject_add call to add a patch command, using the patch executable. unfortunately, the patch executable as delivered by chocolatey requires administrator access to run. the workaround is to use git apply-patch when applying patches to external projects. git apply-patch has its own issues in that it only works properly when applied to a git repository. for that reason, external projects should always use the git method to obtain the project and then use the patch_command to invoke git apply-patch . an example usage of all of the above looks something like: externalproject_add ( mylibrary- { version } git_repository https://github.com/lib/mylibrary.git git_tag { version } git_config advice.detachedhead=false # suppress git update due to https://gitlab.kitware.com/cmake/cmake/-/issues/16419 # see https://github.com/ament/uncrustify_vendor/pull/22 for details update_command "" timeout 600 cmake_args -dcmake_install_prefix= { cmake_current_binary_dir } / { project_name } _install { extra_cmake_args } -wno-dev patch_command { cmake_command } -e chdir <source_dir> git apply -p1 --ignore-space-change --whitespace=nowarn { cmake_current_source_dir } /install-patch.diff ) windows slow timers (slowness in general) ï software running on windows is, in general, much slower than that running on linux. this is due to a number of factors, from the default time slice (every 20 ms, according to the documentation ), to the number of anti-virus and anti-malware processes running, to the number of background processes running. because of all of this, tests should never expect tight timing on windows. all tests should have generous timeouts, and only expect events to happen eventually (this will also prevent tests from being flakey on linux). shells ï there are two main command-line shells on windows: the venerable cmd.exe , and powershell. cmd.exe is the command shell that most closely emulates the old dos shell, though with greatly enhanced capabilities. it is completely text based, and only understands dos/windows batch files. powershell is the newer, object-based shell that microsoft recommends for most new applications. it understands ps1 files for configuration. ros 2 supports both cmd.exe and powershell, so any changes (especially to things like ament or colcon ) should be tested on both. other versions v: jazzy releases jazzy (latest) iron humble galactic (eol) foxy (eol) eloquent (eol) dashing (eol) crystal (eol) in development rolling