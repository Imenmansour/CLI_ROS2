light rust coal navy ayu programming multiple robots with ros 2 the ros command line interface the ros command line interface, or cli for short, is a set of programs for starting, inspecting, controlling, and monitoring a ros robot. the best way to think of the cli is a collection of small and simple programs that allow you perform basic tasks in ros. drawing from our car analogy, the cli can be thought of as the subsystems of a vehicle: the breaks, the transmission, the window wipers, all of the smaller parts that are composed together to build the larger vehicle. what we'll show you in this section is how to turn on the car, put it in gear, turn on the radio, and perhaps check your oil to perform routine maintenance. the ros 2 cli draws heavily from the unix/linux philosophy of small programs that can be composed together. if you are familiar with the command line interface found in unix and linux, or to a lesser extent in macos or windows, you'll feel right at home. the ros command line tools draw heavily from the design patterns mentioned in the previous section, and directly interface with the apis we will address in the next section. the cli interface is at its core just a set of simple tools built from the ros 2 api; this api is simply an implementation of the high-level patterns we discussed in the previous section. if your goal is to simply interface with a particular piece of software written using ros, the cli interface is the way you will go  starting, stopping, and controlling the underlying ros software. for more advanced users these tools will allow you to study a ros system by exploring the underlying software processes in the system. there are only two things you need to memorize from this section. the first command simply tells your computer that you are using ros, and what version of ros you want to use. let's take a look at the magic command: source /opt/ros/eloquent/setup.bash if everything is working correctly, this command should simply return. nothing happens that you can see, but underneath the hood you've just told this particular shell that you are using ros 2 eloquent elusor, and where all the ros programs and files live. you should plan on doing this every time you want to use ros. the most common mistake new users have is not running this command. if you're not sure if you ran the command in a shell, that's okay. the command is idempotent; running it twice in a row won't break anything. you can run it a million times in a row and it won't make any difference. the other command you need to commit to memory is ros2 . almost everything in the ros 2 cli starts with ros2 . go ahead and try it in the same shell where you just sourced the setup file. if everything is working correctly you should see the following:  ros2 usage: ros2 [-h] call `ros2 <command> -h` for more detailed usage. ... ros2 is an extensible command-line tool for ros 2. optional arguments: -h, --help show this help message and exit commands: action various action related sub-commands component various component related sub-commands daemon various daemon related sub-commands doctor check ros setup and other potential issues interface show information  ros interfaces launch run a launch file lifecycle various lifecycle related sub-commands msg various msg related sub-commands multicast various multicast related sub-commands node various node related sub-commands param various param related sub-commands pkg various package related sub-commands run run a package specific executable security various security related sub-commands service various service related sub-commands srv various srv related sub-commands topic various topic related sub-commands wtf use `wtf` as alias to `doctor` call `ros2 <command> -h` for more detailed usage. from this one command you can figure out what every single ros 2 cli program does and how to use it. the ros 2 cli has a syntax just like most languages. all ros cli commands start with ros2 , followed by a command. after the command any number of other things can come; you can append --help or -h to see the documentation and find out what arguments any of the commands are expecting. the rest of this section just walks through each of the commands one by one. writing commands using the command line is tricky and error prone. there are a couple of tools you can use to make the process much smoother. the first is the tab key, which attempts to auto complete whatever you type. it can't read your mind, but for common command combinations you usually only need to type the first one or two letters. another tool is the up arrow key. when you use the command line sometimes you mistype a command, or need to rerun a command. pressing the up key will cycle through the previous commands which you can modify and rerun as needed. running your first ros program let's get started with our first ros cli command. the first command we'll visit is run . let's start by looking at the documentation for the run command:  ros2 run usage: ros2 run [-h] [--prefix prefix] package_name executable_name ... ros2 run: error: the following arguments are required: package_name, executable_name, argv to get more complete information  a ros 2 command, simply ask the command for help by adding --help to the command. let's try that again:  ros2 run --help usage: ros2 run [-h] [--prefix prefix] package_name executable_name ... run a package specific executable positional arguments: package_name name of the ros package executable_name name of the executable argv pass arbitrary arguments to the executable optional arguments: -h, --help show this help message and exit --prefix prefix prefix command, which should go before the executable. command must be wrapped in quotes if it contains spaces (e.g. --prefix 'gdb -ex run --args'). we can see that ros2 run is the command to, "run a package specific executable." in ros 2 collections of ros software are gathered into logical units called packages . each package contains all of the source code for the package as a variety of other data that tells ros how to build and compile the package and the names of all the programs, also called executables , that can be found in the package. the line below the description then gives the positional arguments for the package. positional arguments are the words and values that come after ros2 and the command you run. in this case the syntax for the command sentence we want to write is as follows: ros2 run <package name> <program/executable name> <args> there is one piece of missing information here. what is this argv that the command is asking for? the argv element is programmer short hand for variable arguments, and it simply means, "some number of additional arguments that are determined by the executable". it is worth noting that a program can have zero arguments and you can just leave it blank. this is actually how a lot of programs work. for example, say we had a package called math , and an executable called add that takes in two numbers and returns the result. in this case argv would be the two numbers to add. the final command would look like: ros2 run math add 1 2 finally, below the positional arguments we have optional arguments . you don't need to included them, unless you need to. now that we've looked into our help file let's run our first ros program. for these tutorials we're going to use a package called turtlesim , and the program we want to run is turtlesim_node . let's run this program (remember your tab complete!). your command should look like the following: ros2 run turtlesim turtlesim_node if everything goes smoothly you should see the following: [info] [turtlesim]: starting turtlesim with node name /turtlesim [info] [turtlesim]: spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000] a window should also pop up with a cute little turtle that looks like the one below: the real power in ros isn't that it can run a program, it is that it can run lots of programs all at the same time, all talking together to control a robot, or multiple robots, all working together. to illustrate this let's run a second ros program that makes our little turtle move around. to do this we'll first open a new terminal (using ctrl-shift-t ). next we'll tell that terminal that we want to use ros eloquent by using the source command. finally, we'll run another program in the turtlesim package to draw a square. see if you can find the program yourself (hint: use tab ). if everything works you should have typed the following, and the following output should be visible:  source /opt/ros/eloquent/setup.bash  ros2 run turtlesim draw_square [info] [draw_square]: new goal [7.544445 5.544445, 0.000000] [info] [draw_square]: reached goal [info] [draw_square]: new goal [7.448444 5.544445, 1.570796] [info] [draw_square]: reached goal your screen should look roughly like this: it is worth noting that you can stop any ros program by pressing the ctrl and c keys at the same time in the terminal; we call this ctrl-c (note that ctrl-shift-c and ctrl-shift-v are responsible for copy and paste in a linux terminal). feel free to try it out. start and stop the programs, and then restart them before moving on. ros topics we now have two ros 2 programs running from the turtlesim package. there is turtle_node that opens our turtle simulation, and draw_square that makes the turtle in turtle_node move around. how are these two programs communicating? ros programs, also called nodes , communicate over topics on the ros message bus . ros topics use namespaces to distinguish themselves. for example, in a vehicle running ros, the positions of each wheel may be organized as follows: /wheels/front/driver/velocity /wheels/front/passenger/velocity /wheels/rear/driver/velocity /wheels/rear/passenger/velocity the key thing to realize  topics is that the data they contain is dynamic, meaning it changes constantly. in our vehicle example the velocity of each wheel might be measured one thousand times a second or more. since the data in a ros topic is constantly changing, an important distinction for a topic is whether the topic is "creating" or as we like to say in ros publishing , or if it is reading the data, what we call subscribing to the topic. many ros nodes subscribe to one set of topics, process that input data, and then publish to another set of topics. let's return to our turtlesim example and see if we can use the ros cli to understand the topics, publishers, and subscribers. to see sub commands and syntax for the topic command, we'll run: ros2 topic --help . this command outputs the following:  ros2 topic --help usage: ros2 topic [-h] [--include-hidden-topics] call `ros2 topic <command> -h` for more detailed usage. ... various topic related sub-commands optional arguments: -h, --help show this help message and exit --include-hidden-topics consider hidden topics as well commands: bw display bandwidth used by topic delay display delay of topic from timestamp in header echo output messages from a topic find output a list of available topics of a given type hz print the average publishing rate to screen info print information  a topic list output a list of available topics pub publish a message to a topic type print a topic's type call `ros2 topic <command> -h` for more detailed usage. there are quite a few sub commands; we won't discuss all of them, but let's look closely at a few. sub commands have their own help command. why don't we examine the list command. repeating our command pattern let's try running ros2 topic list --help . usage: ros2 topic list [-h] [--spin-time spin_time] [-t] [-c] [--include-hidden-topics] output a list of available topics optional arguments: -h, --help show this help message and exit --spin-time spin_time spin time in seconds to wait for discovery (only applies when not using an already running daemon) -t, --show-types additionally show the topic type -c, --count-topics only display the number of topics discovered --include-hidden-topics consider hidden topics as well as indicated at the top of this command help file, ros2 topic list will "output a list of available topics." there appears to be a variety of optional arguments that we don't need to include if we don't want to. however, the -t, --show-types line looks interesting. it is worth noting that command arguments, sometimes called flags, can have two types. a short form indicated with a single dash ("-"), and a long form indicated by a double dash ("--"). don't worry, despite looking different both versions of the argument do the same thing. let's try running this command, sub command pair with the -show-types argument.  ros2 topic list --show-types /parameter_events [rcl_interfaces/msg/parameterevent] /rosout [rcl_interfaces/msg/log] /turtle1/cmd_vel [geometry_msgs/msg/twist] /turtle1/color_sensor [turtlesim/msg/color] /turtle1/pose [turtlesim/msg/pose] on the left hand side we see all of the ros topics running on the system, each starting with / . we can see that most of them are gathered in the /turtle1/ group. this group defines all the inputs and outputs of the little turtle on our screen. the words in brackets ( [] ) to the right of the topic names define the messages used on the topic. our car wheel example was simple, we were only publishing velocity, but ros allows you to publish more complex data structures that are defined by a message type . when we added the --show-types flag we told the command to include this information. we'll dig into messages in detail a bit later. one of the more commonly used topic sub commands is info . unsurprisingly, info provides info  a topic. let's peek at its help file using ros2 topic info --help  ros2 topic info --help usage: ros2 topic info [-h] topic_name print information  a topic positional arguments: topic_name name of the ros topic to get info (e.g. '/chatter') optional arguments: -h, --help show this help message and exit that seems pretty straight forward. let's give it a go by running it on /turtle1/pose  ros2 topic info /turtle1/pose type: turtlesim/msg/pose publisher count: 1 subscriber count: 1 what does this command tell us? first it tells us the message type for the /turtle1/pose topic, which is /turtlesim/msg/pose . from this we can determine that the message type comes from the turtlesim package, and its type is pose . ros messages have a predefined message type that can be shared by different programming languages and between different nodes. we can also see that this topic has a single publisher, that is to say a single node generating data on the topic. the topic also has a single subscriber, also called a listener, who is processing the incoming pose data. if we only wanted to know the message type of a topic there is a sub command just for that called, type . let's take a look at its help file and its result:  ros2 topic type --help usage: ros2 topic type [-h] topic_name print a topic's type positional arguments: topic_name name of the ros topic to get type (e.g. '/chatter') optional arguments: -h, --help show this help message and exit kscottz@kscottz-ratnest:~/code/ros2multirobotbook ros2 topic type /turtle1/pose turtlesim/msg/pose while it is not part of the topic command it is worthwhile for us to jump ahead briefly and look at one particular command, sub command pair, namely the interface command and the show sub command. this sub command will print all the information related to a message type so you can better understand the data being moved over a topic. in the previous example we saw that the topic type sub command told us the /turtle1/pose topic has a type turtlesim/msg/pose . but what does turtlesim/msg/pose data look like? we can look at the data structure transferred by this topic by running the ros2 interface show sub command and giving the message type name as an input. let's look at the help for this sub command and its output:  ros2 interface show --help usage: ros2 interface show [-h] type output the interface definition positional arguments: type show an interface definition (e.g. "std_msgs/msg/string") optional arguments: -h, --help show this help message and exit  ros2 interface show turtlesim/msg/pose float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity we can see the values x and y which are the position coordinates of our turtle, and that they are of type float32 . theta is the direction the head is pointing. the next two values, linear_velocity and angular_velocity , are how fast the turtle is moving and how quickly it is turning, respectively. to summarize, this message tells us where a turtle is on the screen, where it is headed, and how fast it is moving or rotating. now that we know what ros topics are on our simple turtlesim, and their message types, we can dig in and find out more  how everything works. if we look back at our topic sub commands, we can see a sub command called echo . echo is computer jargon that means "repeat" something. if you echo a topic it means you want the cli to repeat what's on a topic. let's look at the echo sub command's help text:  ros2 topic echo --help usage: ros2 topic echo [-h] [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}] [--qos-reliability {system_default,reliable,best_effort}] [--qos-durability {system_default,transient_local,volatile}] [--csv] [--full-length] [--truncate-length truncate_length] [--no-arr] [--no-str] topic_name [message_type] output messages from a topic positional arguments: topic_name name of the ros topic to listen to (e.g. '/chatter') message_type type of the ros message (e.g. 'std_msgs/string') optional arguments: -h, --help show this help message and exit --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default} quality of service preset profile to subscribe with (default: sensor_data) --qos-reliability {system_default,reliable,best_effort} quality of service reliability setting to subscribe with (overrides reliability value of --qos-profile option, default: best_effort) --qos-durability {system_default,transient_local,volatile} quality of service durability setting to subscribe with (overrides durability value of --qos-profile option, default: volatile) --csv output all recursive fields separated by commas (e.g. for plotting) --full-length, -f output all elements for arrays, bytes, and string with a length > '--truncate-length', by default they are truncated after '--truncate-length' elements with '...'' --truncate-length truncate_length, -l truncate_length the length to truncate arrays, bytes, and string to (default: 128) --no-arr don't print array fields of messages --no-str don't print string fields of messages wow, that's a lot of features. the top of the help files says that this cli program "output[s] messages from a topic." as we scan the positional arguments we see one required argument, a topic name, and an optional message type. we know the message type is optional because it has square brackets ( [] ) around it. let's give the simple case a whirl before we address some of the optional elements. two things to keep in mind: first is that topics are long and easy to mess up, so use the tab key. second is that this will print a lot of data, fast. you can use ctrl-c to stop the command and stop all the output. let's take a look at the /turtle1/pose topic.  ros2 topic echo /turtle1/pose x: 5.4078755378723145 y: 7.081490516662598 theta: -1.0670461654663086 linear_velocity: 1.0 angular_velocity: 0.0 --- x: 5.4155988693237305 y: 7.067478179931641 theta: -1.0670461654663086 linear_velocity: 1.0 angular_velocity: 0.0 --- x: 5.423322677612305 y: 7.053465843200684 theta: -1.0670461654663086 linear_velocity: 1.0 angular_velocity: 0.0 --- <<going on forever>> let's examine what is going on. between the dashes ( --- ) is a single ros message on our topic. if you examine the numbers closely you can see that they are changing, and doing so in relation to the movement of the turtle. going back to our car example you can see how this would be useful for understanding the instantaneous velocity of each of our wheels. now that we have the basics down let's dig into a few of the optional arguments. we see a variety of commands that start with --qos . "qos" here means "quality of service" and it is a really cool feature that is only in ros 2. without getting too technical, qos is a way of asking for a certain level of networking robustness. a ros system can operate over a network, and just like streaming video or video games, packets can get dropped or not get to their destination. the os settings help you control which packets are the most important and should get the highest priority. most of the other commands deal with changing the output format of this cli program, but there is one in particular that is super handy, and it is also new in ros 2. the --csv flag stands for "comma separated values" and it a very simple way of defining a spreadsheet. what this argument does is make the topic echo command output data in the comma separate value format. many command lines allow you send data from the screen to a file, saving the data for later review or analysis. to do this file saving in linux we use the > character followed by a file name. below are two examples of using the --csv argument:  ros2 topic echo /turtle1/pose --csv 7.097168922424316,8.498645782470703,2.442624092102051,0.0,0.4000000059604645 7.097168922424316,8.498645782470703,2.449024200439453,0.0,0.4000000059604645 ... <<ctrl-c>>  ros2 topic echo /turtle1/pose --csv > mydata.csv <<nothing happens>> <<ctrl-c>> the second command above creates a file called mydata.csv . you can look at it using a cli utility called less (press q to quit), or open it with your favorite spreadsheet tool. now that we've looked at ros2 topic echo let's take a look at a few other topic sub commands. one thing you may have noticed is that topics can output a lot of data! more complex robots, like a self driving car, can saturate a high speed internet connection with how much data it produces. there are two topic sub commands that can be used to diagnose performance issues. the first sub command is topic hz which is the abbreviation of hertz, the unit of frequency. the hz sub command will tell you how often a particular topic produces a message. similarly there is the topic bw sub command, where bw stands for bandwidth, which is a engineering term related to the volume of data being produced. a high bandwidth connection can move more data, like high definition video, than a low bandwidth data, which might move a radio show. let's take a look at the help for these two commands:  ros2 topic hz --help usage: ros2 topic hz [-h] [--window window] [--filter expr] [--wall-time] topic_name print the average publishing rate to screen positional arguments: topic_name name of the ros topic to listen to (e.g. '/chatter') optional arguments: -h, --help show this help message and exit --window window, -w window window size, in # of messages, for calculating rate (default: 10000) --filter expr only measure messages matching the specified python expression --wall-time calculates rate using wall time which can be helpful when clock is not published during simulation  ros2 topic bw --help usage: ros2 topic bw [-h] [--window window] topic display bandwidth used by topic positional arguments: topic topic name to monitor for bandwidth utilization optional arguments: -h, --help show this help message and exit --window window, -w window window size, in # of messages, for calculating rate (default: 100) both bw and hz follow the same pattern, they simply take in a topic name followed by a few optional arguments. the only argument worth noting is the window argument. both of these commands calculate statistics for a series of messages; how many messages to use in calculating those statistics is the window size. the default value for window is 100, so when you call ros2 topic bw it will first collect 100 messages then use that data to calculate the average message size. let's give it a shot (use tab to complete and ctrl-c to exit).  ros2 topic hz /turtle1/pose average rate: 60.021 min: 0.001s max: 0.073s std dev: 0.00731s window: 65 average rate: 61.235 min: 0.001s max: 0.073s std dev: 0.00523s window: 128  ros2 topic bw /turtle1/pose subscribed to [/turtle1/pose] average: 1.44kb/s mean: 0.02kb/s min: 0.02kb/s max: 0.02kb/s window: 46 average: 1.52kb/s mean: 0.02kb/s min: 0.02kb/s max: 0.02kb/s window: 100 as we can see above, the hz command says that the topic is publishing messages at 60.021, where the unit is hz, or 60.021 times a second. notice that the command gives the publishing frequency as an average, followed by the minimum, maximum, and standard deviation, in seconds. the bandwidth sub command is very similar; and we can see that the topic is producing 1.44 kilobytes of data per second. this command has similar outputs around the minimum, maximum, and mean. one tool that is handy when exploring topics is understanding their type. while we have already looked at the interface command to see what integral types make up a topic, the topic command has both a tool to query the type of a topic, and a means to search all topics for a specific type. if all you want to know is a topic's type you can use the type command which will return a type that can then be further explored with the interface command. if instead you would like to know what topics use a particular message type you can use the topic find command, sub command pair. both the topic type and topic interface command, sub command pairs have a very limited set of optional arguments, so we simply provide them with our desired topic or message type. let's take a look at these two commands together:  ros2 topic type --help usage: ros2 topic type [-h] topic_name print a topic's type positional arguments: topic_name name of the ros topic to get type (e.g. '/chatter') optional arguments: -h, --help show this help message and exit  ros2 topic type /turtle1/pose turtlesim/msg/pose  ros2 topic find --help usage: ros2 topic find [-h] [-c] [--include-hidden-topics] topic_type output a list of available topics of a given type positional arguments: topic_type name of the ros topic type to filter for (e.g. 'std_msg/msg/string') optional arguments: -h, --help show this help message and exit -c, --count-topics only display the number of topics discovered --include-hidden-topics consider hidden topics as wel  ros2 topic find turtlesim/msg/pose /turtle1/pose the last sub command for the topic command is pub , which simply means publish. it allows you to publish a command to any ros topic from the command line. while you shouldn't need to use this command regularly it can be particularly handy for testing and debugging when you are building a robot system. the pub command has a number of optional arguments that allow you to send one or more messages, and with different quality of service (qos) presets. the format of the command is ros2 topic pub topic_name message_type values , which means for it to work successfully you must include a target topic, the topic's message type, and finally the message's values. the values for the message are specified in the yaml format and we can use the interface show command to understand the format. to illustrate the utility of this command we'll issue a message to rotate and stop our turtle by publishing to the /turtle1/cmd_vel/ topic. let's first take a look at the topic pub documentation before we construct our command:  ros2 topic pub --help usage: ros2 topic pub [-h] [-r n] [-p n] [-1] [-n node_name] [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}] [--qos-reliability {system_default,reliable,best_effort}] [--qos-durability {system_default,transient_local,volatile}] topic_name message_type [values] publish a message to a topic positional arguments: topic_name name of the ros topic to publish to (e.g. '/chatter') message_type type of the ros message (e.g. 'std_msgs/string') values values to fill the message with in yaml format (e.g. "data: hello world"), otherwise the message will be published with default values optional arguments: -h, --help show this help message and exit -r n, --rate n publishing rate in hz (default: 1) -p n, --print n only print every n-th published message (default: 1) -1, --once publish one message and exit -n node_name, --node-name node_name name of the created publishing node --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default} quality of service preset profile to publish with (default: system_default) --qos-reliability {system_default,reliable,best_effort} quality of service reliability setting to publish with (overrides reliability value of --qos-profile option, default: system_default) --qos-durability {system_default,transient_local,volatile} quality of service durability setting to publish with (overrides durability value of --qos-profile option, default: system_default) since we want to manually move our turtle we will use the --once flag to issue our command once. it is worth noting that the message type used to command the velocity of the turtle is complex in that it is made up of other message types so we'll have to query the base message type. here's a rough summary of what we will do: print the cmd_vel topic type using ros2 topic type , which is geometry_msgs/msg/twist determine the structure of the twist message type using interface show . determine the structure of the vector3 , which is part of the twist message type using inteface show command a second time. create the yaml syntax for our command. note the yaml syntax below as it is rather tricky! the yaml is wrapped in single quotes and a top level set of curly braces, while subsequent levels follow the pattern of name:value , and name:{name1:val1,name2:val2} for nested types like the twist command. issue the command using ros2 pub .  ros2 topic type /turtle1/cmd_vel geometry_msgs/msg/twist  ros2 interface show geometry_msgs/msg/twist # this expresses velocity in free space broken into its linear and angular parts. vector3 linear vector3 angular  ros2 interface show geometry_msgs/msg/vector3 # this represents a vector in free space. float64 x float64 y float64 z  ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/twist '{linear: {x: 4.0,y: 4.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' if you did everything correctly you should have moved around the turtle on the screen. try changing the command to draw a small picture. ros 2 services and actions as discussed previously, services are the name given to short, synchronous robot behaviors that can be done quickly, like turning on lights and switching components on or off. actions are longer term, asynchronous, tasks that may have intermediate steps. a classic example of an action is navigation: a robot is provided a goal position and asked to navigate to that goal. try as the robot might, since it cannot move infinitely fast, it takes time to move to a goal and sometimes its path may become blocked. these two primitives are the backbone of most robotic systems using ros, and learning how to use them via the command line will allow you quickly and easily command a robot to complete a task for you. to aid in clarity of this section we'll also touch on the ros2 node command to determine what node, or software process, is conducting a particular action or service. let's get nodes out of the way quickly. ros nodes are small programs, running in their own process. a ros system can have ten, hundreds, or even thousands of nodes running concurrently. moreover, a ros system can have multiple copies of the same node running concurrently on the same system. in the case of our turtle simulation we can actually create multiple turtles, each with their own node, all running the exact same program. ros nodes, like ros topics, have namespaces so that you can address specific nodes in the case where multiple copies of the same node (program) are running. let's dig in a bit by restarting our turtle simulation in a terminal using ros2 run turtlesim turtlesim_node . now in a new terminal let's first examine what ros2 node has to offer by asking for help.  ros2 node --help usage: ros2 node [-h] call `ros2 node <command> -h` for more detailed usage. ... various node related sub-commands optional arguments: -h, --help show this help message and exit commands: info output information  a node list output a list of available nodes call `ros2 node <command> -h` for more detailed usage. much like topics, we see two sub commands, info and list . node list works much the same as topic list and simply prints a list of all running nodes. let's see what is running on our system:  ros2 node list /turtlesim we have a single node running called "turtlesim". node info works in a way very similar to topic info except that it lists information  the nodes we give it. let's call it with our single ros node /turtlesim as its argument:  ros2 node info /turtlesim /turtlesim subscribers: /parameter_events: rcl_interfaces/msg/parameterevent /turtle1/cmd_vel: geometry_msgs/msg/twist publishers: /parameter_events: rcl_interfaces/msg/parameterevent /rosout: rcl_interfaces/msg/log /turtle1/color_sensor: turtlesim/msg/color /turtle1/pose: turtlesim/msg/pose service servers: /clear: std_srvs/srv/empty /kill: turtlesim/srv/kill /reset: std_srvs/srv/empty /spawn: turtlesim/srv/spawn /turtle1/set_pen: turtlesim/srv/setpen /turtle1/teleport_absolute: turtlesim/srv/teleportabsolute /turtle1/teleport_relative: turtlesim/srv/teleportrelative /turtlesim/describe_parameters: rcl_interfaces/srv/describeparameters /turtlesim/get_parameter_types: rcl_interfaces/srv/getparametertypes /turtlesim/get_parameters: rcl_interfaces/srv/getparameters /turtlesim/list_parameters: rcl_interfaces/srv/listparameters /turtlesim/set_parameters: rcl_interfaces/srv/setparameters /turtlesim/set_parameters_atomically: rcl_interfaces/srv/setparametersatomically service clients: action servers: /turtle1/rotate_absolute: turtlesim/action/rotateabsolute action clients: wow, that's a lot of information, some of which looks familiar. we can see all the topics that the node subscribes to, as well as all the nodes it publishes to. we can also see a number of "action servers" and "service servers". it is worth noting the client and server relationship here. since ros may have multiple nodes running some nodes may offer services (these are servers), and other ros nodes may call those servers (these are the clients). the clients can be other ros nodes, or for these examples, a human using the cli. the command line interface for services and actions are very similar, in fact they both have only four sub commands. let's run the action and service commands and compare them:  ros2 action --help usage: ros2 action [-h] call `ros2 action <command> -h` for more detailed usage. ... various action related sub-commands optional arguments: -h, --help show this help message and exit commands: info print information  an action list output a list of action names send_goal send an action goal show output the action definition call `ros2 action <command> -h` for more detailed usage.  ros2 service --help usage: ros2 service [-h] [--include-hidden-services] call `ros2 service <command> -h` for more detailed usage. ... various service related sub-commands optional arguments: -h, --help show this help message and exit --include-hidden-services consider hidden services as well commands: call call a service find output a list of available services of a given type list output a list of available services type output a service's type call `ros2 service <command> -h` for more detailed usage. we can see that both commands have a list command that gives a list of available services or actions. if we had multiple nodes running and wanted to see every service offered, calling ros2 node info on each node would be very inefficient, particularly if we had tens, or even hundreds of nodes running. in this case it would be much more efficient to use the list commands for the action and service commands. we can run these commands below and see that we get roughly the same list of actions and services listed in our single nodes:  ros2 service list /clear /kill /reset /spawn /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/describe_parameters /turtlesim/get_parameter_types /turtlesim/get_parameters /turtlesim/list_parameters /turtlesim/set_parameters /turtlesim/set_parameters_atomically kscottz@kscottz-ratnest:~ ros2 action list /turtle1/rotate_absolute let's begin digging into services. there seem to be quite a few services listed. let's take a look at the /spawn service, which will create more turtles. ros services and actions use messages similar to those used in topics to communicate. in fact, actions and services are built on top of messages. we can use the service type sub command to determine the message type used by a particular service. we can find specifics of the message by using the interface show command. let's see this in practice with the spawn service:  ros2 service type /spawn turtlesim/srv/spawn  ros2 interface show turtlesim/srv/spawn float32 x float32 y float32 theta string name # optional. a unique name will be created and returned if this is empty --- string name we can see from the output above that the spawn message takes three float32 values for its position and orientation as well a string for its name. the --- indicate the return value of the services. unlike topics, services have a return value, which enables them to do things like perform computations and calculations. let's examine the help for calling a service by running ros2 service call --help :  ros2 service call --help usage: ros2 service call [-h] [-r n] service_name service_type [values] call a service positional arguments: service_name name of the ros service to call to (e.g. '/add_two_ints') service_type type of the ros service (e.g. 'std_srvs/srv/empty') values values to fill the service request with in yaml format (e.g. "{a: 1, b: 2}"), otherwise the service request will be published with default values optional arguments: -h, --help show this help message and exit -r n, --rate n repeat the call at a specific rate in hz the syntax here is very similar to publishing to a topic, but instead of using a a topic name we use a service name. the service type is just like the topic type that we used in the past, but instead of using a message type we need a service type. finally we give it a value in yaml format. a yaml string must be encased in single quotes. let's try calling a service by creating a turtle named larry at a position where all values are zero (use tab complete).  ros2 service call /spawn turtlesim/srv/spawn "{x: 0, y: 0, theta: 0.0, name: 'larry'}" requester: making request: turtlesim.srv.spawn_request(x=0.0, y=0.0, theta=0.0, name='larry') response: turtlesim.srv.spawn_response(name='larry') if everything is working correctly you should now have a turtle named "larry" in the lower left hand corner of the screen: try exploring the other services offered, or creating more turtles at different locations and moving them around. let's move on to actions. as mentioned previously, actions differ from services in a few ways and offer a number of advantages. actions have the following advantages: actions have a goal . that is to say you send them a goal, and they attempt to complete it. actions can reject goal requests. this prevents them from becoming too busy. actions are asynchronous and can perform tasks "while you wait." actions will provide you with "updates" with information  their progress while you wait. actions are preemptable, meaning you can cancel them if you change your mind. just like with services, we'll first figure out how to call the sole action in our ros system by using the action list , action show , and action info commands. recall, that when we called ros2 action list we got a single service. now that we have larry things have changed. let's take a look:  ros2 action list /larry/rotate_absolute /turtle1/rotate_absolute now there are two actions available, one for larry and one for turtle1 . let's rotate turtle1 to face larry. first we'll call action info using /turtle1/rotate_absolute as the input and see what we get:  ros2 action info /turtle1/rotate_absolute action: /turtle1/rotate_absolute action clients: 0 action servers: 1 /turtlesim well, that tells us  the client and servers, but it really isn't helpful for our goal of moving larry. why don't we look at the action send_goal help and see if we can figure out how to use it:  ros2 action send_goal --help usage: ros2 action send_goal [-h] [-f] action_name action_type goal send an action goal positional arguments: action_name name of the ros action (e.g. '/fibonacci') action_type type of the ros action (e.g. 'example_interfaces/action/fibonacci') goal goal request values in yaml format (e.g. '{order: 10}') optional arguments: -h, --help show this help message and exit -f, --feedback echo feedback messages for the goal this command needs an action name, an action type, and a goal in yaml. we know the action name, and we know how to write yaml, so all we need is to determine the action type. the best way to get the action type is the same way we published a message. we see each of our turtles have one service called rotate_absolute . let's dig into this action using the info sub command. this command has a -t flag to list the types of messages.  ros2 action info /turtle1/rotate_absolute -t action: /turtle1/rotate_absolute action clients: 0 action servers: 1 /turtlesim [turtlesim/action/rotateabsolute] the first line lists the action name. the second line gives the current number of clients for the action. the action servers line gives the total number of action servers for this action. the last line gives the package and message type for the action. we can see here that we need to know the action name, the type, and the values. now the only problem is figuring out the format of the action type. let's understand the rotateabsolute action message the ros2 interface show command can be used to find the type of action message. let's take a look:  ros2 interface show turtlesim/action/rotateabsolute # the desired heading in radians float32 theta #< --- this section is the goal --- # the angular displacement in radians to the starting position float32 delta #< --- this section is the final result, different from the goal. --- # the remaining rotation in radians float32 remaining # < --- this is the current state. what does this say  rotate absolute? there is a float input, theta , the desired heading. this first section is the actual goal. delta is the angle from the initial heading. this is the value returned when the action completes. remaining is the remaining radians to move. this is the value posted by the action while the action is being done. with this information we can create our call to the action server. we'll use the -f flag to make this a bit clearer. keep an eye on your turtle! it should move, slowly.  ros2 action send_goal -f /turtle1/rotate_absolute turtlesim/action/rotateabsolute {'theta: 1.70'} waiting for an action server to become available... sending goal: theta: 1.7 feedback: remaining: 0.11599969863891602 goal accepted with id: 35c40e91590047099ae5bcc3c5151121 feedback: remaining: 0.09999966621398926 feedback: remaining: 0.06799960136413574 feedback: remaining: 0.03599953651428223 result: delta: -0.09600019454956055 goal finished with status: succeeded if everything worked correctly we should see our turtle has rotated. ros parameters in ros, parameters are values that are shared between nodes in the system (if you are familiar with the blackboard design pattern in software engineering). parameters are values that any node can query or write to. another good analogy would be global constants in normal software programs. parameters are best used to configure your robot. for example, if you were building an autonomous vehicle and wanted to cap the maximum velocity of the vehicle at 100 km/h, you could create a parameter called "max_speed" that is visible to all the nodes. let's take a look at the param command by running ros2 param --help .  ros2 param --help various param related sub-commands commands: delete delete parameter get get parameter list output a list of available parameters set set parameter call `ros2 param <command> -h` for more detailed usage. at a high level, ros 2's param command has sub commands to get and set a variable, along with a list functionality, and a delete command. as with most of the other commands we've worked through, it is instructive to look at list first. let's see what the docs say  the list command and then see what happens when we call the sub command:  ros2 param list --help usage: ros2 param list [-h] [--spin-time spin_time] [--include-hidden-nodes] [--param-prefixes param_prefixes [param_prefixes ...]] [node_name] output a list of available parameters positional arguments: node_name name of the ros node optional arguments: -h, --help show this help message and exit --spin-time spin_time spin time in seconds to wait for discovery (only applies when not using an already running daemon) --include-hidden-nodes consider hidden nodes as well --param-prefixes param_prefixes [param_prefixes ...] only list parameters with the provided prefixes  ros2 param list /turtlesim: background_b background_g background_r use_sim_time the only argument of note in this sub command is the node_name which allows you to narrow the scope of param list to only those parameters used by a particular node. in  of parameters in the turtlesim node, we see that our call to param list gives us: three background color control params named background_x and a use_sim_time parameter. to learn all  the param command why don't we try to change these background color parameters using the cli. the first step in changing the background color is to see what the current color is. the param get sub command requires both a node name and a parameter name. in our list above we can see the node name as the top level element with the forward slash in front of it, namely /turtlesim . the syntax for param get is ros2 param get <node_name> <param> . let's give it a whirl and see our current background color values.  ros2 param get /turtlesim background_b integer value is: 255  ros2 param get /turtlesim background_g integer value is: 86  ros2 param get /turtlesim background_r integer value is: 69 on most computers color is represented as a triplet of <r,g,b> values. the color value of <69,86,255> corresponds to a periwinkle blue color. to change the color of the turtlesim we need to first set the parameter value and then reset the turtlesim to make it apply the color changes. we covered the basics of calling a service previously so we won't cover the steps of constructing a service call. let's try setting our background color's blue component to 128.  ros2 param set turtlesim background_b 128 set parameter successful  ros2 service call /reset std_srvs/srv/empty requester: making request: std_srvs.srv.empty_request() response: std_srvs.srv.empty_response() if everything worked correctly your turtle should look like the screen below. ros bags ros bags are ros's tool for recording, and replaying data. ros bags are like log files that let you store data along with messages. ros systems can generate a lot of data, so when you bag data you must select which topics you want. bags are a great tool for testing and debugging your application and a great tool for building robust unit tests. let's take a look at the root ros bag command by typing ros2 bag --help into the terminal. if you get an error you might need to install ros bag as it is often in a separate package. on linux you can run sudo apt install ros-eloquent-ros2bag and it should automatically install the package for you.  ros2 bag -h usage: ros2 bag [-h] call `ros2 bag <command> -h` for more detailed usage. ... various rosbag related sub-commands commands: info ros2 bag info play ros2 bag play record ros2 bag record as you can see there are three sub commands, record , play , and info . with these commands you can record a bag file, play/replay a file you've recorded, and find information  a bag file. let's try recording our first bag file. to do this we'll need three terminals all running ros. the first terminal should already have our turtlesim running. if it isn't running you can restart it with ros2 run turtlesim turtlesim_node . next you'll need to start the draw_square demo again to get the default turtle moving. to do this run ros2 run turtlesim draw_square . now, in a third terminal we can bag some data by running the bag command. let's first look at the record sub command by running ros2 bag record -h  ros2 bag record -h usage: ros2 bag record [-h] [-a] [-o output] [-s storage] [-f serialization_format] [--no-discovery] [-p polling_interval] [-b max_bag_size] [topics [topics ...]] ros2 bag record positional arguments: topics topics to be recorded optional arguments: -h, --help show this help message and exit -a, --all recording all topics, required if no topics are listed explicitly. -o output, --output output destination of the bagfile to create, defaults to a timestamped folder in the current directory -s storage, --storage storage storage identifier to be used, defaults to "sqlite3" -f serialization_format, --serialization-format serialization_format rmw serialization format in which the messages are saved, defaults to the rmw currently in use --no-discovery disables topic auto discovery during recording: only topics present at startup will be recorded -p polling_interval, --polling-interval polling_interval time in ms to wait between querying available topics for recording. it has no effect if --no-discovery is enabled. -b max_bag_size, --max-bag-size max_bag_size maximum size in bytes before the bagfile will be split. default it is zero, recording written in single bagfile and splitting is disabled. we can see from the help file that the syntax for recording a bag is to simply give the sub command a list of topics to record. most of the other arguments are for more advanced users to help configure how and when data is stored. it is worth noting that there is a -a, --all command that records all the data. you can also specify the output bag file with the -o, --output command . let's go ahead and run our bag command, and let's bag the pose data on the /turtle1/pose topic and save it to the file turtle1.bag using the -o flag. be aware that the program will continue bagging data until you hit ctrl-c , so give the command a good 30 seconds to collect data before you kill it.  ros2 bag record /turtle1/pose -o turtle1 [info] [rosbag2_storage]: opened database 'turtle1'. [info] [rosbag2_transport]: listening for topics... [info] [rosbag2_transport]: subscribed to topic '/turtle1/pose' [info] [rosbag2_transport]: all requested topics are subscribed. stopping discovery... ^c[info] [rclcpp]: signal_handler(signal_value=2) now that we collected our data let's inspect our bag file. you can introspect any bag file using the ros2 bag info command. this command will list the messages in the bag, the duration of file, and the number of messages.  ros2 bag info turtle1 files: turtle1.db3 bag size: 268.4 kib storage id: sqlite3 duration: 68.705s start: may 4 2020 16:10:26.556 (1588633826.556) end may 4 2020 16:11:35.262 (1588633895.262) messages: 4249 topic information: topic: /turtle1/pose | type: turtlesim/msg/pose | count: 4249 | serialization format: cdr once you have collected a bag file you can replay the file just like a running system. bags are a great tool for debugging and testing. you can treat a ros bag like a recording of a running ros system. when you play a bag file you can use most of the ros2 cli tools to inspect the recorded topics. to replay the bag, first use ctrl-c to turn off the turtlesim_node and the draw_square node. now in a new terminal replay the bag file using the following command:  ros2 bag play turtle1 [info] [rosbag2_storage]: opened database 'turtle1'. nothing should happen visibly, but a lot is happening under the hood. to see what is happening go to a second terminal. just like a running robot, you should be able to list and echo topics:  ros2 topic list /parameter_events /rosout /turtle1/pose  ros2 bag info turtle1 x: 3.8595714569091797 y: 3.6481313705444336 theta: -1.2895503044128418 linear_velocity: 1.0 angular_velocity: 0.0 --- ros2 component command ros2 daemon command ros2 doctor command with any complex system problems can sometimes arise, and knowing how to describe your system and what is happening can do a lot to help others help you fix your problem. ros 2 has a doctor command that you can use to print a variety of reports that you can use to help communicate the state of your system to others trying to provide help. whether it is one of your co-workers, a vendor, or an on-line forum, providing detailed and complete information  your ros system can go a long way to solving your problem. let's call --help on the ros 2 doctor command:  ros2 doctor --help usage: ros2 doctor [-h] [--report | --report-failed] [--include-warnings] check ros setup and other potential issues optional arguments: -h, --help show this help message and exit --report, -r print all reports. --report-failed, -rf print reports of failed checks only. --include-warnings, -iw include warnings as failed checks. warnings are ignored by default. as we can see from the help file we have a couple of report options. one option is to print the full report with -r , or just what failed with -rf . if you're running ros2 doctor -r you should see a fairly lengthy report generated giving information  your computer's operating system, your networking configuration, and your running ros system. if you ever run into an issue you should always include this full report. ros 2 interface as you've already seen, ros uses standard messages so that different packages and programs, potentially written in different programming languages, can all talk to one another. to make this all work, ros uses standard messages, and communication protocols built on top of those standard messages. this can make finding type information  a particular message, service, or action difficult. to help developers write both cli command calls and develop client code, the ros cli has the interface command. we've touched on this command briefly in other sections, as it is the go to tool for message type information. to better understand the interface command let's start by looking at its high level help command to see what sub commands are available:  ros2 interface --help usage: ros2 interface [-h] call `ros2 interface <command> -h` for more detailed usage. ... show information  ros interfaces optional arguments: -h, --help show this help message and exit commands: list list all interface types available package output a list of available interface types within one package packages output a list of packages that provide interfaces proto output an interface prototype show output the interface definition call `ros2 interface <command> -h` for more detailed usage. the interface command are all geared towards helping you understand available message types. let's examine the list sub command in depth. list will list all of the available messages, services, and actions on your system. this command has flags that can help you narrow down the scope of your search. even a basic ros installation has a lot of messages, so a tool you should get familiar with is grep . grep lets you search through some text to find what you are looking for quickly and easily. you can grep in a case insensitive manner using the -i flag followed by the text you want to search for. we can tie this cli tool to our interface tool by using the unix pipe operator | . the example below shows you how to use the list operation and then how to use it to search:  ros2 interface list --only-msgs messages: action_msgs/msg/goalinfo action_msgs/msg/goalstatus ... <dozens of different types> ... visualization_msgs/msg/markerarray visualization_msgs/msg/menuentry  ros2 interface list --only-msgs | grep -i point geometry_msgs/msg/point geometry_msgs/msg/point32 geometry_msgs/msg/pointstamped map_msgs/msg/pointcloud2update pcl_msgs/msg/pointindices rcl_interfaces/msg/floatingpointrange sensor_msgs/msg/pointcloud sensor_msgs/msg/pointcloud2 sensor_msgs/msg/pointfield trajectory_msgs/msg/jointtrajectorypoint using grep to search through cli output is a common tactic used by developers to find just the specific information they need. the next two sub commands package and packages can be used to first determine what ros packages are on your system, and then to drill down into an individual package to determine what messages are in that package. note that you can use grep just like before to search for your specific interest. the example below shows you how to first determine if std_msgs is installed and then to find out what sort of array types it contains:  ros2 interface packages action_msgs action_tutorials_interfaces actionlib_msgs builtin_interfaces composition_interfaces diagnostic_msgs example_interfaces geometry_msgs lifecycle_msgs logging_demo map_msgs nav_msgs pcl_msgs pendulum_msgs rcl_interfaces rosgraph_msgs rqt_py_common sensor_msgs shape_msgs std_msgs std_srvs stereo_msgs tf2_msgs trajectory_msgs turtlesim unique_identifier_msgs visualization_msgs kscottz@kscottz-ratnest:~/code/ros2multirobotbook/src ros2 interface package std_msgs | grep -i array std_msgs/msg/int8multiarray std_msgs/msg/int32multiarray std_msgs/msg/multiarraylayout std_msgs/msg/uint64multiarray std_msgs/msg/float32multiarray std_msgs/msg/uint16multiarray std_msgs/msg/uint32multiarray std_msgs/msg/int16multiarray std_msgs/msg/bytemultiarray std_msgs/msg/int64multiarray std_msgs/msg/float64multiarray std_msgs/msg/uint8multiarray std_msgs/msg/multiarraydimension the next two commands are particularly helpful and you should remember them as they will make your life much easier. as we have discussed previously all message publication, service calls, and action calls in the cli take in both the message type and data you want to transmit in yaml format. but what if you don't know the message format, and you don't know a lot  yaml? the interface show and interface proto commands make this process easier by respectively telling you first the message type and then the message format. recall earlier in the chapter when we called the spawn service on our turtle simulation. we can use interface show to tell us broadly  the service and what each of the values mean. we can then use interface proto , short for prototype, to then generate an empty message that we can fill out. see the example below:  ros2 interface show turtlesim/srv/spawn float32 x float32 y float32 theta string name # optional. a unique name will be created and returned if this is empty --- string name  ros2 interface proto turtlesim/srv/spawn "x: 0.0 y: 0.0 theta: 0.0 name: '' "  ros2 service call /spawn turtlesim/srv/spawn "{<copy and paste proto here>}" you can see from the example above how handy these tools can be. it is worth noting that you need to paste the prototype into a set of quotes and curly braces for the call to work "{<prototype>}" . ros 2 launch the launch command is used to run ros launch files. up until this point we've been running single ros programs by hand using the run command, however this is not how larger ros systems are generally operated and many robots command tens if not hundreds of small programs. the ros launch command is different from most of the other ros commands in that it has no sub commands and has a single function, to start a ros launch file that executes multiple of programs. to illustrate this command let's take a look at its help file.  ros2 launch -h usage: ros2 launch [-h] [-d] [-p | -s] [-a] package_name [launch_file_name] [launch_arguments [launch_arguments ...]] run a launch file positional arguments: package_name name of the ros package which contains the launch file launch_file_name name of the launch file launch_arguments arguments to the launch file; '<name>:=<value>' (for duplicates, last one wins) optional arguments: -h, --help show this help message and exit -d, --debug put the launch system in debug mode, provides more verbose output. -p, --print, --print-description print the launch description to the console without launching it. -s, --show-args, --show-arguments show arguments that may be given to the launch file. -a, --show-all-subprocesses-output show all launched subprocesses' output by overriding their output configuration using the override_launch_process_output envvar. launch files are usually included with a ros package and are commonly stored in a launch sub directory. modern launch files are usually written in python and end with the *.launch.py file extension. the launch command has two arguments, the first one is the package name and then the launch file name. if you are unaware of the launch files in your package you can use tab completion to list all the available launch files. finally, some launch files have arguments that can be appended to the command. if you are unsure  what a launch file does, or what arguments it needs, the --print and --show-args commands will tell you this information. let's read up on the multisym.launch.py launch file and then run it following the example below (end the simulation with ctrl-c ):  ros2 launch turtlesim multisim.launch.py --show-args arguments (pass arguments as '<name>:=<value>'): no arguments.  ros2 launch turtlesim multisim.launch.py --print <launch.launch_description.launchdescription object at 0x7f75aab63828>  executeprocess(cmd=[execinpkg(pkg='turtlesim', exec='turtlesim_node'), '--ros-args'], cwd=none, env=none, shell=false)  executeprocess(cmd=[execinpkg(pkg='turtlesim', exec='turtlesim_node'), '--ros-args'], cwd=none, env=none, shell=false)  ros2 launch turtlesim multisim.launch.py [info] [launch]: all log files can be found below /home/kscottz/.ros/log/2020-06-24-14-39-03-312667-kscottz-ratnest-20933 [info] [launch]: default logging verbosity is set to info [info] [turtlesim_node-1]: process started with pid [20944] [info] [turtlesim_node-2]: process started with pid [20945] ^c[warning] [launch]: user interrupted with ctrl-c (sigint) ros 2 lifecycle ros 2 has a new feature called lifecycle which allows for greater control over the state of a ros node. roughly, this feature allows nodes to have complex start-up and shut-down procedures that are correctly handed. an example of such a node would be one that controls a sensor or actuator that needs to perform a power-on self-test or calibration procedure prior to running. the ros design docs give a great primer on the states and transitions in a lifecycle node. let's look at the lifecycle command to determine what sub commands are available:  ros2 lifecycle -h usage: ros2 lifecycle [-h] call `ros2 lifecycle <command> -h` for more detailed usage. ... various lifecycle related sub-commands optional arguments: -h, --help show this help message and exit commands: get get lifecycle state for one or more nodes list output a list of available transitions nodes output a list of nodes with lifecycle set trigger lifecycle state transition call `ros2 lifecycle <command> -h` for more detailed usage. the nodes sub command will list all the lifecycle nodes on a given system. once you have listed the nodes, you can list each node's available transitions using ros2 lifecycle list <nodename> . these transitions are dictated by the node's current state with some states having more transitions available than others. if instead of available transitions you wish to query the current state you can use lifecycle get to return the current state of your target node. once you have satisfactorily determined the state of the node and the available transitions, the lifecycle set command can be used to trigger the node to transition to a new state. generally, these cli commands are used to diagnose failure modes of systems, or to manually transition a particular component. ros 2 msg (message) ros 2 eloquent is the last version of ros to use the msg command. all of the commands in msg are mirrored in the interface command. these features are currently deprecated and will be removed in foxy. ros 2 pkg (package) the ros 2 package command is a very useful command to understand what ros packages are installed on your system, where they are installed, and the executables contained within each package. these tools are particularly useful for understanding an existing robot configuration and finding tools that are only used on occasion. let's start by taking a look at the help file for the pkg command:  ros2 pkg -h usage: ros2 pkg [-h] call `ros2 pkg <command> -h` for more detailed usage. ... various package related sub-commands optional arguments: -h, --help show this help message and exit commands: create create a new ros2 package executables output a list of package specific executables list output a list of available packages prefix output the prefix path of a package xml output the xml of the package manifest or a specific tag call `ros2 pkg <command> -h` for more detailed usage. this command has a variety of sub commands, many of which should look fairly familiar at this point. the list sub command acts in a manner very similar to list sub commands we have discussed previously, but this one only lists the installed system packages. this sub command is often used with grep to help you find out if a particular package is installed. once you have located an installed package you can then have it list the executables contained by the package using the executables command. this is much more practical than finding the executables manually. the sub command takes in a single argument which is the package name. the executables command has a single optional argument, --full-path , which will output the full path to all the executable programs. the example below shows how to use these commands to check the path for all of the turtlesim executables:  ros2 pkg list | grep turtle turtlesim  ros2 pkg executables turtlesim --full-path /opt/ros/eloquent/lib/turtlesim/draw_square /opt/ros/eloquent/lib/turtlesim/mimic /opt/ros/eloquent/lib/turtlesim/turtle_teleop_key /opt/ros/eloquent/lib/turtlesim/turtlesim_node if you just wanted to know the path to the turtlesim executables you could use the prefix sub command, which returns the path for a given package's executables. each ros package contains an xml file that contains metadata for the package, including information such as the license, maintainer, and its dependencies. ros pkg has a handy xml sub command to print these files to the screen, saving you the hassle of locating and opening the file. you can use grep on the output of this command to get just the info you need. below is an example of xml and prefix used to find the directory of turtlesim, its maintainer, and its license:  ros2 pkg prefix turtlesim /opt/ros/eloquent  ros2 pkg xml turtlesim | grep maintainer <maintainer email="dthomas@osrfoundation.org">dirk thomas</maintainer>  ros2 pkg xml turtlesim | grep license <license>bsd</license> kscottz@kscottz-ratnest:~ the last sub command in the pkg command is create . create is a tool to help you create a ros package. we'll use this sub command later in the chapter to create a new ros package. the short of it is that you feed the command your package name and all of the relevant information for your package as optional arguments. ros 2 security