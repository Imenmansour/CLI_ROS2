january 23, 2024 ros 2 and vscode by giovanni remigi this document provides a detailed guide for using visual studio code (vscode) to build and execute ros 2 projects efficiently with c++ and python. it covers a range of topics, including initializing vscode, remote development over ssh, development using docker, sourcing ros dependencies, and building with colcon. the document also delves into specific techniques for working in c++ and python within the ros 2 environment, offering valuable insights and tips to enhance the development process. table of contents initialization of visual studio code remote development over ssh development on docker sourcing your ros dependencies solution 1 - for local development solution 2 - for local development solution 3 - for docker containers how to build with colcon how to build with cmake working in c++ navigation and shortcuts debugging tests working in python intellisense sorting imports debugging python files discover and execute tests tips highlight current tab additional extensions general python additional resources initialization of visual studio code for this guide, it is presumed that visual studio code has already been installed on your system without additional extensions. in an ubuntu environment, the extensions are commonly stored in the following directory: ~/.vscode upon launching vscode, install the microsoft ros extension , followed by a restart of the editor. this extension will facilitate the installation of requisite dependencies such as microsoft c/c++ and microsoft python extensions. install the c/c++ extension pack , which provides intellisense and c++ file navigation. this will install the cmake extension , too. remote development over ssh vscode can be used to develop remotely over ssh. you must install an extension called microsoft remote ssh . this extension will also add a button on the left toolbar to display all available docker containers. open the command palette and type: remote-ssh: connect to host. development on docker vscode can be used to develop on docker. you must install an extension called microsoft dev containers , which you can use to connect to running containers. with this extension, you can install your local vscode extensions into the container in one click. you should also install the extension called microsoft docker , which allows you to work with containers and images. for more information, see the vscode document attach to a running container . sourcing your ros dependencies when you execute or debug a file in your project, it may fail to find its runtime dependencies and throw an error in the debug console. there are different solutions for this issue. solution 1 - for local development you can source your ros 2 workspace in the same debug console and try again. source install/setup.bash solution 2 - for local development you can modify the user .bashrc to source your ros 2 workspace whenever you attach vscode to the container. solution 3 - for docker containers if you do not want to run a command each time you start a debug session and you cannot modify the file .bashrc , here is a more versatile approach. you want to execute a source command every time vscode opens the container. the vscode devcontainer extension allows you to edit the json container configuration file, providing a field for this purpose. open the configuration file by clicking on the highlighted cog. add the following field to modify the .bashrc each time you connect vscode to the container. tag is a unique id to verify if the command has already been added. "postattachcommand": "grep -qf 'tag' home/.bashrc || echo 'source project-workspace/install/setup.bash # tag' >> home/.bashrc" the container configuration file is usually stored somewhere inside this folder: home/.config/code/user/globalstorage/ms-vscode-remote.remote-containers/ how to build with colcon to run the colcon command from vscode, you need to create the file tasks.json within the .vscode folder and populate it with the following content: { "version": "2.0.0", "tasks": [ { "label": "colcon: build (debug)", "type": "shell", "command": [ "source /opt/ros/humble/setup.bash;", "colcon build", "--symlink-install", "--event-handlers console_cohesion+", "--base-paths workspace-path", "--cmake-args -dcmake_build_type=debug" ] }, { "label": "colcon: clean", "type": "shell", "command": ["cd project-workspace;", "rm -rf build/ install/ log/;"] }, { "label": "colcon: test", "type": "shell", "command": [ "cd project-workspace;", "source /opt/ros/humble/setup.bash;", "source install/setup.bash;", "colcon test", "--packages-select <package-name>", "--event-handlers console_direct+;" ] } ] } to build a package, this may also work. { "version": "2.0.0", "tasks": [ { "label": "colcon: build (debug)", "type": "colcon", "group": "build", "args": [ "build", "--symlink-install", "--event-handlers console_cohesion+", "--base-paths project-workspace", "--cmake-args -dcmake_build_type=debug" ] } ] } modify the file according to your ros 2 distribution and project location. choose terminal  run build task from the menu to build your project. the system will automatically locate and initiate the build task specified in the aforementioned tasks.json file. alternatively, use the keyboard shortcut: ctrl + shift + b using the same approach, you can also execute any ros 2 launch files. how to build with cmake building your code with cmake from within the ide is also possible. here is a sample configuration to add to the file tasks.json. { "version": "2.0.0", "tasks": [ { "label": "cmake configure", "type": "shell", "command": "cmake", "args": [ "-s", ".", "-b", "build", "-dcmake_build_type=release", "other options..." ], "options": { "env": { "c_include_path": "path to c include files...", "cplus_include_path": "path to c++ include files...", "library_path": "path to libraries...", "cmake_prefix_path": "path to cmake modules...", "ld_library_path": "path to libraries...", "path": "path to executables, including compiler and cmake..." } }, "group": { "kind": "build", "isdefault": true } }, { "label": "cmake build", "type": "shell", "command": "cmake", "args": [ "--build", "build" ], "options": { "env": { "c_include_path": "path to c include files...", "cplus_include_path": "path to c++ include files...", "library_path": "path to libraries...", "cmake_prefix_path": "path to cmake modules...", "ld_library_path": "path to libraries...", "path": "path to executables, including compiler and cmake..." } } }, "group": "build", "problemmatcher": [ "gcc" ], "dependson": ["cmake configure"] } ] } working in c++ if you open an existing ros 2 project that contains c++ source code, you may observe that vscode generates a .vscode folder containing two configuration files: c_cpp_properties.json settings.json if c_cpp_properties.json is not created, you can create a new one by opening the command palette and typing c++: edit configurations (ui). update it to match roughly the following content: { "configurations": [ { "browse": { "databasefilename": "{default}", "limitsymbolstoincludedheaders": false }, "includepath": [ "/opt/ros/humble/include/**", "/usr/include/**", "add here your project include files" ], "name": "ros", "intellisensemode": "gcc-x64", "compilerpath": "/usr/bin/gcc", "cstandard": "gnu11", "cppstandard": "c++17" } ], "version": 4 } warning do not implicitly add all include files of your install folder, for example, by adding "{workspacefolder}/**" to your include path. this can seriously confuse intellisense and yourself when developing. add a subfolder if needed: {workspacefolder}/build/package there are two additional parameters worth mentioning. "configurationprovider": "ms-vscode.cmake-tools", "compilecommands": "{workspacefolder}/build/compile_commands.json" if you can build your application with colcon before opening vscode, you can use the generated file compile_commands.json to feed intellisense. this configuration overrides the includepath parameter. it is more precise but requires a build folder, which is not always the case. navigation and shortcuts you may conveniently toggle between .cpp and .hpp files using the following keyboard shortcut: alt + o debugging tests another helpful extension is c++ testmate , which lets you launch and debug gtests directly within vscode. please note that for this extension to work correctly, you may need to source your ros repository before starting up vscode. to debug your test, create a launch.json file inside your .vscode directory. the file is automatically created for you when you debug your first test. { "version": "0.2.0", "configurations": [ { "name": "gdp: launch", "type": "cppdbg", "request": "launch", "program": "enter program name, for example, {workspacefolder}/../build/path_to_executable", "args": [], "stopatentry": false, "cwd": "{filedirname}", "environment": [], "externalconsole": false, "mimode": "gdb", "prelaunchtask": "add your build task here. e.g. colcon: build", "setupcommands": [ { "description": "enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignorefailures": true }, { "description": "set disassembly flavor to intel", "text": "-gdb-set disassembly-flavor intel", "ignorefailures": true } ] } ] } working in python more information is available here: https://code.visualstudio.com/docs/python/python-tutorial intellisense when you open an existing ros 2 python project, intellisense does not find your ros 2 python modules or local package modules. to solve the issue, create a file settings.json with content matching roughly the following: { "python.autocomplete.extrapaths": [ "/opt/ros/humble/lib/python3.10/site-packages", "/opt/ros/humble/local/lib/python3.10/dist-packages", "/my_project/build/package1", "/my_project/build/package2" ], "python.analysis.extrapaths": [ "/opt/ros/humble/lib/python3.10/site-packages", "/opt/ros/humble/local/lib/python3.10/dist-packages", "/my_project/build/package1", "/my_project/build/package2" ] } all python dependencies are stored in the environment variable pythonpath. unfortunately, vscode does not use it. to get the list of all libraries, source your project and type the following bash command ifs=:; for path in pythonpath; do echo "\"path\","; done sorting imports to sort imports in a python module, open the command palette and type organize imports. you can also use the following shortcut: shift + alt + o debugging python files to debug a normal python file, you must create a launch.json file inside your .vscode directory. { "version": "0.2.0", "configurations": [ { "name": "python: current file", "type": "python", "request": "launch", "program": "{file}", "args": ["--arg1", "value"], "console": "integratedterminal", "justmycode": true } ] } to debug a ros 2 python launch file, open a command palette and type ros: run a ros launch file (roslaunch) to add a new launch configuration to your launch.json. you can also add it manually. { "version": "0.2.0", "configurations": [ { "name": "ros: launch", "type": "ros", "request": "launch", "target": "/absolute-path/launch-file.py" } ] } the ros 2 extension allows you to debug a running node as well. { "version": "0.2.0", "configurations": [ { "name": "ros: attach", "type": "ros", "request": "attach" } ] } remember to add the following additional argument to your node in the launch file: my_node = launch_ros.actions.node( ... prefix=["gdbserver :3000"], ) following is a more complex solution that requires you to modify the python file. add this code to the end of the launch file to convert it to a normal python file: def main(): ls = launch.launchservice() ld = generate_launch_description() ls.include_launch_description(ld) return ls.run() if __name__ == '__main__': main() using an opaque function allows you to debug the values of launch parameters. however, with the previous change, youll need to modify the launch file, as demonstrated in the following example. def launch_setup(context, *args, **kwargs): my_param = launchconfiguration("param_name") def generate_launch_description(): return launchdescription( [ declarelaunchargument( "param_name", default_value="param_value", description=("param_description"), ), opaquefunction(function=launch_setup), ] ) in vscode, we can add a breakpoint and display the content of this variable with a watch: my_param.perform(context) discover and execute tests test discovery in vscode does not work perfectly, and sometimes it does not find your tests automatically. you can add them manually by appending the following lines to your settings.json: "python.testing.pytestenabled": true, "python.testing.unittestenabled": false, "python.testing.cwd": "{workspacefolder}/path-to-test-folder/", "python.testing.pytestpath": "/usr/bin/pytest-3" your tests should now be available under the testing view on the left activity bar. if you do not need to debug your tests, you can always run colcon test as described previously. tips highlight current tab add the following to your configuration file settings.json: "workbench.colorcustomizations": { "tab.activeborder": "#ffffff", "tab.activebackground": "#373737" } additional extensions general bookmarks : mark lines of codes and later jump to them. codesnap : extension to take screenshots of your code. debug visualizer : extension for visualizing data structures while debugging. like the watch view, but with rich visualizations of the watched value. error lens : extension to better display errors in the code. favorites : mark resources (files or folders, local and remote) as favorites, so they can be easily accessed. git history : view the git log, and file history and compare branches or commits. markdown all in one : extension for markdown advanced editing. it adds a document outline, automatic table of contents, etc. microsoft live preview : hosts a local server in your workspace to preview your web pages. microsoft live share : extension to share your editor for real-time collaborative development. protobuf (protocol buffers) : extension to add protobuf support powered by the pbkit language server. shortcut menu bar : extension to add some helpful toolbar buttons like go back/forward buttons, switch between headers and cpp files, and more. task explorer : extension to display and execute tasks displayed on the explorer panel. remember to configure the extension to enable the tasks button on the vscode left activity panel. umlet : draw uml diagrams inside vscode python astral software ruff : support for the ruff linter. debug launcher : start debugging without having to define any tasks or launch configurations, even from the terminal. microsoft black formatter : an automatic python code formatted. microsoft jupyter : extension to edit and run jupyter notebooks. microsoft pylint : support for the pylint linter. this extension helps identify missing methods and variables. microsoft pylance : this is a powerful tool that enhances the python development experience in visual studio code by providing tools for code analysis, error checking, code navigation, and code completion. additional resources for additional information  ros 2 and vscode, you may refer to the following tutorials: configure vs code for ros 2 vscode, docker, and ros 2 share this: tweet linkedin previous post datatamer: an oss library to improve debuggability and observability in ros next post systems engineering your robotics project latest posts june 30, 2024 new moveit lts release for ros 2 jazzy! june 25, 2024 beyond factories: challenges of unstructured ro... june 22, 2024 satellite servicing demonstration since 2015, picknik has developed our commercial grade moveit pro platform to propel the robotics industry forward, while also contributing back to ros , moveit , and many other open source projects. + 1 720 513 2221 hello@picknik.ai products moveit pro developer platform mobile manipulation multi arm control scan, pick, & place bin picking teach pendant remote robot control moveit pro space moveit open source space ros support docs discord  faq tech specs services solution studies prototyping & digital twin application development ros driver development expertise open source ros navigation perception controls case studies team news  careers press kit   2024 picknik inc, located in boulder, colorado, usa. .  policy