skip to content in this tutorial youll learn how to create a ros2 cpp node. the code will be simple to focus on the basics, and get a base structure for all your future ros2 cpp programs. after a minimal running example ill show you what is the recommended way to write your node, using object oriented programming (oop). (if youre interested  writing a node in python, check out the ros2 python node tutorial .) table of contents toggle write a minimal ros2 cpp node code structure for an rclcpp node plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #include "rclcpp/rclcpp.hpp" int main ( int argc, char **argv ) { rclcpp:: init ( argc, argv ) ; auto node = std::make_shared < rclcpp::node >( "my_node_name" ) ; rclcpp:: spin ( node ) ; rclcpp:: shutdown () ; return 0; } #include "rclcpp/rclcpp.hpp" int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<rclcpp::node>("my_node_name"); rclcpp::spin(node); rclcpp::shutdown(); return 0; } #include "rclcpp/rclcpp.hpp" int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<rclcpp::node>("my_node_name"); rclcpp::spin(node); rclcpp::shutdown(); return 0; } this code will start a ros2 node, and wait until you kill the node. lets break this code down line by line. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #include "rclcpp/rclcpp.hpp" #include "rclcpp/rclcpp.hpp" #include "rclcpp/rclcpp.hpp" first we import the rclcpp library. from rclcpp well be able to retrieve many of the ros2 core functionalities: nodes, topics, services, etc. you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter int main ( int argc, char **argv ) { rclcpp:: init ( argc, argv ) ; int main(int argc, char **argv) { rclcpp::init(argc, argv); int main(int argc, char **argv) { rclcpp::init(argc, argv); in our main program, the first thing we do is to initiate ros2 communications with rclcpp:: init () rclcpp::init() . you have to pass 2 arguments, which are the parameters you get from the main () main() function. this line is very important, you must call rclcpp:: init () rclcpp::init() before you create any node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter auto node = std::make_shared < rclcpp::node >( "my_node_name" ) ; auto node = std::make_shared<rclcpp::node>("my_node_name"); auto node = std::make_shared<rclcpp::node>("my_node_name"); now that ros2 communications are initiated, were allowed to create an rclcpp::node rclcpp::node . youll specify the name of the node as an argument. one good practice is to create a std::shared_ptr std::shared_ptr to handle the node object. with ros2 you can use cpp 14, so ditch the new/delete keywords, and use smart pointers instead. here we also used the keyword auto because the type is quite obvious  std::shared_ptr < rclcpp::node > std::shared_ptr<rclcpp::node> , this may be better to increase readability (but its really up to you). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter rclcpp:: spin ( node ) ; rclcpp::spin(node); rclcpp::spin(node); the node is created, however if we do nothing else the program will exit and our node will be destroyed. rclcpp:: spin () rclcpp::spin() will do 2 things: pause the program here and keep the node alive. when you request to kill the node (for example ctrl+c), the spinning will stop and the program will resume. also it will allow all defined callback functions to be called. if you create a callback for a subscriber, a parameter, etc., then spin will monitor any input coming from other nodes, and will trigger some callbacks if needed. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter rclcpp:: shutdown () ; return 0; } rclcpp::shutdown(); return 0; } rclcpp::shutdown(); return 0; } after youve killed the node, this is what gets executed. rclcpp:: shutdown () rclcpp::shutdown() will stop ros2 communications, it is basically the opposite of rclcpp:: init () rclcpp::init() . because the node is stored in a smart pointer, you dont need to worry  de-allocating its resources. to resume, your minimal cpp program will: initiate ros2 communications. create a ros2 node. make the node spin until you kill it. cleanup and shutdown ros2 communications. install and run your ros2 cpp node if you dont already have a ros2 cpp package , create one and create a cpp file in its src/ directory. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/  ros2 pkg create my_robot_tutorials --build-type ament_cmake  cd my_robot_tutorials/src/  touch my_cpp_node.cpp  cd ~/ros2_ws/src/  ros2 pkg create my_robot_tutorials --build-type ament_cmake  cd my_robot_tutorials/src/  touch my_cpp_node.cpp  cd ~/ros2_ws/src/  ros2 pkg create my_robot_tutorials --build-type ament_cmake  cd my_robot_tutorials/src/  touch my_cpp_node.cpp write the previous code into my_cpp_node.cpp. to compile the node, open the cmakelists.txt of your package and add those lines just after find_package(ament_cmake required) find_package(ament_cmake required) : plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... find_package(rclcpp required) add_executable(minimal_cpp_node src/my_cpp_node.cpp) ament_target_dependencies(minimal_cpp_node rclcpp) install(targets minimal_cpp_node destination lib/{project_name} ) ... ... find_package(rclcpp required) add_executable(minimal_cpp_node src/my_cpp_node.cpp) ament_target_dependencies(minimal_cpp_node rclcpp) install(targets minimal_cpp_node destination lib/{project_name} ) ... ... find_package(rclcpp required) add_executable(minimal_cpp_node src/my_cpp_node.cpp) ament_target_dependencies(minimal_cpp_node rclcpp) install(targets minimal_cpp_node destination lib/{project_name} ) ... also, dont forget to add < depend > rclcpp </ depend > <depend>rclcpp</depend> after < buildtool _depend > ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake</buildtool_depend> in package.xml. now you can compile your node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/  colcon build --packages-select my_robot_tutorials  cd ~/ros2_ws/  colcon build --packages-select my_robot_tutorials  cd ~/ros2_ws/  colcon build --packages-select my_robot_tutorials to run your node, open a new terminal, source your ros2 environment, and execute ros2 run : plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run my_robot_tutorials minimal_cpp_node  ros2 run my_robot_tutorials minimal_cpp_node  ros2 run my_robot_tutorials minimal_cpp_node this will do nothing, which is normal since we didnt add any functionality to the node. press ctrl+c to kill the node and exit the program. use oop to write your ros2 cpp nodes code structure lets rewrite the exact same minimal code but this time with oop. well add some functionalities just after that. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public : mynode () : node ( "my_node_name" ) {} private : } ; int main ( int argc, char **argv ) { rclcpp:: init ( argc, argv ) ; auto node = std::make_shared < mynode >() ; rclcpp:: spin ( node ) ; rclcpp:: shutdown () ; } #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public: mynode() : node("my_node_name") {} private: }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<mynode>(); rclcpp::spin(node); rclcpp::shutdown(); } #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public: mynode() : node("my_node_name") {} private: }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<mynode>(); rclcpp::spin(node); rclcpp::shutdown(); } this is the recommended structure to write a node: create a class which inherits from rclcpp::node rclcpp::node . rclcpp::node rclcpp::node contains almost all ros2 basic functionalities. the constructor is a good place to initiate your node with a name and options (not present here). you will also define your publishers/subscribers/services here. what changed in the main function? well now instead of creating a rclcpp::node rclcpp::node object, we create an object of the custom class we wrote. the nodes name is now set in the constructor, but nothing prevents you from passing the name from the main if you want, and then use it. from now on, any addition/change youll make to your node will be inside the mynode class. the main function will stay the same. add some functionalities to your node lets make our node print hello from ros2 at 5hz. well use the code structure from above and add whats needed. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public : mynode () : node ( "my_node_name" ) { timer_ = this - > create_wall_timer ( std::chrono:: milliseconds ( 200 ) , std:: bind ( &mynode::timercallback, this )) ; } private : void timercallback () { rclcpp_info ( this - > get_logger () , "hello from ros2" ) ; } rclcpp::timerbase::sharedptr timer_; } ; int main ( int argc, char **argv ) { rclcpp:: init ( argc, argv ) ; auto node = std::make_shared < mynode >() ; rclcpp:: spin ( node ) ; rclcpp:: shutdown () ; return 0; } #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public: mynode() : node("my_node_name") { timer_ = this->create_wall_timer( std::chrono::milliseconds(200), std::bind(&mynode::timercallback, this)); } private: void timercallback() { rclcpp_info(this->get_logger(), "hello from ros2"); } rclcpp::timerbase::sharedptr timer_; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<mynode>(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } #include "rclcpp/rclcpp.hpp" class mynode : public rclcpp::node { public: mynode() : node("my_node_name") { timer_ = this->create_wall_timer( std::chrono::milliseconds(200), std::bind(&mynode::timercallback, this)); } private: void timercallback() { rclcpp_info(this->get_logger(), "hello from ros2"); } rclcpp::timerbase::sharedptr timer_; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared<mynode>(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } lets break the new stuff down line by line. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter rclcpp::timerbase::sharedptr timer_; rclcpp::timerbase::sharedptr timer_; rclcpp::timerbase::sharedptr timer_; we declare a ros2 timer object as a private attribute of the class. note that ros2 brings you some useful types: you can use sharedptr, which means that the object will in fact be contained inside a std::shared_ptr std::shared_ptr . plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter private : void timercallback () { rclcpp_info ( this - > get_logger () , "hello from ros2" ) ; } private: void timercallback() { rclcpp_info(this->get_logger(), "hello from ros2"); } private: void timercallback() { rclcpp_info(this->get_logger(), "hello from ros2"); } we add a callback for this timer. we make this method private since it will only be called from within the node class. inside this method we simply print something on the screen, with rclcpp_info () rclcpp_info() . we use the inherited method get_logger () get_logger() to get the nodes logger and all the settings that go with it. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter mynode () : node ( "my_node_name" ) { timer_ = this - > create_wall_timer ( std::chrono:: milliseconds ( 200 ) , std:: bind ( &mynode::timercallback, this )) ; } mynode() : node("my_node_name") { timer_ = this->create_wall_timer( std::chrono::milliseconds(200), std::bind(&mynode::timercallback, this)); } mynode() : node("my_node_name") { timer_ = this->create_wall_timer( std::chrono::milliseconds(200), std::bind(&mynode::timercallback, this)); } inside the constructor we initialize the timer with another inherited method: create_wall_timer () create_wall_timer() . we need to give 2 arguments: the duration between 2 callbacks, and the function to call. here to pass the class method we have to use std:: bind () std::bind() . the callback will start being triggered when the node starts spinning. and as you can see, no need to change anything in the main function of the program. using a class inherited from rclcpp::node rclcpp::node makes the approach quite modular. if you run this node you should see the message printed every 0.2 second: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run my_robot_tutorials minimal_cpp_node [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2  ros2 run my_robot_tutorials minimal_cpp_node [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2  ros2 run my_robot_tutorials minimal_cpp_node [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 [info] [my_node_name]: hello from ros2 as long as your node is alive and spinning, the timer created in the constructor will continue to trigger callbacks at 5hz. when you request to kill the node with ctrl+c, the spinning will end and no callback will be called anymore. then, its time for cleanup and shutdown, and the program exits. for reference: ros2 cpp node without oop (not recommended) plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #include "rclcpp/rclcpp.hpp" std::shared_ptr < rclcpp::node > node = nullptr ; void timercallback () { rclcpp_info ( node- > get_logger () , "hello from ros2" ) ; } int main ( int argc, char **argv ) { rclcpp:: init ( argc, argv ) ; node = std::make_shared < rclcpp::node >( "my_node_name" ) ; auto timer = node- > create_wall_timer ( std::chrono:: milliseconds ( 200 ) , timercallback ) ; rclcpp:: spin ( node ) ; rclcpp:: shutdown () ; return 0; } #include "rclcpp/rclcpp.hpp" std::shared_ptr<rclcpp::node> node = nullptr; void timercallback() { rclcpp_info(node->get_logger(), "hello from ros2"); } int main(int argc, char **argv) { rclcpp::init(argc, argv); node = std::make_shared<rclcpp::node>("my_node_name"); auto timer = node->create_wall_timer( std::chrono::milliseconds(200), timercallback); rclcpp::spin(node); rclcpp::shutdown(); return 0; } #include "rclcpp/rclcpp.hpp" std::shared_ptr<rclcpp::node> node = nullptr; void timercallback() { rclcpp_info(node->get_logger(), "hello from ros2"); } int main(int argc, char **argv) { rclcpp::init(argc, argv); node = std::make_shared<rclcpp::node>("my_node_name"); auto timer = node->create_wall_timer( std::chrono::milliseconds(200), timercallback); rclcpp::spin(node); rclcpp::shutdown(); return 0; } this will work, but is much less modular and scalable than using oop. using global variables is not a good practice (you could try to pass the node as a parameter for each callback function, but it would cause other problems too), and we had to write functionality code inside the main function. not using the oop way also prevents you from using ros2 components and lifecycle node, which can be quite useful for more complex applications. writing ros2 code like this may be fine for small projects that you dont intend to share with the ros2 community. but if you intend to work with other ros developers, or simply to read the code from some robots using ros2, well oop is the convention used by (almost) everybody. it will save you  and others who work with your code  time and potential headaches. going further with ros2 cpp nodes in this tutorial you have seen how to write a basic ros2 cpp node with rclcpp. there is much more you can do: components, lifecycled nodes, running multiple nodes in the same executable with intra-process communication, etc. but the most important thing is that you first clearly understand how to write the code foundation that youll need for your nodes. once youre clear with that, start to work with ros2 publishers, subscribers, parameters, services. those are the most important functionalities you have to learn. and youll see, if you already have a good code structure for your nodes, adding more ros2 functionalities will be quite straightforward. want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here