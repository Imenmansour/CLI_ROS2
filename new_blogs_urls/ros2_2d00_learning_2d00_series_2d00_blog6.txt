element14 community search register log in site search log in register technologies more robotics  ros2 learning series -  6 - advanced programming - part 1  forum documents quiz events polls members mentions sub-groups tags more cancel new robotics requires membership for participation - click to join share more cancel group actions group rss more cancel engagement author author: crisdeodates date created: 13 apr 2024 5:35 pm date created views 271 views likes 2 likes comments 2 comments robot operating system robotics ros2 ros related recommended ros2 learning series -  6 - advanced programming - part 1 crisdeodates 13 apr 2024 ros2 camera stream project previously we got some basic insight on how to program ros2 nodes and services. now let us take a step further in ros2 programming. we will create a publisher node to capture a video stream from a camera and publish it to a topic. we will also create a subscriber node who will subscribe to the camera stream topic and display it in an opencv window. install the opencv dependencies.  pip install opencv-python create a new ros2 package with dependencies.  cd ~/ros2_ws/src  ros2 pkg create --build-type ament_python camera_stream --dependencies rclpy image_transport cv_bridge sensor_msgs std_msgs opencv-python create the camera_stream_publisher.py file and populate it with the following code : import rclpy from rclpy.node import node from sensor_msgs.msg import image from cv_bridge import cvbridge import cv2 class camerastreampub(node): """ create a camerastreampub class, which is a subclass of the node class. """ def __init__(self): """ class constructor to set up the node. """ # initiate the node class's constructor and give it a name. super().__init__('camera_stream_pub') # create the publisher. this publisher will publish an image # to the video_frame_data topic. the queue size is 10 messages. self.publisher_ = self.create_publisher(image, 'video_frame_data', 10) # we will publish a message every 0.1 seconds. timer_period = 0.1 # seconds # create the timer. self.timer = self.create_timer(timer_period, self.timer_callback) # create a videocapture object. # the argument '0' gets the default webcam. self.cap = cv2.videocapture(0) # used to convert between ros and opencv images. self.br = cvbridge() def timer_callback(self): """ callback function. this function gets called every 0.1 seconds. """ # capture frame-by-frame. # this method returns true/false as well # as the video frame. ret, frame = self.cap.read() if ret == true: # publish the image. # the 'cv2_to_imgmsg' method converts an opencv # image to a ros 2 image message. self.publisher_.publish(self.br.cv2_to_imgmsg(frame)) def main(args=none): """ main function to initialize the node and start the camera stream publisher. """ # initialize the rclpy library. rclpy.init(args=args) # create the node. camera_stream_publisher_node = camerastreampub() # spin the node so the callback function is called. rclpy.spin(camera_stream_publisher_node) # destroy the node explicitly. camera_stream_publisher_node.destroy_node() # shutdown the ros client library for python. rclpy.shutdown() if __name__ == '__main__': main() create the camera_stream_subscriber.py file and populate it with the following code: import rclpy from rclpy.node import node from sensor_msgs.msg import image from cv_bridge import cvbridge import cv2 class camerastreamsub(node): """ create a camerastreamsub class, which is a subclass of the node class. """ def __init__(self): """ class constructor to set up the node. """ # initiate the node class's constructor and give it a name. super().__init__('camera_stream_sub') # create the subscriber. this subscriber will receive an image # from the video_frames topic. the queue size is 10 messages. self.subscription = self.create_subscription( image, 'video_frame_data', self.listener_callback, 10) self.subscription # prevent unused variable warning # used to convert between ros and opencv images. self.br = cvbridge() self.running = true def listener_callback(self, data): """ callback function to receive and display images. """ if self.running: # convert ros image message to opencv image. current_frame = self.br.imgmsg_to_cv2(data) # display image. cv2.imshow("camera_stream", current_frame) # raise systemexit exception to quit if esc key is pressed. if cv2.waitkey(1) == 27: self.running = false cv2.destroyallwindows() raise systemexit def main(args=none): """ main function to initialize the node and start the camera stream subscriber. """ # initialize the rclpy library. rclpy.init(args=args) # create the node. camera_stream_subscriber_node = camerastreamsub() # spin the node so the callback function is called. try: rclpy.spin(camera_stream_subscriber_node) # exit if systemexit exception is raised. except systemexit: print("camera stream output stopped") # destroy the node explicitly. camera_stream_subscriber_node.destroy_node() # shutdown the ros client library for python. rclpy.shutdown() if __name__ == '__main__': main() add the entry points to setup.py inside console_scripts section: 'camera_stream_pub = camera_stream.camera_stream_publisher:main' , 'camera_stream_sub = camera_stream.camera_stream_subscriber:main' , since we already specified our dependencies during the package creation itself, we do not need to edit the package.xml file. build the package.  cd ~/ros2_ws  colcon build --packages-select camera_stream source the new package.  source install/setup.bash run the camera stream publisher node to start publishing the camera frames.  ros2 run camera_stream camera_stream_pub in another terminal, run the camera stream subscriber node.  cd ~/ros2_ws  source install/setup.bash  ros2 run camera_stream camera_stream_sub the camera frames will be displayed in an opencv window. you can press esc on the active opencv window to exit. sign in to reply crisdeodates 4 months ago in reply to dab yes. as long as the camera_stream_publisher node runs in the first terminal, it will continue to capture the camera images. cancel vote up 0 vote down sign in to reply more cancel dab 4 months ago i assume you can continue to capture camera frames and store them in the background even when the display window is closed. cancel vote up 0 vote down sign in to reply more cancel