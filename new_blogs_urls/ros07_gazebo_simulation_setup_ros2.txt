skip to content by sebastian gã¼nther â 27th december, 2021 â posted in robots , ros , gazebo , rviz in a robotics project, simulation is an important aspect that serves multiple purposes. first, you can test the behavioral code that you want your robot to execute. second, you can use the simulation to test different types of hardware, for example distance sensors, cameras or 3d point cloud sensors to see which works best. third, the same software that visualizes a simulation can be used in real time, with a real robot, to see the environment while its being scanned and navigated by the robot. in my robot project, i started with ros1 and provided a basic robot model that can be visualized with rviz. then, i build a first practical prototype, entirely arduino-based with no ros involved. in the current phase of the project, i work on building a gazebo compatible model with visual sensors. this article continues the series with a jumpstart into ros2 simulation with gazebo. we will get to know the essential tools for creating a simulation - ros launch files and gazebo - and learn to apply the essential steps - choosing 3d models, placing them in the world. the technical context for this article is ubuntu 20.04, ros2 foxy, gazebo11, but it should work with newer versions too. essential robotics simulation terminology this paragraph shortly lists all the terminology that is essential to understand the physical simulation aspects. skip this section if you are firm with the vocabulary. kinematics: kinematics is a branch of physics that governs how bodyâs move, in the dimensions of time, location, speed and acceleration, without considering the bodyâs' weight or outward forces, such as gravity kinetics: another branch of physics that considers how a bodyâs' location, speed and acceleration changes when the body has a mass and is affected by forces. (in robotics, this is also called robot dynamics) odometry: a method with which to estimate a bodies' location by continuously recording movement data and compute the distance and trajectory the body has moved inertia: this force is the resistance a moving body has to any other force that would change its direction, speed or acceleration friction: a force that applies when two bodies in proximity to another move and resist this movement joint: a joint is a mechanical element that connects two bodies. joints have different types describing how the connected bodies move. source: ros robot programming book rpy values: this acronym stands for roll, pitch, yaw that describe the movements of an object in 3d space. the object can move on these three axes according to the following graphic: source: wikipedia.org step by step: how to create a simulation world gazebo was started outside of ros, but became fully integrated. it focuses more on the complete physical simulation of a robot and a world. particularly, the world provides correct physical simulation through a physics engine: the robot can bump into objects, which will move and eventually even crash on your robot. gazebo comes with predefined world models, and you can even define your own model. in this tutorial, we will launch a gazebo simulation with an empty world, and then spawn a robot inside. in a nutshell, the essential steps are: create a new ros package and setup the directory structure create an empty world file create the launch file add additional physical properties in the robots urdf model parametrize the robots urdf model for running with gazebo or rviz. start the empty world with the launch file each following section details these tasks. step 1: package creation & directory structure we will create a package structure that looks as follows: radu_gazebo/ âââ config â âââ rviz.config âââ launch â âââ launch.py âââ radu_bot â âââ __init__.py âââ resource âââ scripts âââ test âââ urdf â âââ core.xacro âââ worlds â âââ room.world âââ package.xml âââ setup.cfg âââ setup.py for convenience, just run the following commands: ros2 pkg create --build-type python radu_gazebo mkdir radu_gazebo/launch radu_gazebo/world mkdir radu_gazebo/launch radu_gazebo/world/room.world touch radu_gazebo/launch/room.launch step 2: empty world file the room.world file is an sdf file that will contain <model> tags of everything we want to simulate: objects like walls, windows, and furniture. we will start with a simple empty world and new objects add step-by-step. <!-- file: world/room.world --> <?xml version='1.0'?> <sdf version="1.6"> <world name="room"> <include> <uri>model://sun</uri> </include> <include> <uri>model://ground_plane</uri> </include> </world> </sdf> you can load this file into gazebo manually. but since we will ultimately also spawn a robot in this model, its best to continue with the launch file straight ahead. step 3: launch file as we learned in the last article, ros2 does not support xml launch files anymore, and instead python files are used. the launch file that we use wraps the launch command from the gazebo_ros package, and provide a world argument. #!/usr/bin/python3 import os from ament_index_python.packages import get_package_share_directory from launch import launchdescription from launch.actions import declarelaunchargument from launch.actions import includelaunchdescription from launch.launch_description_sources import pythonlaunchdescriptionsource package_name = 'radu_bot' world_file = 'room.world' def generate_launch_description(): pkg_gazebo_ros = get_package_share_directory('gazebo_ros') pkg_radu_simulation = get_package_share_directory(package_name) # launch gazebo by including its definition gazebo = includelaunchdescription( pythonlaunchdescriptionsource( os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py'), ) ) # load the world file world_arg = declarelaunchargument( 'world', default_value=[os.path.join(pkg_radu_simulation, 'worlds', world_file), ''], description='sdf world file') return launchdescription([ gazebo, world_arg ]) step 4: extend the robot model with gazebo tags in order to use our urdf model from rviz in gazebo, we need to make several changes to the model. first of all, we need to provide additional physical aspects to the robot so that it behaves correctly in a simulation. second, the visual appearance of the robot differs. the color and text definition of an rviz model is not applicable. if you use meshes, they need to be changed as well. third, we also need additional plugins so that the gazebo tool works properly lets review these changes step-by-step. physical simulation properties inertia the inertia of an object is the counterforce that it applies when its current motion is influenced by another object. in gazebo models, the <inertial> tag is used to represent this aspect. here is an example: <link name="base_link"> <inertial> <origin xyz="0 0 0" rpy="0 0 0"/> <mass value="0.25" /> <inertia ixx="0.000486" ixy="0.0" ixz="0.0" iyy="0.000486" iyz="0.0" izz="0.000729"/> </inertial> <visual> <origin rpy="0 0 0" xyz="0 0 0"/> <geometry> <cylinder radius="0.09" length="0.09"/> </geometry> </visual> </link> the <origin> tag positions the link with respect to its parent link, here you would change the xyz values to move the estimated mass center. with <mass> you specify this links mass in kg. finally, the <inertial> element is a matrix of how forces on x, y, and z are affecting the link. you can read the physics article on wikipedia , or use this handy python script . friction another set of variables governs the friction of links in your robot. you express this with four values. first, <kp> and <kd> provide the static and dynamic  stiffness. here, we use the values 100000 and 1.0 , which is the default value used in many ros projects. second, the values <mu1> and <mu2> are the static and dynamic friction coefficients, which you can lookup on wikipedia based on the material of the link. <gazebo reference="base_link"> <kp>100000.0</kp> <kd>1.0</kd> <mu1>10.0</mu1> <mu2>10.0</mu2> </gazebo> collision this defines the hard material boundaries of your robot - it affects how gravity and other forces are applied to your robot in the simulation. these properties are expressed with the <collision> tag inside the links. its properties are very simply: just copy the original links' <geometry> and <origin> values as follows. <link name="base_link"> <inertial> <origin xyz="0 0 0" rpy="0 0 0"/> <mass value="0.25" /> <inertia ixx="0.000486" ixy="0.0" ixz="0.0" iyy="0.000486" iyz="0.0" izz="0.000729"/> </inertial> <visual> <origin rpy="0 0 0" xyz="0 0 0"/> <geometry> <cylinder radius="0.09" length="0.09"/> </geometry> </visual> <collision> <origin rpy="0 0 0" xyz="0 0 0"/> <geometry> <cylinder radius="0.09" length="0.09"/> </geometry> </collision> </link> joint characteristics the joints in your robot should be further modeled to express their real-world behavior. for all non-static, non-continuous joints, set <upper> and <lower> values for all continuous joints, add <effort> and <velocity> limits <joint name="camera_joint"> <limit upper="0.5" lower="-0.5"/> </joint> <joint name="left_wheel_joint"> <limit effort="0.1" velocity="0.005"/> </joint> visual simulation properties to change the visuals of your robot, you have these options: simple colors this works the same as in rviz: inside your links <visual> tags, you can reference a <color> element. <material name="blue"> <color rgba="0 0 0.8 1"/> </material> <link name="camera"> <visuals> <material name="blue"> </visuals> </link> predefined meshes gazebo provides a set of build-in meshes that are listed in this source code file . apply them be adding an <material> tags inside the <gazebo> tag as follows. <gazebo reference="base_link"> <material>gazebo/grey</material> </gazebo> custom meshes when you use custom meshes to represent your links, simple reference them in the <geometry> tag of your link as follows: <link name="camera"> <mesh filename:"package://radu_bot/model/meshes/camera.dae" /> </link> important: it is recommended to not use custom mesh files in the <collision> tags since this will affect the simulation performance. instead, define the values based on the available <geometry> types of boxes, cylinder and sphere. step 5: parametrize the robots urdf model for running with gazebo or rviz as you see, the required changes are fundamental. and they are not backwards compatible: all the changes required for gazebo cannot be parsed by rviz. for these reasons, complex robot projects separate the urdf aspects into different xacro files. after some experimentation, i came up with the following hierarchy. core - contains the core macros for rendering the links and the joints of the robot rviz - the rviz master file, it defines parameters and imports other files rviz_viusals - defines how the robot is visualized in rviz gazebo - the gazebo core file, as before it defines parameters and imports other files gazebo_visuals - defines how the robot is visualized in gazebo gazebo_physics - additional macros that calculate the <inertial> and <collision> tags of the links gazebo_sensor - adds sensor data gazebo_controll - adds the ros-control plugin and defines macros for rendering the <transmission> tags letâs see how this approach works in practice. when running xacro to render a model, the command xacro rviz.xacro -o radu_rviz_compiled.urdf will be used. this file will... import the other required files <xacro:include filename="(find radu_bot)/urdf2/core.xacro"/> <xacro:include filename="(find radu_bot)/urdf2/visuals.xacro"/> define the essential parameters that control the macro execution <xacro:property name="gazebo_build" value="false" /> <xacro:property name="rviz_build" value="true" /> execute the macros to create the urdf model <xacro:box_link name="base_link" size="0.6 0.3 0.05" color="{torso_color_name}" color_rgb="{torso_color_rgb}" /> <xacro:wheel_link name="right_wheel_frontside" /> <xacro:wheel_joint name="base_link_right_wheel_frontside" parent="base_link" child="right_wheel_frontside" xyz="0.2 -0.2 -0.05" /> <xacro:wheel_link name="right_wheel_backside" /> <xacro:wheel_joint name="base_link_right_wheel_backside" parent="base_link" child="right_wheel_backside" xyz="-0.2 -0.2 -0.05" /> <xacro:wheel_link name="left_wheel_frontside" /> <xacro:wheel_joint name="base_link_left_wheel_frontside" parent="base_link" child="left_wheel_frontside" xyz="0.2 0.2 -0.05" /> <xacro:wheel_link name="left_wheel_backside" /> <xacro:wheel_joint name="base_link_left_wheel_backside" parent="base_link" child="left_wheel_backside" xyz="-0.2 0.2 -0.05" /> after working with this approach for some time, i realized that the core logic of handling the variability is inside the core.xacro file: the macros for rendering links and joints have different blocks that will be triggered by the master file. see the following definition of a <link> . in line 3, an <xacro:if> condition is evaluated to add rviz-specific visuals. and in line 14, another condition checks and applies the gazebo physical properties to the model. <xacro:macro name="box_link" params="name size color color_rgb" > <link name="{name}"> <xacro:if value="{rviz_build}"> <visual> <origin xyz="0 0 0" rpy="0 0 0"/> <geometry> <box size="{size}"/> </geometry> <material name="{color}"> <color rgba="{color_rgb}"/> </material> </visual> </xacro:if> <xacro:if value="{gazebo_build}"> <pose>0 0 0 0 0 0</pose> <xacro:box_inertia m="0.6" x="0.7" y="0.4" z="0.2"/> <collision name="collision_{name}"> <origin xyz="0 0 0" rpy="0 0 0"/> <geometry> <box size="{size}"/> </geometry> </collision> </xacro:if> </link> </xacro:macro> step 6: spawning a robot the gazebo node is started with a launch file, but the robot needs to be spawn into the node. thanks to the  article how to spawn robots in ros2 , i created the following launch file. #!/usr/bin/python3 import os import sys import rclpy from gazebo_msgs.srv import spawnentity from ament_index_python.packages import get_package_share_directory package_name = 'radu_bot' def main(args=none): rclpy.init(args=args) node = rclpy.create_node('minimal_client') cli = node.create_client(spawnentity, '/spawn_entity') sdf_file_path = (os.path.join(get_package_share_directory(package_name), 'urdf', 'radu_gazebo_compiled.urdf')), model = open(sdf_file_path[0], 'r').read() print("model %s" %model) req = spawnentity.request( name = "radu_bot", xml = model, robot_namespace = "radu", reference_frame = "world", ) while not cli.wait_for_service(timeout_sec=1.0): node.get_logger().info('service not available, waiting again...') future = cli.call_async(req) rclpy.spin_until_future_complete(node, future) if future.result() is not none: node.get_logger().info( 'result ' + str(future.result().success) + " " + future.result().status_message) else: node.get_logger().info('service call failed %r' % (future.exception(),)) node.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() the launch file can also transform the xacro files during startup, as shown in the diff_bot example . for example, to load the gazebo configuration, you need to execute this: import xacro def generate_launch_description(): pkg_radu_simulation = get_package_share_directory(package_name) robot_description_path = os.path.join( pkg_radu_simulation, "urdf", "gazebo.xacro", ) robot_description = {"robot_description": xacro.process_file(robot_description_path).toxml()} launching the robot first, we build the current workspace. > colcon build --symlink-install --cmake-clean-first --event-handlers console_direct+ --packages-up-to radu_bot then we launch gazebo. > ros2 launch radu_bot gazebo.launch.py [info] [launch]: all log files can be found below /home/devcon/.ros/log/2021-05-30-09-07-30-541933-giga-36879 [info] [launch]: default logging verbosity is set to info [info] [gzserver-1]: process started with pid [36886] [info] [gzclient -2]: process started with pid [36889] and then spawn the robot. > ros2 run radu_bot spawn_radu [info] [1622358479.722919377] [minimal_client]: result true spawnentity: successfully spawned entity [radu_bot] finally, the robot is rendered: conclusion this article showed you how to create a gazebo compatible simulation in ros2 from scratch. it turned out to be lengthy process in which you need to (1) create a package, (2) create the world file, (3) create the launch file, (4) add gazebo specific tags to our robot model, (5) parametrize your robot model to be compatible with gazebo and rviz, and (6) spawn the robot entity in the simulation. form all these steps. adding the gazebo physics was time-intensive to learn and apply, and i hope you gained valuable insights as well. at the end, we can spawn radu in gazebo and rviz with a custom launch script file. and from here, we can move the robot around in its simulation. robots ros gazebo rviz previous: robot operating system: practical guide for migrating from ros1 to ros2 next: robot operating system: expose control nodes for an interactive simulation in gazebo menu