skip to content in ros2, when you create a package you have to select a build type: either ament_cmake or ament_python. this will determine whether your package is a cpp package, or a python package. but how to do if you want to create a ros2 package containing both python nodes and cpp nodes? good news for you: its possible, and in this tutorial ill show you how to create and configure your python and cpp nodes in the same package. first things first, make sure you already know how to setup a standard ros2 python package , and a ros2 cpp package . >> watch this video as an additional resource to this article: you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! table of contents toggle how well manage to setup python and cpp nodes in the same ros2 package first well create a ros2 cpp package, which contains a package.xml and cmakelists.txt. for cpp related stuff, nothing will be too different from what youre already used to do. for python, well add some folders and files so you an add your py nodes inside the package. and well configure the python stuff in the cmakelists.txt. this is one of the main difference youll have from a standard python package. no more setup.py and setup.cfg, everything will be done in the cmakelists.txt. note: the method i propose here is not necessarily the only one. you have many different ways to achieve that. first follow this tutorial to get something working, and then modify the architecture/configuration as you need. setup your ros2 cpp and python package the name of the package for this tutorial will be my_cpp_py_pkg. create a standard cpp package first create the package with the ament_cmake build type . plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/  ros2 pkg create my_cpp_py_pkg --build-type ament_cmake  cd ~/ros2_ws/src/  ros2 pkg create my_cpp_py_pkg --build-type ament_cmake  cd ~/ros2_ws/src/  ros2 pkg create my_cpp_py_pkg --build-type ament_cmake for now the package contains those files: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter my_cpp_py_pkg/  cmakelists.txt  include   my_cpp_py_pkg  package.xml  src my_cpp_py_pkg/  cmakelists.txt  include   my_cpp_py_pkg  package.xml  src my_cpp_py_pkg/  cmakelists.txt  include   my_cpp_py_pkg  package.xml  src this is the base for a cpp package. later on, from that base well add necessary files and configuration for python. add a cpp node + header lets add a .cpp file in the src/ directory, and an .hpp header file in the include/my_cpp_py_pkg/ directory. no need to create new folders here. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd my_cpp_py_pkg/  touch src/cpp_node.cpp  touch include/my_cpp_py_pkg/cpp_header.hpp  cd my_cpp_py_pkg/  touch src/cpp_node.cpp  touch include/my_cpp_py_pkg/cpp_header.hpp  cd my_cpp_py_pkg/  touch src/cpp_node.cpp  touch include/my_cpp_py_pkg/cpp_header.hpp note: if your cpp_node.cpp file needs to include the cpp_header.hpp file youll have to write #include "my_cpp_py_pkg/cpp_header.hpp" #include "my_cpp_py_pkg/cpp_header.hpp" . note 2: you have to have a main() in your cpp_node otherwise the compilation step wont succeed. you can just add a minimal c++ node if youre following this tutorial by the letter. add a python node + module to import lets setup the package so it can also have python nodes. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  mkdir my_cpp_py_pkg  touch my_cpp_py_pkg/__init__.py  mkdir scripts  mkdir my_cpp_py_pkg  touch my_cpp_py_pkg/__init__.py  mkdir scripts  mkdir my_cpp_py_pkg  touch my_cpp_py_pkg/__init__.py  mkdir scripts the first folder we create has the same name as the package. inside this folder we create an empty __init__.py file. this is something that is already present when you create a python package. this folder will host any library and module we want to use or export. then we create a scripts/ folder. in there well place our executables (and nodes). now that we have the structure, lets add one python module and one node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  touch my_cpp_py_pkg/module_to_import.py  touch scripts/py_node.py  touch my_cpp_py_pkg/module_to_import.py  touch scripts/py_node.py  touch my_cpp_py_pkg/module_to_import.py  touch scripts/py_node.py important : you have to add a shebang line first thing in the py_node.py file: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #!/usr/bin/env python3 ... #!/usr/bin/env python3 ... #!/usr/bin/env python3 ... this is something you dont have to do with a standard ros2 python package (its managed for you), but with this setup if you dont add this line, you will get an error when you try to start the node with ros2 run ros2 run or from a launch file. also (and well come back to it later), if you want to be able to modify your code and re-run it without recompiling every time, or if you simply want to start your node by launching your script directly, then make the script executable: chmod +x scripts/py_node.py chmod +x scripts/py_node.py . note: if you want to import the module_to_import.py file from your py_node.py file (or from any other file from other packages), youll have to write from my_cpp_py_pkg.module_to_import import ... from my_cpp_py_pkg.module_to_import import ... . ros2 package architecture with both python and cpp nodes  final by now your package should look like this: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter my_cpp_py_pkg/ # --> package info, configuration, and compilation  cmakelists.txt  package.xml # --> python stuff  my_cpp_py_pkg   __init__.py   module_to_import.py  scripts   py_node.py # --> cpp stuff  include   my_cpp_py_pkg   cpp_header.hpp  src  cpp_node.cpp my_cpp_py_pkg/ # --> package info, configuration, and compilation  cmakelists.txt  package.xml # --> python stuff  my_cpp_py_pkg   __init__.py   module_to_import.py  scripts   py_node.py # --> cpp stuff  include   my_cpp_py_pkg   cpp_header.hpp  src  cpp_node.cpp my_cpp_py_pkg/ # --> package info, configuration, and compilation  cmakelists.txt  package.xml # --> python stuff  my_cpp_py_pkg   __init__.py   module_to_import.py  scripts   py_node.py # --> cpp stuff  include   my_cpp_py_pkg   cpp_header.hpp  src  cpp_node.cpp the cmakelists.txt and package.xml will be used for both python and cpp nodes. for the rest, you can see that cpp stuff is clearly separated from python stuff. now, dont forget to write something to run in the python and cpp files, and after that lets configure the package! configure your ros2 package for both cpp and python package.xml plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> < package format = "3" > < name > my_cpp_py_pkg </ name > < version > 0.0.0 </ version > < description > todo: package description </ description > < maintainer email = "your@email.com" > name </ maintainer > < license > todo: license declaration </ license > < buildtool _depend > ament_cmake</buildtool_depend> < buildtool _depend > ament_cmake_python</buildtool_depend> < depend > rclcpp </ depend > < depend > rclpy </ depend > < test _depend > ament_lint_auto</test_depend> < test _depend > ament_lint_common</test_depend> < export > < build _type > ament_cmake</build_type> </ export > </ package > <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> <package format="3"> <name>my_cpp_py_pkg</name> <version>0.0.0</version> <description>todo: package description</description> <maintainer email="your@email.com">name</maintainer> <license>todo: license declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake_python</buildtool_depend> <depend>rclcpp</depend> <depend>rclpy</depend> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> <package format="3"> <name>my_cpp_py_pkg</name> <version>0.0.0</version> <description>todo: package description</description> <maintainer email="your@email.com">name</maintainer> <license>todo: license declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake_python</buildtool_depend> <depend>rclcpp</depend> <depend>rclpy</depend> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> first of all, if you ever need to share your package with other people, or publish it on the internet, dont forget to modify the version, description, maintainer (+ author if needed), and license tags. here is what we added: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter < buildtool _depend > ament_cmake</buildtool_depend> < buildtool _depend > ament_cmake_python</buildtool_depend> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake_python</buildtool_depend> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake_python</buildtool_depend> by default you should already have a buildtool_depend tag for ament_cmake, since thats what we asked when creating the package from command line. here we add another buildtool_depend tag: ament_cmake_python. note: in a standard python package, youd have ament_python, not ament_cmake_python. make sure not to mix those 2. using ament_cmake_python means that well be able to setup our python stuff with cmake, so, from the cmakelists.txt file. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter < depend > rclcpp </ depend > < depend > rclpy </ depend > <depend>rclcpp</depend> <depend>rclpy</depend> <depend>rclcpp</depend> <depend>rclpy</depend> we add a dependency for the ros2 cpp library (rclcpp) as well as the ros2 python library (rclpy). thats it for package.xml. cmakelists.txt heres the complete cmakelists.txt to install both cpp and python nodes. i have removed some stuff we dont use here (default to c99, and the test section). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter cmake_minimum_required(version 3. 5 ) project(my_cpp_py_pkg) # default to c++14 if (not cmake_cxx_standard) set(cmake_cxx_standard 14 ) endif() if (cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang" ) add_compile_options(-wall -wextra -wpedantic) endif() # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) ament_package() cmake_minimum_required(version 3.5) project(my_cpp_py_pkg) # default to c++14 if(not cmake_cxx_standard) set(cmake_cxx_standard 14) endif() if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) ament_package() cmake_minimum_required(version 3.5) project(my_cpp_py_pkg) # default to c++14 if(not cmake_cxx_standard) set(cmake_cxx_standard 14) endif() if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) ament_package() basically, we can split this config into 3 parts: dependencies, cpp part, and python part. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) # find dependencies find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) we import external dependencies for both cpp and python at the same time. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) # include cpp "include" directory include_directories(include) # create cpp executable add_executable(cpp_executable src/cpp_node.cpp) ament_target_dependencies(cpp_executable rclcpp) # install cpp executables install(targets cpp_executable destination lib/{project_name} ) this is the cpp part. first we include the include directory so the cpp_header.hpp file can be found. then its business as usual: you create an executable, link with dependencies, and install the executable in the lib/ folder of your package (inside the install/ folder of your ros2 workspace). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) # install python modules ament_python_install_package({project_name}) # install python executables install(programs scripts/py_node.py destination lib/{project_name} ) and this is the python part, which should be new to you if youve always installed ros2 python nodes from setup.py (which does not exist here). first, use ament_python_install_package({project_name}) ament_python_install_package({project_name}) to install any python module (in this example: files under my_cpp_py_pkg/ folder), so you can find them from this  or another  package. then, we install the scripts/py_node.py file. we put this file in the install lib/ folder, which is the same folder as for ros2 cpp nodes. thus all cpp/python executables will be at the same place. for any new python script you need to install, just add a new line here. after being copied, the installed file will be automatically made executable. compile and run your ros2 cpp and python nodes lets compile our ros2 python/cpp package. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/  colcon build --packages-select my_cpp_py_pkg  cd ~/ros2_ws/  colcon build --packages-select my_cpp_py_pkg  cd ~/ros2_ws/  colcon build --packages-select my_cpp_py_pkg open 2 new terminals, source the ros2 environment, and you can start both cpp and python nodes. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run my_cpp_py_pkg cpp_executable  ros2 run my_cpp_py_pkg cpp_executable  ros2 run my_cpp_py_pkg cpp_executable plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run my_cpp_py_pkg py_node.py  ros2 run my_cpp_py_pkg py_node.py  ros2 run my_cpp_py_pkg py_node.py important : if you wish to compile with the --symlink-install --symlink-install option (so you can modify and re-run a script without having to re-compile), youll have to make your scripts executable with chmod +x chmod +x . otherwise when you try to run your node youll get this error :no executable found. going further in this tutorial youve seen how to create and setup a ros2 package for both python and cpp nodes. as you can see its not that difficult, and as long as you clearly separate your python/cpp files, as well as the python/cpp configuration, nothing should go wrong. if you wish to install other things in this package, such as launch files, yaml config files, etc., then you just need to install them as you would in a standard cpp package . want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here