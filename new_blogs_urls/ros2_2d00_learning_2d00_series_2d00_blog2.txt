element14 community search register log in site search log in register technologies more robotics  ros2 learning series -  2 - basic concepts  forum documents quiz events polls members mentions sub-groups tags more cancel new robotics requires membership for participation - click to join share more cancel group actions group rss more cancel engagement author author: crisdeodates date created: 9 apr 2024 10:23 am date created views 269 views likes 5 likes comments 2 comments robot operating system robotics ros2 ros related recommended ros2 learning series -  2 - basic concepts crisdeodates 9 apr 2024 ros2 - basic concepts let's dig into the ros2 concepts, starting with the basic ones. wherever used, ros means in the general context of both ros1 & ros2, unless specified. client library the base library of ros2 is written in c, called ros client library or rcl, which sits between these other client libraries and the dds communication interface. other libraries are built on top of rcl and act as wrappers for other programming languages to implement ros code. code written using these different client libraries can share messages with each other because all the client libraries implement the necessary code generators that provide the users with a capability to interact with ros2 interface files in their respective language. e.g. rclcpp, rclpy. the advantage of this approach is that if any changes are made to the logic/behavior of the functionality in the core rcl library, all client libraries that use the rcl will have these changes reflected in them. nodes picture courtesy: https://docs.ros.org/en/foxy/_images/nodes-topicandservice.gif normally a ros2 system revolves around a ros graph which visualizes the interconnected network of nodes within the system. these nodes can be seen as processes or participants or simply executables that use topics as data channels to communicate messages between them. nodes can subscribe to a topic or publish to it. all nodes subscribed to the same topic will receive the published data or message on that topic. nodes can provide configurable parameters to change their behavior during run-time. topics & messages in the ros publish - subscribe model, publisher nodes produce the data and subscriber nodes consume the data. the data communication between the nodes happens via topics or topic name which are essentially data channels that allow passage of message information between various nodes. these messages can be discrete data like interrupt information or continuous data stream like robot state, sensor readings etc. all publishers and subscribers that are on the same topic name can directly communicate with each other. also, when data is published to the topic by any of the publishers, all subscribers in the system will receive the data. messages contain specific information and may contain one or more datatypes in it. services apart from just publishing and subscribing to information, nodes can often act as a service client to have another node in the system perform a computation on their behalf. the node that performs this computation for another node is a service server. this is like remote procedure calls where the client (requester) waits for the server (responder) to make a short computation and return a result. to maintain a distributed architecture, each node periodically advertise their presence so that connections can be made with new-found entities, allowing discovery. hoever, nodes will only establish connections with other nodes if they have compatible quality of service settings. actions picture courtesy: https://docs.ros.org/en/foxy/_images/action-singleactionclient.gif ros2 services are expected to compute and return quickly, since the client is generally waiting for the result. if the computation is long-running, actions should be used instead of services. for such long-running computations, a node can act as an action client to have another node perform the computation on their behalf, or as an action server to provide functionality to other nodes. actions can be considered as long-running remote procedure call with feedback and the ability to cancel or preempt the goal. in ros2, actions enable one node (the client) to send a request to another node (the action server) to perform a specific action. while the action is being performed, the server will constantly send feedback to the client with details  the progress of the action being performed. once the action is completed, the server will send a result to the client with the final action outcome. ros actions are like ros services, except that the action server sends feedback, while the ros service would not. namespaces namespaces provide a method to divide a ros network into different isolated groups. this is very useful in multi-robot systems and when managing large projects. it creates a unique context for ros nodes, topics, and services. in other words, namespaces allow the ros nodes to have the same name but operate in different contexts. for example, when two robots in the same network have nodes and topics with the same name, giving unique namespaces allow them to operate independently. parameters in ros2, parameters are linked to nodes and are used to configure the nodes at startup or during runtime, without any changes to the code. parameters can be created and used to control the behavior of the nodes, even during runtime. they act like settings for a node and each node maintains its own parameters. a node can register a callback to be informed when a parameter is changed by user, allowing to tune the node behavior on the fly. launch files for a complex ros system, there will be multiple nodes and running each of their nodes will present a huge task. hence ros allows automation in this scenario using launch systems. the launch system in ros automates the running of multiple nodes with a single command. it also contains the configuration of the system, nodes to execute, arguments to pass to nodes, etc. launch files can be written in python, xml, or yaml. command line tools ros2 has a plethora of commands that can be used for a variety of tasks. the main command is ros2 followed by a subcommand and arguments. as ros2 uses this distributed discovery process for nodes to connect to each other, it can take time for ros nodes to discover all other participants in the ros graph. because of this, a long-running daemon is automatically started in the background when the relevant command-line tools are used for the first time. this daemon stores information  the ros graph to provide faster responses to queries. reference sign in to reply crisdeodates 4 months ago in reply to dab thanks a lot for the feedback dab cancel vote up 0 vote down sign in to reply more cancel dab 4 months ago i like it, nice simple and easy to use. cancel vote up 0 vote down sign in to reply more cancel