first steps tutorials overview first micro-ros application on linux first micro-ros application on an rtos zephyr emulator teensy with arduino programming with rcl and rclc overview nodes publishers and subscribers services parameter server executor and timers quality of service micro-ros utilities advanced tutorials overview middleware configuration how to include a custom ros message in micro-ros handling messages memory in micro-ros how to use custom qos in micro-ros creating custom micro-ros transports creating custom static micro-ros library benchmarking with the shadow-builder unmaintained tutorials adding micro-ros to a nuttx board configuration nsh console over uart & usb 6lowpan guide debugging a nuttx application micro-ros configuration for nuttx demos overview kobuki demo crazyflie demo time of flight sensor demo openmanipulator-x demo interfacing with fiware context broker demobox power and boot time thumper, a six-wheeled robot moveit 2 demo edge impulse demo combined demos first micro-ros application on linux in this tutorial, youll learn the use of micro-ros with linux by testing a ping pong application. in the follow-up tutorial first micro-ros application on an rtos , youll learn how to build and bring this application on a microcontroller running the rtos nuttx, freertos, or zephyr. finally, in the tutorial zephyr emulator youll learn how to test a micro-ros application on a zephyr emulator. installing ros 2 and the micro-ros build system first of all, install ros 2 humble hawksbill on your ubuntu 22.04 lts computer. to do so from binaries, via debian packages, follow the instructions detailed here . tip: alternatively, you can use a docker container with a fresh ros 2 humble installation. the one that serves the purpose is the container run by the command: docker run -it --net = host -v /dev:/dev --privileged ros:humble once you have a ros 2 installation in the computer, follow these steps to install the micro-ros build system: # source the ros 2 installation source /opt/ros/ ros_distro /setup.bash # create a workspace and download the micro-ros tools mkdir microros_ws cd microros_ws git clone -b ros_distro https://github.com/micro-ros/micro_ros_setup.git src/micro_ros_setup # update dependencies using rosdep sudo apt update && rosdep update rosdep install --from-paths src --ignore-src -y # install pip sudo apt-get install python3-pip # build micro-ros tools and source them colcon build source install /local_setup.bash these instructions will setup a workspace with a ready-to-use micro-ros build system. this build system is in charge of downloading the required cross-compilation tools and building the apps for the required platforms. the build systems workflow is a four-step procedure: create step: this step is in charge of downloading all the required code repositories and cross-compilation toolchains for the specific hardware platform. among these repositories, it will also download a collection of ready to use micro-ros apps. configure step: in this step, the user can select which app is going to be cross-compiled by the toolchain. some other options, such as transport, agents ip address/port (for udp transport) or device id (for serial connections) will be also selected in this step. build step: here is where the cross-compilation takes place and the platform-specific binaries are generated. flash step: the binaries generated in the previous step are flashed onto the hardware platform memory, in order to allow the execution of the micro-ros app. further information  micro-ros build system can be found here . creating a new firmware workspace once the build system is installed, lets create a firmware workspace that targets all the required code and tools: # create firmware step ros2 run micro_ros_setup create_firmware_ws.sh host once the command is executed, a folder named firmware must be present in your workspace. this step is in charge, among other things, of downloading a set of micro-ros apps for linux, that are located at src/uros/micro-ros-demos/rclc . each app is represented by a folder containing the following files: main.c : this file contains the logic of the application. cmakelists.txt : this is the cmake file containing the script to compile the application. for the user to create a custom application, a folder <my_app> will need to be registered in this location, containing the two files just described. also, any such new application folder needs to be registered in src/uros/micro-ros-demos/rclc/cmakelists.txt by adding the following line: export_executable(<my_app>) in this tutorial, we will focus on the out-of-the-box ping_pong application located at src/uros/micro-ros-demos/rclc/ping_pong . you can check the complete content of this app here . this example showcases a micro-ros node with two publisher-subscriber pairs associated with a ping and a pong topics, respectively. the node sends a ping package with a unique identifier, using a ping publisher. if the ping subscriber receives a ping from an external node, the pong publisher responds to the incoming ping with a pong . to test that this logic is correctly functioning, we implement communication with a ros 2 node that: listens to the topics published by the ping subscriber. publishes a fake_ping package, that is received by the micro-ros ping subscriber. as a consequence, the pong publisher on the micro-ros application will publish a pong , to signal that it received the fake_ping correctly. the diagram below clarifies the communication flow between these entities: the contents of the host app specific files can be found here: main.c and cmakelists.txt . a thorough review of these files is illustrative of how to create a micro-ros app in this rtos. building the firmware once the app has been created, the build step is in order. notice that, with respect to the four-steps workflow delined above, we would expect a configuration step to happen before building the app. however, given that we are compiling micro-ros in the host machine rather than in a board, the cross-compilation implemented by the configuration step is not required in this case. we can therefore proceed to build the firmware and source the local installation: # build step ros2 run micro_ros_setup build_firmware.sh source install /local_setup.bash creating the micro-ros agent the micro-ros app is now ready to be connected to a micro-ros agent to start talking with the rest of the ros 2 world. to do that, lets first of all create a micro-ros agent: # download micro-ros-agent packages ros2 run micro_ros_setup create_agent_ws.sh now, lets build the agent packages and, when this is done, source the installation: # build step ros2 run micro_ros_setup build_agent.sh source install /local_setup.bash running the micro-ros app at this point, you have both the client and the agent correctly installed in your host machine. to give micro-ros access to the ros 2 dataspace, run the agent: # run a micro-ros agent ros2 run micro_ros_agent micro_ros_agent udp4 --port 8888 and then, in another command line, run the micro-ros node (remember sourcing the ros 2 and micro-ros installations, and setting the rmw micro xrce-dds implementation): source /opt/ros/ ros_distro /setup.bash source install /local_setup.bash # use rmw micro xrce-dds implementation export rmw_implementation = rmw_microxrcedds # run a micro-ros node ros2 run micro_ros_demos_rclc ping_pong testing the micro-ros app now, we want to check that everything is working. open a new command line. we are going to listen to the ping topic with ros 2 to check whether the micro-ros ping pong node is correctly publishing the expected pings: source /opt/ros/ ros_distro /setup.bash # subscribe to micro-ros ping topic ros2 topic echo /microros/ping you should see the topic messages published by the ping pong node every 5 seconds: user@user:~ ros2 topic echo /microros/ping stamp: sec: 20 nanosec: 867000000 frame_id: '1344887256_1085377743' --- stamp: sec: 25 nanosec: 942000000 frame_id: '730417256_1085377743' --- at this point, we know that our app is publishing pings. lets check if it also answers to someone elses pings. if this works, itll publish a pong. so, first of all, lets subscribe with ros 2 to the pong topic from a new shell (notice that initially we dont expect to receive any pong, since none has been sent yet): source /opt/ros/ ros_distro /setup.bash # subscribe to micro-ros pong topic ros2 topic echo /microros/pong and now, lets publish a fake_ping with ros 2 from yet another command line: source /opt/ros/ ros_distro /setup.bash # send a fake ping ros2 topic pub --once /microros/ping std_msgs/msg/header '{frame_id: "fake_ping"}' now, we should see this fake_ping in the ping subscriber console, along with the micro-ros pings: user@user:~ ros2 topic echo /microros/ping stamp: sec: 0 nanosec: 0 frame_id: fake_ping --- stamp: sec: 305 nanosec: 973000000 frame_id: '451230256_1085377743' --- stamp: sec: 310 nanosec: 957000000 frame_id: '2084670932_1085377743' --- also, we expect that, because of having received the fake_ping , the micro-ros node will answer with a pong : user@user:~ ros2 run micro_ros_demos_rcl ping_pong ping send seq 1706097268_1085377743 ping send seq 181171802_1085377743 ping send seq 1385567526_1085377743 ping send seq 926583793_1085377743 ping send seq 1831510138_1085377743 ping received with seq fake_ping. answering. ping send seq 1508705084_1085377743 ping send seq 1702133625_1085377743 ping send seq 176104820_1085377743 as a consequence, in the pong subscriber console, we should see the micro-ros app answer to our fake_ping : user@user:~ ros2 topic echo /microros/pong stamp: sec: 0 nanosec: 0 frame_id: fake_ping --- multiple ping pong nodes one of the advantages of having a linux micro-ros app is that you dont need to buy a bunch of hardware in order to test some multi-node micro-ros apps. so, with the same micro-ros agent of the last section, lets open four different command lines and run the following on each: cd microros_ws source /opt/ros/ ros_distro /setup.bash source install /local_setup.bash export rmw_implementation = rmw_microxrcedds ros2 run micro_ros_demos_rclc ping_pong as soon as all micro-ros nodes are up and connected to the micro-ros agent you will see them interacting: user@user:~ ros2 run micro_ros_demos_rclc ping_pong ping send seq 1711620172_1742614911 <---- this micro-ros node sends a ping with ping id "1711620172" and node id "1742614911" pong for seq 1711620172_1742614911 (1) <---- the first mate pongs my ping pong for seq 1711620172_1742614911 (2) <---- the second mate pongs my ping pong for seq 1711620172_1742614911 (3) <---- the third mate pongs my ping ping received with seq 1845948271_546591567. answering. <---- a ping is received from a mate identified as "546591567", let's pong it. ping received with seq 232977719_1681483056. answering. <---- a ping is received from a mate identified as "1681483056", let's pong it. ping received with seq 1134264528_1107823050. answering. <---- a ping is received from a mate identified as "1107823050", let's pong it. ping send seq 324239260_1742614911 pong for seq 324239260_1742614911 (1) pong for seq 324239260_1742614911 (2) pong for seq 324239260_1742614911 (3) ping received with seq 1435780593_546591567. answering. ping received with seq 2034268578_1681483056. answering. improve this page  previous next  we would like to use third party s and scripts to improve the functionality of this website. approve more info