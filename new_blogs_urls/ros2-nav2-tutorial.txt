skip to content in this ros2 nav2 tutorial you will learn the basics of the navigation 2 stack, step by step. you will first install the nav2 stack on ros2 humble, then you will start directly to generate a map with slam. after this, we will check whats inside the map, and then use this map with the navigation 2 stack, so that we can make a robot navigate inside the map. to do all that, you actually dont need to buy any hardware, we will use the simulation of an already configured robot, the turtlebot3, on gazebo. and this tutorial is in fact inspired by this 1h crash course video: you can watch the video and use the written tutorial to get all the commands quickly. you are learning navigation 2 with ros2? check out this ros2 nav2 course, and learn step by step, from scratch. table of contents toggle what is ros2 nav2? lets quickly understand what nav2 is and why we need it. and before we get started, lets just be clear on the  we are going to use. when i write  navigation, navigation 2, nav2, well this is all the same, i am writing  the navigation 2 stack in ros2 (also if i write ros i also mean ros2). so, why do we need nav2 in the first place? well, as you probably already know, ros is a great framework that allows you to develop new robotics applications in no time. you get a lot of plumbing already done for you, a huge set of plug & play libraries, a community to help you, etc. now, how do you go from knowing the ros basics, to successfully implementing navigation for a mobile robot? this is not trivial at all, and fortunately, the navigation 2 stack was developed just for that. the stack is a collection of packages that have been developed with one goal in mind. and what is this goal? the main goal is to make a robot move from point a to point b, in a safe way. so, basically, to find a path that allows the robot to reach the destination, while making sure that it will not collide with other robots, with people, and obstacles. to achieve this, we will do a 2 step process: we will create a map of the environment using slam. we will make the robot navigate using this map  with the navigation functionalities and tools. install nav2 as a prerequisite for this tutorial, make sure you have installed ubuntu and ros2 on your computer. i strongly recommend using a dual boot for ubuntu, not a virtual machine (3d tools like gazebo are usually not working well on vms). if you do want to use a vm, choose vmware workstation (free version) over virtualbox. for the following, i will use ubuntu 22.04 and ros2 humble. so, once you have correctly installed and setup ros2 on your computer, lets install the navigation 2 stack. here is how to install the nav2 packages. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup as we will use a simulation of a robot on gazebo, lets install the packages for this robot (turtlebot3). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-turtlebot3*  sudo apt install ros-humble-turtlebot3*  sudo apt install ros-humble-turtlebot3* and thats it to get started! make the robot move in the environment before we generate a map with nav2 and use it for navigation, we need to make sure that we can make our robot move in the environment. if you were using a custom robot, you would need to adapt it first for nav2. this process is really not easy, especially if youre doing it for the first time. so, to make things easier  as the goal here is just to get an introduction of the stack  we will use the turtlebot3 in gazebo. we first need to export an environment variable to choose which version of the turtlebot3 we want to use (burger, waffle, waffle_pi). add this line at the end of your .bashrc: export turtlebot3_model=waffle export turtlebot3_model=waffle . after doing that, make sure to source the .bashrc, or to open a new terminal. then, time to start the simulated robot in a gazebo world. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py note: the first time you launch this world, it may take some time (a few minutes) and youll have the impression that it froze on the loading screen. dont worry, just wait, dont touch anything, and let it load the map. then, when you start again, it will be much faster. great, now we have a robot inside a room. lets make it move. in a new terminal, start the teleop node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard you will see some instructions on the terminal. press keys w, a, s, d, to make the robot move. its not necessarily super intuitive the first time you use it, so take a few minutes to familiarize yourself with the commands. and make sure your mouse is focused on the terminal when you press a key. once you can make the robot move in the world, you are ready for the next steps. generate a map with ros2 nav2  using slam in order to make the robot navigate autonomously in the world, we first need to generate a map of that world. and to do that, well use the slam functionality of the ros2 nav2 stack. note: there are many possible tools and algorithms to do slam. to make it easier well choose the default slam tool for turtlebot3: cartographer. later on you can choose to use other tools, such as slam_toolbox . so, how to generate a map with slam? start the slam functionality and rviz first make sure you have started the robot  here, turtlebot3 in gazebo. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py then, lets start the slam functionality for turtlebot3. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=true  ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=true  ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=true note: i provide the use_sim_time argument because we are running on gazebo, so we want to use the gazebo time. if using a real robot, skip this argument. after running this command you will see rviz starting. you can see the tfs of the robot, as well as the laserscan from the lidar sensor (red dots). some pixels are already grey/black. as you make the robot move, pixels will be cleared into 3 categories: free space (will turn white), obstacle (will turn black), unknown space (will stay grey). generate and save the map now, make the robot move in the world. here we start the turtlebot3 teleop node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard make the robot move around until you get a satisfying result. by the way, what is a satisfying result? well if you can manage to clear most of the free space (white pixels), and get most of the obstacles (black pixels), thats good enough, and navigation will work fine. no need to clear 100% of the pixels. once you get a good enough result, its time to save the map. make sure you dont stop the navigation terminal before you save the map, otherwise youll have to start everything again. to save the map, open a new terminal and run this command. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run nav2_map_server map_saver_cli -f my_map  ros2 run nav2_map_server map_saver_cli -f my_map  ros2 run nav2_map_server map_saver_cli -f my_map with the optional -f argument you can specify the path/name for the map. dont add any extension, this will be done automatically for you. once you run this, you should see some logs in white and maybe yellow. if it doesnt work (red error logs), try again several times. your map has now been generated, and you can stop all the commands in all the terminals. whats in the map? you should now have 2 new files: my_map.yaml my_map.pgm the pgm file is the image representing the map, with white (free space), black (obstacles) and grey pixels (unknown space). the yaml file contains important info  the map. this will be used by the navigation stack. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter image: my_map.pgm mode: trinary resolution: 0.05 origin: [ -2.97 , -2.57 , 0 ] negate: 0 occupied_thresh: 0.65 free_thresh: 0.25 image: my_map.pgm mode: trinary resolution: 0.05 origin: [-2.97, -2.57, 0] negate: 0 occupied_thresh: 0.65 free_thresh: 0.25 image: my_map.pgm mode: trinary resolution: 0.05 origin: [-2.97, -2.57, 0] negate: 0 occupied_thresh: 0.65 free_thresh: 0.25 here is more info  the most important fields: image: the relative path from the yaml file to the pgm file. resolution: in meters per pixels. so, here 0.05 meters per pixels. one pixel represents 5 cm. that gives you the precision of the map. origin: the coordinates of the robot (when it started) relative to the lowest left point on the map. negate: if you set it to 1, then free and occupied space will be inverted. occupied_tresh and free_tresh: very basically put, when mapping, each pixel will be given a probability  whether there is an obstacle or not. with the values that you see here, if the probability is greater than 65%, we consider the space to be occupied. if the probability is less than 25%, the space is free. quick fix and dds issue with nav2 before we continue with navigation, we need to fix 2 small things. first, as you may know, ros2 communication is based on dds (for the middleware). no need to dive into this now, you just have to know that there are several possible dds implementations, and the default one for ros2 is fast dds. unfortunately it doesnt work so well with nav2, so its been recommended to use cyclone dds instead. lets install and setup cyclone dds for ros2. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-rmw-cyclonedds-cpp  sudo apt install ros-humble-rmw-cyclonedds-cpp  sudo apt install ros-humble-rmw-cyclonedds-cpp cyclone dds is now installed, now you need to tell ros2 to use it instead of the default one. add this line into your .bahsrc: export rmw_implementation=rmw_cyclonedds_cpp export rmw_implementation=rmw_cyclonedds_cpp . you can put it just before sourcing ros2 for example. great, dds problem solved! one more thing to do, and this is a turtlebot3 specific issue. open this param file: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo gedit /opt/ros/humble/share/turtlebot3_navigation2/param/waffle.yaml  sudo gedit /opt/ros/humble/share/turtlebot3_navigation2/param/waffle.yaml  sudo gedit /opt/ros/humble/share/turtlebot3_navigation2/param/waffle.yaml find this line, and replace it like you see below. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... #robot_model_type: "differential" robot_model_type: "nav2_amcl::differentialmotionmodel" ... ... #robot_model_type: "differential" robot_model_type: "nav2_amcl::differentialmotionmodel" ... ... #robot_model_type: "differential" robot_model_type: "nav2_amcl::differentialmotionmodel" ... make the robot navigate using the map and ros2 nav2 great, you now have a map, and everything setup so you can make the robot navigate autonomously, while avoiding obstacles. start navigation 2 for the robot lets start from a clean environment  stop everything, close and reopen all terminals. there are a lot of things that can go wrong with rviz and gazebo, so we make sure to reduce the risks. now, start the robot again. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py in another terminal, start the navigation stack, and provide the map as an argument. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=true map:=path/to/my_map.yaml  ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=true map:=path/to/my_map.yaml  ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=true map:=path/to/my_map.yaml note: use use_sim_time only if running with gazebo. for the map argument, provide the path to the yaml file of the map. if you dont see the map on rviz, try finding the map topic options on the left panel, and set to transient local instead of volatile. you might also try to restart everything, and even reboot your computer. now, you should just see the map on the screen, but no robot. youll also see some kinds of error logs in the terminal. this is because nav2 doesnt know where your robot is, and you need to provide the first 2d pose estimate. 2d pose estimate and navigation goals click on the 2d pose estimate button on rviz. then click on the map where the robot is (you should see that on gazebo). maintain the click to also specify the orientation with a green arrow. once youre done, you should see something like that on rviz. finally, you can give navigation commands! click on nav2 goal, then click on the map to select a position + orientation, and the robot should start to go to that pose. you can verify on gazebo, to see that the robot is actually moving. now, you can experiment with different poses. give valid ones, and also invalid ones (ex: a point that cannot be reached). going further with ros2 nav2 in this tutorial you have seen how to get started with the navigation 2 stack. you should now have a better idea of how it works and how to use it. now to go further and really understand how things work, you can continue your learning with the ros2 nav2 course (6 hours of content). in this course youll also: understand how nav2 works behind the hoods, with all components: global/local planner, parameters, tfs, etc. learn how to build your own simulated world in gazebo to be able to use nav2 for your own office/classroom/building. get an intro on how to adapt a custom robot for nav2, with all the steps. program with nav2 directly using python instead of the buttons on rviz. and even more tips and best practices. did you find this tutorial useful? do you want to learn nav2 from scratch? if yes, this course is for you: >> ros2 nav2 course - with slam and navigation << want to learn nav2 from scratch? ros2 nav2 course step by step we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here