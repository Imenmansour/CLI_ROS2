skip to main content on this page why are transforms so important?  coordinate transformations (or transforms) play a huge role in the mathematics of robotics. they are a a mathematical tool to take points or measurements that are represented from one point of view, and represent them in a different point of view that is more useful. without using transformations, we would need to perform the calculations with trigonometry, which quickly becomes very complex with larger problems, and especially in 3d. note this tutorial is all  how ros makes using transformations simple. if you're particularly interested in the more complex and interesting underlying mathematics, i've written (most of) a series of tutorials on them, available here . shown below are two examples of robotic systems where transformations are helpful. in the first, two mobile robots are exploring and one has found an object of interest. how will the other robot know how to get to it? in the second, a mounted camera has spotted a target and a manipulator needs to move the gripper over to it. how do we know the correct motion from the gripper to the target? to solve these problems, we need to first assign coordinate systems, or frames to appropriate components of our system. next, we would need to define transforms between the frames. a transform tells us the translations and rotations required to turn one frame into a different frame, and can be easily reversed to go the other way. if we have a system where every frame is defined by its relationship to one (and only one) other frame, this will create a tree structure , and we will be able to convert a known point in one frame to any other frame in the tree. figuring out all the mathematics and code behind this can be quite tricky, so ros provides us with a whole subsystem just to make working with transforms easier. in this tutorial we'll learn how to set up a transform tree for some example cases. transforms in ros  ros provides a system called tf2 (transform version 2) to handle these transformations for us. any node can use the tf2 libraries to broadcast a transform from one frame to another. as mentioned above, these transforms will need to form a tree structure, where each frame is defined by one (and only one) transform from another frame, but can have any number of frames dependent on it. the picture below shows a portion of a tree that we'll be exploring later. in this tree, base and camera are defined relative to world , and l3 is defined relative to base . any node can also use the tf2 libraries to listen for transforms, and then use the transforms to convert points from any frame to any other frame, as long as they are connected in the tree. when a node broadcasts a particular transform, it can either be static (doesn't change over time), or dynamic (may change over time, but doesn't have to). the reason for this distinction is that robust systems will need to know if their information is out of date, and can flag an error if the broadcaster hasn't updated a dynamic transform for some time. static transforms, on the other hand, can be broadcast once and are assumed to be correct until a new one is broadcast. underneath, the tf2 libraries are still using topics ( /tf and /tf_static ) to handle all this communication, but because we don't actually publish to the topic ourselves, we call it broadcasting and listening instead of publishing and subscribing. if we're writing our own nodes, we can code them to broadcast whatever transforms we like, but most of us starting out aren't ready to write custom nodes or calculate transforms. to help with this, ros comes with some built-in nodes that perform some common broadcasting tasks. broadcasting single frames  the first way is to manually broadcast them using static_transform_publisher . as you might guess, this tool can't broadcast dynamic transforms, only static ones. that might seem a bit useless, but it's very helpful for learning transforms, doing quick tests, and acting as the "glue" in a bigger system (e.g. if two different nodes expect a frame to have different names, or be in slightly different spots). the command below will broadcast a static transform, with the translations and rotations provided, from parent_frame to child_frame . note that the rotations are in radians, and are processed after the translations, in order, with respect to the local coordinate system. ros2 run tf2_ros static_transform_publisher x y z yaw pitch roll parent_frame child_frame as an example, we might want to have a frame robot_1 that is across and up from a world frame, at a 45 (0.785 rad) angle. to do that we'd use the following command: ros2 run tf2_ros static_transform_publisher 2 1 0 0.785 0 0 world robot_1 let's pretend we have a second robot that always sits to the right of our first one (like a sidecar). using a second terminal, we can create another static transform using the command below to create a new frame, robot_2 that sits 1m in the positive x direction of robot_1 . ros2 run tf2_ros static_transform_publisher 1 0 0 0 0 0 robot_1 robot_2 to check if these worked, we'll use the ros visualisation tool, rviz. viewing frames and transforms in rviz  in ros 2, rviz (the ros visualisation tool) is called rviz2 , and is in a package with the same name. so we just need to run: ros2 run rviz2 rviz2 note, you can just run rviz2 directly as a shortcut, rather than using ros2 run . rviz can display all kinds of different data. to display tf data, we click the "add" button in the bottom-left corner, and select "tf". our transforms won't appear just yet, because we haven't told rviz which frame to use as a reference (it defaults to map , which doesn't exist right now). up in the top-left corner we can select world as our fixed frame. the "global status" should become healthy and our two frames should appear, with a line between them to indicate the transform. note that rviz represents the transform as an arrow from child to parent, rather than parent to child as in the introduction and in view_frames below. we can configure the data displayed in rviz using the left panel. for example, we can open up the settings for the tf visualisation and enable displaying frame names. if we go back to our first terminal, and rerun the command with a larger rotation of 90 (1.57 rad), we should see in rviz that the first robot's marker rotates, and the second robot moves too because its frame is defined relative to the first robot. ros2 run tf2_ros static_transform_publisher 2 1 0 1.57 0 0 world robot_1 it's good to play around with this and get a feel for how transforms work. try changing the fixed frame (top-left) to be one of the robots instead of world , adjusting the frames to new positions and rotations, or adding some new ones. we need to make sure to stop all the static_transform_publishers and close rviz before we move to the next part, otherwise they will interfere. broadcasting a moving robot  we've learnt some cool tricks so far, but we're still stuck publishing static frames. we want our robot to move! before we tackle this we need to install a couple of extra packages: sudo apt install ros-foxy-xacro ros-foxy-joint-state-publisher-gui the first step in doing this is to make sure we have a urdf file for our robot. this is a kind of configuration file where we can specify all sorts of physical characteristics of the robot's components, such as their size, shape, colour, and more. there are many tutorials available for writing urdf files, but for now we can use this example file which is for a manipulator similar to the one from the introduction. in urdf, a robot is made up of a series of rigid components called links , and the links are joined together in a parent-child tree structure, where the relationships between different links are called joints . seem familiar? it's not too hard to see how the link/joint pattern is very similar to the frame/transform pattern. because they are so tightly related, there is a ros node called robot_state_publisher which can take in a urdf file and automatically broadcast all the transforms from it. it will also publish the full contents of the urdf file to the topic /robot_description so that any other nodes that need it can all use the same file. in the urdf file each joint can be defined as "fixed", or one of a variety of movable types (e.g. continuous spinning, limited rotation, linear sliding). for the joints that are fixed, robot_state_publisher can just publish a static transform, but for the ones that move it needs an external value (e.g an angle or distance) to calculate the dynamic transform for that point in time. to get these values, it subscribes to a topic called /joint_states , which will contain jointstate messages. these messages can contain information  the position, velocity, or effort of a joint (but for now we will only use position). suddenly our job got a whole lot easier! instead of having to broadcast whole transforms, all we need to do is publish jointstate messages. normally, this data will come from actuator feedback sensors on the robot such as encoders or potentiometers (and in a simulation environment those can be simulated). for now, we will just fake the joint states using a tool called joint_state_publisher_gui . this node will look at the /robot_description topic published by robot_state_publisher , find any joints that can be moved, and display a slider for them. it reads the values from these sliders, and publishes them to /joint_states . let's have a go at running all this. first we'll run robot_state_publisher , which can be a bit confusing when doing it for the first time as passing in the urdf file in is a bit tricky. the urdf is taken on the parameter robot_description , so the command will look something like: ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:=(something here) you might expect the robot_description parameter to be a path to a urdf file, but it actually expects the full content of the urdf file to be passed in at the command line. to achieve this we need to use the xacro software on the urdf to preprocess it, run that inside a subshell ( (...) ), and enclose it in quotes ( "..." ) so that the spaces don't break everything. so our run command will look more like: ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="(xacro path/to/my/xacro/file.urdf.xacro)" tip because it is such a pain to run robot_state_publisher this way, it is generally easiest to create a launch file to do it for us. an example one is available here . then, to publish the joint states, we can run ros2 run joint_state_publisher_gui joint_state_publisher_gui finally, we can launch rviz again, add the tf visualisation, and see our frames move as we adjust the sliders. we can also add a "robotmodel" visualisation in rviz. use the options to select /robot_description as the topic, and a visual representation of the links should appear. note, for the case of a mobile platform, things will get a bit more complicated. robot_state_publisher can broadcast all the transforms within the robot, but you'll need other nodes to publish transforms such as the robot's location within the environment. there are existing nodes to handle this kind of thing, but they'll be covered in later tutorials. under the hood  hopefully the above example worked, but sometimes when we're working with transforms things aren't working properly and we need to figure out why. as mentioned earlier, the transform data is published across two topics, /tf and /tf_static . we can try to listen to these topics directly using ros2 topic echo , but that can sometimes be tricky to interpret. to help, ros comes with a tool (do we need to install tf2_tools ?) called view_frames that lets us visualise the transform tree, along with information  how it is being broadcast. note note, in ros 1 there was a useful tool called rqt_tf_tree which did exactly this but with less hassle. at time of writing, however, this hasn't been ported to ros 2, and so we have to use view_frames instead. the view_frames tool is actually a python script which listens to the transforms for a few seconds, then generates a file called frames.pdf (and also frames.gv ) in whatever directory the terminal was in when the script was executed (for a fresh terminal this will be your home directory). the script is part of the tf2_tools package, so all we need to do is run: ros2 run tf2_tools view_frames.py if we take a look at the resulting file (either opening in a file browser, or from the terminal with atril frames.pdf ), we can see the tree visualised. note that the arrows here are reversed compared to rviz (and are the same as in the introduction). we won't worry too much  the rest of the information displayed for now. tip if you're not familiar with it, the big numbers starting with "16314......" are times, represented in "unix time" which is commonly used in linux systems, and so in robotic platforms. for more info on unix time (a.k.a epoch time) check out the epoch converter . when running simulations, gazebo will generate its own time source, and the numbers will be in seconds since gazebo was started. conclusion  the ros transform system is a powerful tool and we've only just scratched the surface of how we can use it. the details of how we use tf will depend on many factors such as whether our robot is mobile, or a manipulator (or a mobile manipulator), and whether we are running simulations or on physical hardware. in future tutorials we'll look more closely at how tf can be used for particular projects. why are transforms so important? transforms in ros broadcasting single frames viewing frames and transforms in rviz broadcasting a moving robot under the hood conclusion