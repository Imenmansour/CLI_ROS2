how to release a ros 2 binary package  part 3 written by ruben alves  ros2 q&a | ros2 tutorials  10/03/2023 what we are going to learn how to generate a changelog file how to bump the package version how to run a first-time release using bloom list of resources used in this post use the rosject: https://app.theconstructsim.com/l/5562c7f1/ the construct: https://app.theconstructsim.com/ ros2 courses  ros2 basics in 5 days humble (python): https://app.theconstructsim.com/course/132 ros2 basics in 5 days humble (c++) : https://app.theconstructsim.com/course/133 overview this is the third part of a video that shows how to release a ros2 package to the ros build farm using bloom. be sure to check the first and second parts if you havent yet: https://www.theconstruct.ai/how-to-release-a-ros-2-binary-package-part-1-2/ https://www.theconstruct.ai/how-to-release-a-ros-2-binary-package-part-2-2/ here we will explain how to generate a changelog file, bump the package version, and run a first-time release using bloom. acknowledgment this video is based-off on ros2s official documentation, check it out at the link below: https://docs.ros.org/en/humble/how-to-guides/releasing/releasing-a-package.html ros inside! ros inside before anything else, if you want to use the logo above on your own robot or computer, feel free to download it and attach it to your robot. it is really free. find it in the link below: ros inside logo opening the rosject in order to follow this tutorial, we need to have ros2 installed in our system, and ideally a ros2_ws (ros2 workspace). to make your life easier, we have already prepared a rosject with a simulation for that: https://app.theconstructsim.com/l/5562c7f1/ . you can download the rosject on your own computer if you want to work locally, but just by copying the rosject (clicking the link), you will have a setup already prepared for you. after the rosject has been successfully copied to your own area, you should see a run button. just click that button to launch the rosject (below you have a rosject example). how to release a ros 2 binary package  part 3  run rosject (example of the run button) after pressing the run button, you should have the rosject loaded. now, lets head to the next section to get some real practice. what is bloom? bloom is a build automation tool that will guide you through all necessary steps in the process of compiling the source code in the ros build farms, packaging the code into binaries, and uploading them to the debian archive. this way any users can easily install and uninstall it using the debian package tools. what is a build farm? a build farm is a collection of one or more servers, which has been set up to compile computer programs remotely. assumptions in order to follow this tutorial, we assume you have: an existing ros2 package, publicly available for everyone to use git and github basics knowledge you have completed the first part of the post ( https://www.theconstruct.ai/how-to-release-a-ros-2-binary-package-part-1-2/ ): created a release repository started a new release team installed the tools required on our machine created a git access token to authenticate you have completed the second part of the video ( https://www.theconstruct.ai/how-to-release-a-ros-2-binary-package-part-2-2/ ): created a ros/rosdistro source entry recap from part 1: install the tools required on your machine after having opened the rosject, lets start running some commands in the terminal. for that, lets open a terminal by clicking the open a new terminal button. open a new terminal once inside the terminal, lets run the commands below, use apt to install bloom together with the python3-catkin-pkg modules if you havent done so already. sudo apt update sudo apt install python3-bloom python3-catkin-pkg new addition step : since we are using a version of bloom older than 0.6.8 we need to use the v4 index url for releasing: export rosdistro_index_url='https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml' recap from part 2: incorporate feedback if you followed the second part of this video, you created a pull request to add a ros/rosdistro source entry. remember that you have to make the changes requested by the reviewer to get your pull request merged. this part assumes that your pull request has been successfully merged to the ros/rosdistro repository. important : the issues created in part 1 and part 2 must be shown as completed. verify your repository is up to date and your code builds this might seem like an obvious one, but its easy to overlook. ensure you have committed your changes and pushed the last commit to your remote. additionally, confirm your new code builds and executes right before making it available to the build farm. cd ~/ros2_ws/src git clone https://github.com/rfzeg/wall_follower_ros2 cd ~/ros2_ws colcon build; source install/setup.bash important!!! here we cloned the https://github.com/rfzeg/wall_follower_ros2 package. you cannot release the same package from the same url because it has been already released by ros, which means some parts of this tutorial may not work 100% if you close the same repository. to make sure it works, you have to close your own repository instead of the one above. please use the same repository you used in the previous posts of this series, for example. starting the simulation after having opened the rosject and making sure the workspace builds with no problems, lets start a simulation using the same terminal that you have already opened previously. lets run the following commands in order to launch the simulation: source ~/ros2_ws/install/setup.bash source /usr/share/gazebo-11/setup.bash ros2 launch wall_follower_ros2_tests miniworld.launch.py now, in a second terminal , lets make sure our wall follower is working properly: ros2 run wall_follower_ros2 wall_follower_ros2 --ros-args -r scan:=/lidar_1/out if everything went well, you should see the robot moving around, and when it gets close to the wall, it turns and keep moving: wall follower using ros 2 it is always a good idea to verify if there are new changes since the last commit. lets try that in the same second terminal . for that, first press ctrl+c to kill the current process, and then run the commands below: cd ~/ros2_ws/src/wall_follower_ros2 git status when you have added all of the changes to a commit, the git status command line will inform you  nothing to commit, working tree clean  : on branch master your branch is up to date with 'origin/master'. nothing to commit, working tree clean generating the changelog we are now going to generate a changelog. a changelog is a file that contains a condensed list of all important changes made to a project in a chronologically ordered way. its purpose is to communicate to other developers what features have been added, improved, or removed over time. to auto-generate the changelog.rst files, use the " catkin_generate_changelog --all" command. make sure to run this command from inside the home directory where the package files are located: cd ~/ros2_ws/src/wall_follower_ros2 catkin_generate_changelog --all if everything went well, we expect to have the following output: found packages: wall_follower_ros2 querying all tags and commit information... generating changelog files with all versions... - creating './changelog.rst' done. please review the extracted commit messages and consolidate the changelog entries before committing the files! a new changelog.rst file will be automatically created for every package within the repository. the above command will also populate the file with the contents of your commit messages. the above command will generate a changelog.rst file. if we open that file using the code editor, or by typing  cat changelog.rst , we should see something similar to the following, for instance: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ changelog for package wall_follower_ros2 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ forthcoming ----------- * merge pull request `#1 <https://github.com/rfzeg/wall_follower_ros2/issues/1>`_ from rfzeg/master master to main * feat: stop robot when a ctrl+c signal is received * fix safety_distance parameter value * add parameter to reverse ranges array in case it starts with rays at the left side * refactor: rename, reformat and rearrange code * add timer callback to set movement state, fill vel msg, publish vel msg * refactor laser_callback to get the distance reading to the closest object and the ray's position index * rename set_drive_state() -> set_drive_logic_state(), rclcpp_info() -> rclcpp_debug() logs * rename set_velocity() -> determine_vel_msg(), rewrite debug logs * rename package to 'wall_follower_ros2'. set version to 0.0.0 in package.xml * add info & debug log messages * add logical behavoir depending upon 5 zones around the robot, set velocity command * add log info & debug statements * refactor parameter value retrieval * add safety distance parameter * add default parameter values * add minimal rule based obstacle avoidance node (c++) * add initial ros2 package files, readme, license & git configuration * contributors: roberto zegers, roberto zegers r note: the changelog is basically a list of commits. i you want to compare it with your log messages, have a look at the git log history using git log oneline: git log --oneline so, the changelog is basically a list of commits, but you can definitely remove some of the commits in the changelog if you want, however, you must not remove the forthcoming header. again!!! make sure you do not modify the forthcoming header. in this example i reduced the list of changes to only include the most important things as shown below: forthcoming ----------- * add initial version with logical behavoir depending upon 5 zones around the robot * contributors: roberto zegers if you are interested you can consult the following page for additional information: incorporation of changelogs into package source tree commit if you have modified the changelog, then you must commit changelog.rst changes giving it an appropriate commit message such as add changelog. git add changelog.rst git commit -m "add changelog" bump the package version before releasing the package you will also have to increment its version number to a new, unique value because by default its initial version will be  0.0.0, which is the value defined in the package.xml file of our package. to confirm that number, you can run the command below: cat ~/ros2_ws/src/wall_follower_ros2/package.xml | grep version which will output something like this: <version>0.0.0</version> now, in order to automatically bump the package version, we can use the following command, but be aware that the command will ask you for your github credentials . that is why we mentioned previously that you would have to clone your own repository instead of the one we are using in this example ( https://github.com/rfzeg/wall_follower_ros2 ): cd ~/ros2_ws/src/wall_follower_ros2 catkin_prepare_release according to the ros2s documentation, this command performs the following: increases the package version in package.xml. the above command will increment the patch version of the package from its default value of 0.0.0 to 0.0.1. replaces the heading forthcoming with version (date) (eg. 0.0.1 (2022-01-08)) in changelog.rst commits those changes creates a git tag (eg. 0.0.1) to mark this point in the git history pushes the changes and the tag to your remote repository you can show the changes made to the repository like this: git diff head^ head if you want to verify the tag that git just added, run the command below, which will list the available tags in your git repository: git tag sidenote on semantic versioning a semantic version number has three parts delimited by a dot, for instance: 1.2.5 where 1 stands for a major version, 2 represents the minor version and 5 is the patch. lets understand these labels: patch : patch updates are interchangeable, meaning consumers can upgrade or downgrade freely. example: bug fix, performance improvement, or internal tweaks. minor : minor updates are backward compatible, meaning consumers can upgrade freely. for instance new additional api methods, without changing the current methods. major : major updates are non-compatible, meaning consumers can not upgrade without changing the software that uses the api, where applicable. you normally have interface changes breaking backward compatibility, like changes in an api endpoint name or signature, removal of an endpoint, etc. to increment the major version, for instance in the first major release, run: catkin_prepare_release --bump major similarly, the minor version gets incremented when you execute: catkin_prepare_release --bump minor run the bloom-release command run the following command, the <my_repository> should be replaced with the name of your repository: bloom-release new-track rosdistro humble track humble <my_repository> note that <my_repository> is not an url, but the repository reference in distribution.yaml. in this particular example, the command to be executed is: bloom-release --new-track --rosdistro humble --track humble wall_follower_ros2 the above command will create a release for ros2 humble. lets have a quick breakdown of the flags we used: new-track is important for a first-time release to create a new track before running bloom. what is a track? bloom is designed to allow the release of the same package for different ros distributions and versions in the same release repository. to facilitate this, bloom uses release tracks to maintain configurations for different release processes. rosdistro humble indicates that this release is for the humble distro. replace as appropriate. track humble indicates that you want the track name to be humble note : for later releases, you dont need the --new-track flag. however, if you want to add a new distribution to an already released package (see documentation) and configure it, you will have to include the --new-track option again. once executed, it will look at the distributions.yaml file for your project key. if it doesnt find it, itll look in other distributions. if it finds one, itll prompt you to approve it. if not, you will be asked to enter a release repository url: looking for a release of this repository in a different distribution in this particular example, we have to add the following. note that you should replace this with the name of your repository . again !!! note that you should replace this with the name of your repository. our ros2-gbp release repository is at: https://github.com/ros2-gbp/wall_follower_ros2-release.git what follows are prompts that are meant to configure the new release track. configure the new release track you will be asked to enter some basic information required to configure a new track. in the example shown we should respond to the prompts as follows: repository name: the name of the repository in which the package is: wall_follower_ros2 upstream repository uri: our repository is hosted on github at https://github.com/rfzeg/wall_follower_ros2 , but please remember to insert the url of your own repository upstream vcs type: [enter] version: [enter] release tag: [enter] upstream devel branch: master ros distro: [enter] patches directory: [enter] release repository push url: [enter] the whole process will take a while because it runs quite a few commands, for instance: ==> git-bloom-release humble ==> bloom-export-upstream ==> git-bloom-import-upstream ==> git-bloom-generate -y rosrelease humble --source upstream -i 1 ==> git-bloom-generate -y rosdebian --prefix release/humble humble -i 1--os-name ubuntu it will also check if all dependencies can be satisfied by running rosdep update : running rosdep update to release a ros2 binary package you should continue to see lots of dumping messages/logs on the terminal: ==> git-bloom-generate -y rosdebian --prefix release/humble humble -i 1--os-name debian --os-not-required ==> git-bloom-generate -y rosrpm --prefix release/humble humble -i 1 --os-name fedora ==> git-bloom-generate -y rosrpm --prefix release/humble humble -i 1 --os-name rhel <== released 'wall_follower_ros2' using release track 'humble' successfully then you will be asked if you want to push to the release repository. just type y and [enter] to pass this prompt: releasing complete, push to release repository? continue [y/n]? y the script will continue its execution: ==> git push --tags we dont have documentation information, and thats okay: would you like to add documentation information for this repository? [y/n]? n you might encounter a prompt message like this one: enter an access token prompt go to http://github.com/settings/tokens to create a token if you havent done it so far. this token will be saved in the bloom config file in your local machine:  /home/user/.config/bloom  then, finally, you will be asked to confirm the creation of a pull request: open a pull request prompt a few more commands will be run: ==> pulling latest rosdistro branch ==> writing new distribution file: humble/distribution.yaml ==> git add humble/distribution.yaml ==> pushing changes to fork at the very end of the process, you should see a message similar to this: <== pull request opened at: https://github.com/ros/rosdistro/pull/xxxxx in our case, the pull request url was the following: https://github.com/ros/rosdistro/pull/36080 note : the release process begins recording logs as soon as you run it. bloom log files are saved in your local machine to this directory: '/home/user/.bloom_logs' the pull request page click on that link and you will see the current status of your pull request: ros rosdistro pull request on github now you will have to wait for someone from the ros release team to review/merge the pull request. this can take some time, so you may have to wait a bit. if required you will have to update the pr to address the comments. that is all for todays post. congratulations. you just learned the third part of how to publish your ros 2 binary package. we hope this post was really helpful to you. if you want a live version of this post with more details , please check the video in the next section. youtube video so this is the post for today. remember that we have the live version of this post on youtube. if you liked the content, please consider subscribing to our youtube channel. we are publishing new content ~every day. keep pushing your ros learning. related courses & training if you want to learn more  ros and ros2, we recommend the following courses: ros2 basics in 5 days humble (python): https://app.theconstructsim.com/course/132 ros2 basics in 5 days humble (c++) : https://app.theconstructsim.com/course/133 open-rmf / fleet management training : https://www.theconstruct.ai/robot-fleet-management-ros2-open-rmf-training/ get ros2 industrial ready- hands-on training by the construct cover.png topics: binary | bloom | ros | ros2 check out these related posts how to become a robotics developer may 26, 2018 updated: july 26, 2023 robotics needs developers! robotics needs software engineers and software... read more 130. the open source robotics alliance apr 8, 2024 i would like to dedicate this episode to all the ros developers out there who are thinking and... read more 129. ros2ai jan 29, 2024 i would like to dedicate this episode to all the ros developers who believe that chatgpt or... read more  older entries 0 comments submit a comment cancel reply your email address will not be published. comment name email website save my name, email, and website in this browser for the next time i comment. submit comment δ this site uses akismet to reduce spam. learn how your comment data is processed . pin it on pinterest share this twitter linkedin reddit facebook gmail