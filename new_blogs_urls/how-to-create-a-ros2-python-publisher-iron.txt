skip to content in this tutorial, we will go over how to create a python publisher for ros 2. in ros 2 (robot operating system 2), a python publisher is a program or script (written in python) that sends messages across the ros network to other parts of the system. the official instructions for creating a publisher are here , but i will walk you through the entire process, step by step. we will be following the ros 2 python style guide . lets get started! table of contents toggle prerequisites you have created a ros 2 workspace . you have created a ros 2 package. you have visual studio code installed . code is stored here on github . directions open a terminal, and type these commands to open vs code. cd ~/ros2_ws code . you can close any pop ups that appear. lets set our default indentation to 4 spaces. here are the steps to set a default 4-space indentation in vs code: 1. access settings: using the menu: go to file > preferences > settings (or press ctrl+, on windows/linux or cmd+, on macos). 2. modify settings: search for indentation in the settings panel. change the following values: editor: tab size: set this to 4 to control the width of a tab character. editor: insert spaces: set this to true to ensure that pressing tab inserts spaces instead of a literal tab character. (optional) editor: detect indentation: set this to false if you want to prevent vs code from automatically adjusting indentation based on existing code. 3. apply changes: the changes should take effect immediately. you can test by opening a file and pressing tab to see if it inserts 4 spaces. write the code right-click on src/cobot_arm_examples , and type scripts to create a new folder for our python script. right-click on the scripts folder to create a new file called  minimal_py_publisher.py . type the following code inside minimal_py_publisher.py : #! /usr/bin/env python3 """ description: this ros 2 node periodically publishes "hello world" messages on a topic. it demonstrates basic ros concepts such as node creation, publishing, and timer usage. ------- publishing topics: the channel containing the "hello world" messages /topic - std_msgs/string ------- subscription topics: none ------- author: addison sears-collins date: january 31, 2024 """ import rclpy # import the ros 2 client library for python from rclpy.node import node # import the node class for creating ros 2 nodes from std_msgs.msg import string # import the string message type for publishing class minimalpublisher(node): """create minimalpublisher node. """ def __init__(self): """ create a custom node class for publishing messages """ # initialize the node with a name super().__init__('minimal_publisher') # creates a publisher on the topic "topic" with a queue size of 10 messages self.publisher_1 = self.create_publisher(string, '/topic', 10) # create a timer with a period of 0.5 seconds to trigger the callback function timer_period = 0.5 # seconds self.timer = self.create_timer(timer_period, self.timer_callback) # initialize a counter variable for message content self.i = 0 def timer_callback(self): """callback function executed periodically by the timer. """ # create a new string message object msg = string() # set the message data with a counter msg.data = 'hello world: %d' % self.i # publish the message on the topic self.publisher_1.publish(msg) # log a message indicating that the message has been published self.get_logger().info('publishing: "%s"' % msg.data) # increment the counter for the next message self.i = self.i + 1 def main(args=none): """main function to start the ros 2 node. args: args (list, optional): command-line arguments. defaults to none. """ # initialize ros 2 communication rclpy.init(args=args) # create an instance of the minimalpublisher node minimal_publisher = minimalpublisher() # keep the node running and processing events. rclpy.spin(minimal_publisher) # destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_publisher.destroy_node() # shutdown ros 2 communication rclpy.shutdown() if __name__ == '__main__': # execute the main function if the script is run directly main() to generate the comments for each class and function, you follow these steps for the autodocstring package . what we are going to do in this node is publish the string hello world to a topic named /topic . the string message will also contain a counter that keeps track of how many times the message has been published. we chose the name /topic for the topic, but you could have chosen any name. configure the package create the __init__.py file now, we need to configure our package so that ros 2 can discover this python node we just created. right-click on src/cobot_arm_examples, and create a folder that has the same name as the package. this folder is required in order to run python scripts. ros 2s build system, ament, relies on this structure to correctly locate and build python modules within a package. the folder with the same name as the package serves as the root for python code, allowing ament to accurately generate and install the packages python modules. now right-click on the name of this folder, and create an empty script called __init__.py . here is what the file should look like: # required to import python modules the presence of _ _init_ _.py explicitly designates a directory as a python package. this enables pythons import machinery to recognize and treat it as a cohesive collection of modules. create a readme.md now lets create a readme.md file. right-click on the name of the package, and name the file readme.md . a readme.md file is a plain text file that serves as an introduction and explanation for a project, software, or package. its like a welcome mat for anyone encountering your work, providing essential information and guidance to get them started. you can find a syntax guide on how to write a readme.md file here on github . # cobot_arm_examples this package provides some basic examples to get you started with ros 2 manipulation. to see what the readme.md file looks like, you can right-click on readme.md on the left pane and click open preview. modify the package.xml file now lets open the package.xml file. make sure it looks like this. <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> <package format="3"> <name>cobot_arm_examples</name> <version>0.0.0</version> <description>basic examples demonstrating ros 2</description> <maintainer email="automaticaddison@example.com">addison sears-collins</maintainer> <license>apache-2.0</license> <!--specify build tools that are needed to compile the package--> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>ament_cmake_python</buildtool_depend> <!--declares package dependencies that are required for building the package--> <depend>rclcpp</depend> <depend>rclpy</depend> <depend>std_msgs</depend> <!--specifies dependencies that are only needed for testing the package--> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> the package.xml file is an important part of any ros 2 package. it serves as the packages manifest, holding essential metadata that ros 2 tools use to build, install, and manage the package. heres a breakdown of the key elements youll find in a typical package.xml file: 1. basic information: name: the unique identifier for the package, often corresponding to the folder name. version: the packages semantic version, indicating its maturity and compatibility. description: a brief explanation of the packages purpose and functionality. 2. dependencies: build_depend: packages and libraries required for building the current package. buildtool_depend: build tools (like compilers) needed for building the package. run_depend: packages and libraries required for running the packages executables. 3. build configuration: build_type: specifies the build system (e.g., cmake, catkin). export: defines properties and settings used during package installation. 4. maintainers and license: maintainer: information  the packages primary developers and maintainers. license: the license under which the package is released (e.g., apache 2.0). modify the cmakelists.txt file now lets configure the cmakelists.txt file. a cmakelists.txt file in ros 2 defines how a ros 2 package should be built. it contains instructions for building and linking the packages executables, libraries, and other artifacts. cmake_minimum_required(version 3.8) project(cobot_arm_examples) # check if the compiler being used is gnu's c++ compiler (g++) or clang. # add compiler flags for all targets that will be defined later in the # cmakelists file. these flags enable extra warnings to help catch # potential issues in the code. # add options to the compilation process if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() # locate and configure packages required by the project. find_package(ament_cmake required) find_package(ament_cmake_python required) find_package(rclcpp required) find_package(rclpy required) find_package(std_msgs required) # define a cmake variable named dependencies that lists all # ros 2 packages and other dependencies the project requires. set(dependencies rclcpp std_msgs ) # add the specified directories to the list of paths that the compiler # uses to search for header files. this is important for c++ # projects where you have custom header files that are not located # in the standard system include paths. include_directories( include ) # tells cmake to create an executable target named minimal_cpp_publisher # from the source file src/minimal_cpp_publisher.cpp. also make sure cmake # knows  the program's dependencies. add_executable(minimal_cpp_publisher src/minimal_cpp_publisher.cpp) ament_target_dependencies(minimal_cpp_publisher {dependencies}) add_executable(minimal_cpp_subscriber src/minimal_cpp_subscriber.cpp) ament_target_dependencies(minimal_cpp_subscriber {dependencies}) # copy necessary files to designated locations in the project install ( directory cobot_arm_examples scripts destination share/{project_name} ) install( directory include/ destination include ) # install cpp executables install( targets minimal_cpp_publisher minimal_cpp_subscriber destination lib/{project_name} ) # install python modules for import ament_python_install_package({project_name}) # install python executables install( programs scripts/minimal_py_publisher.py scripts/minimal_py_subscriber.py #scripts/example3.py #scripts/example4.py #scripts/example5.py #scripts/example6.py #scripts/example7.py destination lib/{project_name} ) # automates the process of setting up linting for the package, which # is the process of running tools that analyze the code for potential # errors, style issues, and other discrepancies that do not adhere to # specified coding standards or best practices. if(build_testing) find_package(ament_lint_auto required) # the following line skips the linter which checks for s # comment the line when a  and license is added to all source files set(ament_cmake__found true) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a  and license is added to all source files set(ament_cmake_cpplint_found true) ament_lint_auto_find_test_dependencies() endif() # used to export include directories of a package so that they can be easily # included by other packages that depend on this package. ament_export_include_directories(include) # generate and install all the necessary cmake and environment hooks that # allow other packages to find and use this package. ament_package() the standard sections of a cmakelists.txt file for ros 2 are as follows: 1. cmake_minimum_required: cmake_minimum_required(version 3.5) specifies the minimum required version of cmake for building the package. this is typically set to a version that is known to be compatible with ros 2. 2. project: project(my_package) specifies the name of the project (ros 2 package). this sets up various project-related variables and settings. 3. find_package: find_package(ament_cmake required) finds and loads the necessary dependencies for the ros 2 package. `ament_cmake` is a key package used in ros 2 build systems. 4. ament_package: ament_package() configures the package to use the appropriate ros 2 build and install infrastructure. this line should be present at the end of the `cmakelists.txt` file. 5. add_executable or add_library: add_executable(my_node src/my_node.cpp) defines an executable or a library to be built. this command specifies the source files associated with the target. 6. ament_target_dependencies: ament_target_dependencies(my_node rclcpp) declares the dependencies for a target (executable or library). in this example, `my_node` depends on the `rclcpp` library. 7. install: install(targets my_node destination lib/{project_name}) specifies the installation rules for the built artifacts. it defines where the executable or library should be installed. 8. ament_export_dependencies: ament_export_dependencies(ament_cmake) exports the dependencies of the package. this is used to inform downstream packages  the dependencies of the current package. 9. ament_export_include_directories: ament_export_include_directories(include) exports the include directories of the package. this is used to inform downstream packages  the include directories. 10. ament_export_libraries: ament_export_libraries(my_library) exports the libraries of the package. this is used to inform downstream packages  the libraries. 11. ament_package_config_dependency: ament_package_config_dependency(rclcpp) declares a dependency on another package for the purpose of package configuration. this is used when configuring the package for building against other packages. these sections collectively define the build process, dependencies, and installation rules for a ros 2 package. the specific content within each section will vary depending on the packages requirements and structure. build the workspace now that we have created our script and configured our build files, we need to build everything into executables so that we can run our code. open a new terminal window, and type the following commands: cd ~/ros2_ws/ colcon build source ~/.bashrc run the node in this section, we will finally run our node. heres the general syntax for running a node: ros2 run <package_name> <python_script_name>.py heres a breakdown of the components: <package_name>: replace this with the name of your ros 2 package containing the python script. <python_script_name>.py: replace this with the name of your python script file that contains the ros 2 node. note that, you can use the tab button to autocomplete a partial command. for example, type the following and then press the tab button on your keyboard. ros2 run cobot_arm_examples min after autocompletion, the command looks like this: ros2 run cobot_arm_examples minimal_py_publisher.py now, press enter. here is what the output looks like: open a new terminal window. lets see a list of all currently active topics. ros2 topic list we see we have three active topics: /parameter_events /rosout /topic /parameter_events and /rosout topics appear even when no nodes are actively running due to the presence of system-level components and the underlying architecture of the ros 2 middleware. the /parameter_events topic facilitates communication  parameter changes, and the /rosout topic provides a centralized way to access log messages generated by different nodes within the ros 2 network. /topic is the topic we created with our python node. lets see what data is being published to this topic. ros2 topic echo /topic you can see the string message that is being published to this topic, including the counter integer we created in the python script. press ctrl + c in the terminal to stop the output. at what frequency is data being published to this topic? ros2 topic hz /topic data is being published at 2hz, or every 0.5 seconds. press ctrl + c in the terminal to stop the output. what type of data is being published to this topic, and how many nodes are publishing to this topic? ros2 topic info /topic to get more detailed information  the topic, you could have typed: ros2 topic info /topic --verbose what are the currently active nodes? ros2 node list lets find out some more information  our node. ros2 node info /minimal_publisher close the node now go back to the terminal where your minimal_py_publisher.py script is running and press ctrl + c to stop its execution. to clear the terminal window, type: clear congratulations! you have written your first publisher in ros 2. in this example, you have written a publisher to publish a basic string message. on a real robot, you will write many different publishers that publish data that gets shared by the different components of a robot: strings, lidar scan readings, ultrasonic sensor readings, camera frames, 3d point cloud data, integers, float values, battery voltage readings, odometry data, and much more. the code you wrote serves as a template for creating these more complex publishers. all publishers in ros 2 are based on the basic framework as minimal_py_publisher.py. thats it. keep building!