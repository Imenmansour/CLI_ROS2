skip to content in this tutorial i will show you how to create a map for the nav2 stack, using the ros2 slam_toolbox package. we are going to use a simulation of a robot, the turtlebot3, but all the steps that are related to slam can be replicated for any other robot, as long as you have a lidar sensor publishing on a /scan topic. also i will use ros2 humble on ubuntu 22.04 for this tutorial. >> here is a video version of this tutorial, as an additional resource: after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! you are learning navigation 2 with ros2? check out this ros2 nav2 course, and learn step by step, from scratch. table of contents toggle setup for ros2 slam_toolbox ros2 installation first of all, make sure that ros2 is correctly installed on your computer, and that you have sourced the environment  with a line like source /opt/ros/humble/setup.bash in your .bashrc for example. dds configuration to use the nav2 stack and slam_toolbox correctly, we will need to change the dds implementation used by ros2. dont worry too much, the setup will be super simple. the thing is, as you may know, ros2 is based on dds for the middleware. there are different dds implementations, the default one (as for now) being fast dds. due to some issues with fast dds and navigation in ros2, it has been recommended to use cyclone dds instead. so, we need to tell ros2 to use a different dds. to do that, first install cyclone dds with apt. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-rmw-cyclonedds-cpp  sudo apt install ros-humble-rmw-cyclonedds-cpp  sudo apt install ros-humble-rmw-cyclonedds-cpp now that cyclone dds is installed, we need to tell ros2 to use it instead of the default dds. to do this, you just need to export one environment variable named rmw_implementation, that we will add into our .bashrc. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... export rmw_implementation=rmw_cyclonedds_cpp source /opt/ros/humble/setup.bash ... export rmw_implementation=rmw_cyclonedds_cpp source /opt/ros/humble/setup.bash ... export rmw_implementation=rmw_cyclonedds_cpp source /opt/ros/humble/setup.bash and thats it! now, just open a new terminal/session, or source the .bashrc, and cyclone dds will be used. install nav2 and slam_toolbox first, lets install the navigation 2 packages. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup  sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup we will also install the turtlebot3 packages as well use this robot as an example. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-turtlebot3*  sudo apt install ros-humble-turtlebot3*  sudo apt install ros-humble-turtlebot3* once you have this, lets install the ros2 slam_toolbox package. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  sudo apt install ros-humble-slam-toolbox  sudo apt install ros-humble-slam-toolbox  sudo apt install ros-humble-slam-toolbox everything is now correctly installed and setup. start the ros2 stack for your robot now you can start your robot. in this tutorial i will use turtlebot3. you can follow along with this example, and then youll have to use your own robot stack here. note that adapting a robot to the navigation 2 stack is not something trivial, and im not going to talk  this here, as it could fit an entire course. so, when you want to use your own robot, make sure that you can start the robot, control it (with keyboard, joystick, ), and have a laserscan message published on a /scan topic. those are the main requirements for slam_toolbox to work. now, back to the turtlebot3. start the robot to start the turtlebot3 stack, we first need to export an environment variable to specify which version we want to launch (burger, waffle, waffle pi). well use the waffle version. run this command, or simply add it somewhere at the end of your .bashrc: export turtlebot3_model=waffle export turtlebot3_model=waffle . now, if youve just added the environment variable, make sure to either source the .bashrc or open a new terminal. as i will do this tutorial without a real robot, i will use a gazebo simulation of the robot. lets start this simulation. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py making sure there is a /scan topic if we list the topics: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 topic list /camera/camera_info /camera/image_raw /clock /cmd_vel /imu /joint_states /odom /parameter_events /performance_metrics /robot_description /rosout /scan /tf /tf_static  ros2 topic list /camera/camera_info /camera/image_raw /clock /cmd_vel /imu /joint_states /odom /parameter_events /performance_metrics /robot_description /rosout /scan /tf /tf_static  ros2 topic list /camera/camera_info /camera/image_raw /clock /cmd_vel /imu /joint_states /odom /parameter_events /performance_metrics /robot_description /rosout /scan /tf /tf_static as you can see, we have a /scan topic. and if we check the type: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 topic info /scan type: sensor_msgs/msg/laserscan publisher count: 1 subscription count: 0  ros2 topic info /scan type: sensor_msgs/msg/laserscan publisher count: 1 subscription count: 0  ros2 topic info /scan type: sensor_msgs/msg/laserscan publisher count: 1 subscription count: 0 great, we found the laserscan message type from the sensor_msgs packages. with this, we know that our robot is correctly configured for slam_toolbox. start nav2 and ros2 slam_toolbox for this we will need 4 terminals. in the first terminal you have already started the ros2 stack for your robot. using the turtlebot3 example: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py  ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py in a 2nd terminal, start the navigation 2 stack. note: if you are using gazebo, add use_sim_time:=true to use the gazebo time. if using the real robot, skip this argument. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch nav2_bringup navigation_launch.py use_sim_time:=true  ros2 launch nav2_bringup navigation_launch.py use_sim_time:=true  ros2 launch nav2_bringup navigation_launch.py use_sim_time:=true in the 3rd terminal, start the slam_toolbox. note: same as previously, if using gazebo, add the argument to use the simulation time. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch slam_toolbox online_async_launch.py use_sim_time:=true  ros2 launch slam_toolbox online_async_launch.py use_sim_time:=true  ros2 launch slam_toolbox online_async_launch.py use_sim_time:=true everything is launched correctly. now, all you see is a bunch of logs in different terminals. in the 4th terminal we will start rviz, so that you can visualize whats going on. to make it easier, we can start with an already existing rviz configuration for nav2. otherwise youd start with nothing and youd have to configure everything by yourself. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run rviz2 rviz2 -d /opt/ros/humble/share/nav2_bringup/rviz/nav2_default_view.rviz  ros2 run rviz2 rviz2 -d /opt/ros/humble/share/nav2_bringup/rviz/nav2_default_view.rviz  ros2 run rviz2 rviz2 -d /opt/ros/humble/share/nav2_bringup/rviz/nav2_default_view.rviz with this, you should see a window like that. as you can see on the left menu, a lot of stuff is already configured: tf, laserscan, amcl, global and local planner, etc. to get a better view for slam, ill uncheck the global planner and the controller (local planner). generate a map with slam_toolbox as you can see on the previous screenshot, we have 3 possible colors for any pixel in the map: white: free space. black: obstacle. grey: unknown. now all we need to do is to make the robot move in the map, so that the grey (unknown) pixels will turn white or black. when we have a result that satisfies us, we can save the map. make the robot move around so, you need to start the node to move your robot, either with a keyboard, joystick, etc. this can also be a node to make the robot explore on its own. basically, anything that will make the robot move around. i will open another terminal (5th one). to make the turtlebot3 move using the keyboard: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard  ros2 run turtlebot3_teleop teleop_keyboard now make the robot move around. heres the map that i got after 20-30 seconds: as you can see, all the free space is in white. for some of the obstacles in the middle/right, however, the shape of the circles is not complete  some black pixels are missing. i could make the robot move everywhere to be sure all pixels are covered, but a result like this should not be a problem when using this map for navigation. you dont necessarily need to clear 100% of the pixels to get a good result. save the map once you get a good enough looking map, you can save it. and before you save the map, make sure you dont stop any of the first 4 terminals, otherwise youd have to start everything again! (however you can stop the 5th terminal, in which you made the robot move.) to save the map: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run nav2_map_server map_saver_cli -f my_map  ros2 run nav2_map_server map_saver_cli -f my_map  ros2 run nav2_map_server map_saver_cli -f my_map you can provide an optional -f option to specify the path/name of the map. make sure you dont put any extension here, this will be done automatically. when you run the command, youll see some logs in white and yellow. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run nav2_map_server map_saver_cli -f my_map [info] [1683279024. 448150393 ] [map_saver]: map_saver lifecycle node launched. waiting on external lifecycle transitions to activate see https://design.ros2.org/articles/node_lifecycle.html for more information. [info] [1683279024. 448733586 ] [map_saver]: creating [info] [1683279024. 449738718 ] [map_saver]: configuring [info] [1683279024. 462418532 ] [map_saver]: saving map from 'map' topic to 'my_map' file [warn] [1683279024. 462503523 ] [map_saver]: free threshold unspecified. setting it to default value: 0. 250000 [warn] [1683279024. 462927136 ] [map_saver]: occupied threshold unspecified. setting it to default value: 0. 650000 [warn] [map_io]: image format unspecified. setting it to: pgm [info] [map_io]: received a 112 x 103 map @ 0. 05 m/pix [info] [map_io]: writing map occupancy data to my_map.pgm [info] [map_io]: writing map metadata to my_map.yaml [info] [map_io]: map saved [info] [1683279024. 596177677 ] [map_saver]: map saved successfully [info] [1683279024. 602026082 ] [map_saver]: destroying  ros2 run nav2_map_server map_saver_cli -f my_map [info] [1683279024.448150393] [map_saver]: map_saver lifecycle node launched. waiting on external lifecycle transitions to activate see https://design.ros2.org/articles/node_lifecycle.html for more information. [info] [1683279024.448733586] [map_saver]: creating [info] [1683279024.449738718] [map_saver]: configuring [info] [1683279024.462418532] [map_saver]: saving map from 'map' topic to 'my_map' file [warn] [1683279024.462503523] [map_saver]: free threshold unspecified. setting it to default value: 0.250000 [warn] [1683279024.462927136] [map_saver]: occupied threshold unspecified. setting it to default value: 0.650000 [warn] [map_io]: image format unspecified. setting it to: pgm [info] [map_io]: received a 112 x 103 map @ 0.05 m/pix [info] [map_io]: writing map occupancy data to my_map.pgm [info] [map_io]: writing map metadata to my_map.yaml [info] [map_io]: map saved [info] [1683279024.596177677] [map_saver]: map saved successfully [info] [1683279024.602026082] [map_saver]: destroying  ros2 run nav2_map_server map_saver_cli -f my_map [info] [1683279024.448150393] [map_saver]: map_saver lifecycle node launched. waiting on external lifecycle transitions to activate see https://design.ros2.org/articles/node_lifecycle.html for more information. [info] [1683279024.448733586] [map_saver]: creating [info] [1683279024.449738718] [map_saver]: configuring [info] [1683279024.462418532] [map_saver]: saving map from 'map' topic to 'my_map' file [warn] [1683279024.462503523] [map_saver]: free threshold unspecified. setting it to default value: 0.250000 [warn] [1683279024.462927136] [map_saver]: occupied threshold unspecified. setting it to default value: 0.650000 [warn] [map_io]: image format unspecified. setting it to: pgm [info] [map_io]: received a 112 x 103 map @ 0.05 m/pix [info] [map_io]: writing map occupancy data to my_map.pgm [info] [map_io]: writing map metadata to my_map.yaml [info] [map_io]: map saved [info] [1683279024.596177677] [map_saver]: map saved successfully [info] [1683279024.602026082] [map_saver]: destroying if you have something that looks like that, all good! if you have some error logs in red however, i suggest you try to run the command a few more times. now, you should have 2 new files: my_map.yaml: this file contains the metadata for the map, as well as the path to the image file. my_map.pgm: this is the image file with white, black and grey pixels, representing the free, occupied, and unknown space. next steps with the generated map great, you have now successfully generated a map with the ros2 slam_toolbox package. this package is usually working quite well and is quite fast to generate the map (compared to other packages such as cartographer). the next steps for you are: use the generated map with navigation 2, to give navigation goals and make the robot move autonomously while avoiding obstacles. if you have a custom robot, adapt the robot for nav2, so that you can use it with slam_toolbox. did you find this tutorial useful? do you want to learn nav2 from scratch? if yes, this course is for you: >> ros2 nav2 course - with slam and navigation << want to learn nav2 from scratch? ros2 nav2 course step by step we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here