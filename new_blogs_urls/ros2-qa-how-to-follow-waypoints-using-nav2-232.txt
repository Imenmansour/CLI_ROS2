[ros2 q&a] how to follow waypoints using nav2 #232 written by ruben alves  ros q&a | ros2 q&a | ros2 tutorials  16/06/2023 what we are going to learn how to launch a functional nav2 system how to use nav2 simple commander api how to launch nav2 waypoint follower module list of resources used in this post use the rosject: https://app.theconstructsim.com/l/4da61f89/ the construct: https://app.theconstructsim.com/ nav2 simple commander api: https://github.com/ros-planning/navigation2/tree/main/nav2_simple_commander https://navigation.ros.org/commander_api/index.html ros2 courses  ros2 basics in 5 days humble (python): https://app.theconstructsim.com/course/132 ros2 basics in 5 days humble (c++) : https://app.theconstructsim.com/course/133 overview in this post, well be learning how to use nav2 simple command api to write a program that makes your program follow waypoints. what we are going to create is something like a patroling system, in which the robot patrols a given area. ros inside! ros inside before anything else, if you want to use the logo above on your own robot or computer, feel free to download it and attach it to your robot. it is really free. find it in the link below: ros inside logo opening the rosject in order to follow this tutorial, we need to have ros2 installed in our system, and ideally a ros2_ws (ros2 workspace). to make your life easier, we have already prepared a rosject with a simulation for that: https://app.theconstructsim.com/l/4da61f89/ . you can download the rosject on your own computer if you want to work locally, but just by copying the rosject (clicking the link), you will have a setup already prepared for you. after the rosject has been successfully copied to your own area, you should see a run button. just click that button to launch the rosject (below you have a rosject example). how to follow waypoints using nav2  run rosject (example of the run button) after pressing the run button, you should have the rosject loaded. now, lets head to the next section to get some real practice. launching the simulation as you may imagine, instead of using a real robot, we are going to use a simulation. the simulation package we are using, neo_simulation2 (by neobotix) , comes along with all the new ros 2 features. like its predecessor, the neo_simulation2 package is fully equipped with all the neobotix robots that are available in the market. by the way, neobotix is a state-of-the manufacturer of mobile robots and robot systems. we offer robots and manipulators for all applications with full ros support. neobotix products range from small mobile robots to mobile robot arms and several omnidirectional robots. they are specialized in deg customized mobile robots to meet your unique requirements. combining the novelty of ros 2 and the state-of-the-art neobotix platforms would allow users to learn and develop various reliable and robust application that caters to their needs in both research and as well as in industries. alright, having opened the rosject and explained a little bit  neobotix, lets start running some commands in the terminal. for that, lets open a terminal by clicking the open a new terminal button. open a new terminal once inside the first terminal , lets run the commands below, to launch a simulation cd ros2_ws source install/setup.bash ros2 launch neo_simulation2 simulation.launch.py there will be countless red error messages on this simulation terminal. lets just ignore those messages for now. if you want to know a bit more  neobotix robots, they offer: omnidirectional robots: neo_mpo_700 : https://www.neobotix-robots.com/products/mobile-robots/mobile-robot-mpo-700 neo_mpo_500 : https://www.neobotix-robots.com/products/mobile-robots/mobile-robot-mpo-500 differential robots: neo_mp_500 : https://www.neobotix-robots.com/products/mobile-robots/mobile-robot-mp-500 neo_mp_400 : https://www.neobotix-robots.com/products/mobile-robots/mobile-robot-mp-400 ros2 navigation in order to move the robot to a desired goal location, pre-defined controllers and planners are available to be readily used. thanks to navigation 2, the all-new ros-2 navigation stack, provides us with localization, global planning, and local planning algorithms, that allow us to jump-start by testing our intended application on the robot real-quick. almost all the algorithms found in move_base (ros-1 navigation stack) are available in navigation2. all the neobotix robots in the simulation for ros-2 are primed and ready with navigation2. once the simulation is started (seen in the previous tutorial), ros-2 navigation stack can be launched using the following command now, in a second terminal, we can launch the localization server using the following command: ros2 launch localization_server localization.launch.py and in a third terminal , we can launch the path planner server: ros2 launch path_planner_server pathplanner.launch.py the commands above should have launched the simulation, localization server, and path planner server. after some seconds, we should have gazebo (simulation), rviz (robot visualization), and teleop running now. the simulation should be similar to the following: simulation  how to follow waypoints using nav2 if the gazebo simulation doesnt pop up: please open the gazebo from the below menu bar rviz would have been loaded as well and can be found in the graphical tool s also, another terminal would have popped out in the graphical tools for the teleoperation . please follow the instruction given in that terminal for moving the robot. to make sure everything is working so far, you can send a 2d navgoal in rviz to make sure the navigation system is working. the files used to launch the localization server and path planner are found on the following paths: ls ~/ros2_ws/src/neobotix_mp_400_navigation/localization_server/launch/localization.launch.py ls ~/ros2_ws/src/neobotix_mp_400_navigation/path_planner_server/launch/pathplanner.launch.py these files can also be seen in the code editor: localization server and path planner  how to follow waypoints using nav2 feel free to localize and send goals to the robot as shown in this video  ros2 navigation for omnidirectional robots: global costmap and local costmap in rviz assuming you have rviz running, you can add global and local costmaps to it. for that, click the add button on the bottom left side of rviz, then add by topic , then select global costmap : add by topic  global costmap  how to follow waypoints using nav2 to add local costmap, click the add button on the bottom left side of rviz, then add by topic , then select the map under local costmap : add by topic  local costmap  how to follow waypoints using nav2 assuming everything went well so far, now we are going to test the waypoint follower. waypoint follower if you forked the rosject (clicking on the link we provided to you earlier), you should have a package named follow_waypoints on your ros2_ws/src folder already, but for documentation purposes, and in case you want to know the baby steps, here is how we created that package. first, in a fourth terminal we created that package: cd ~/ros2_ws/src ros2 pkg create --build-type ament_python follow_waypoints by listing the content of that ~/ros2_ws/src folder, we see that the package has been created: ls # follow_waypoints neo_local_planner2 neo_simulation2 neobotix_mp_400_navigation that follow_waypoints package has a folder with the same name on it. on that folder, we created a file named follow_waypoints.py cd ~/ros2_ws/src/follow_waypoints/follow_waypoints touch follow_waypoints.py chmod +x follow_waypoints.py the touch command was used to create the file, and the chmod +x command was used to give execution permissions to that file (make it executable, basically) we then pasted some content on the follow_waypoints.py file. you can see the content by opening that file using the code editor . the content we pasted is basically a modified version of https://github.com/ros-planning/navigation2/blob/main/nav2_simple_commander/nav2_simple_commander/example_waypoint_follower.py inspection route  to navigation to  how to follow waypoints using nav2 on lines 33 to 36 we define an inspection_route variable, which essentially is an array that defines the waypoints (positions in the map) that the robot has to go when patrolling. #! /usr/bin/env python3 #  2021 samsung research america # # licensed under the apache license, version 2.0 (the "license"); # you may not use this file except in compliance with the license. # you may obtain a copy of the license at # # http://www.apache.org/licenses/license-2.0 # # unless required by applicable law or agreed to in writing, software # distributed under the license is distributed on an "as is" basis, # without warranties or conditions of any kind, either express or implied. # see the license for the specific language governing permissions and # limitations under the license. import time from copy import deepcopy from geometry_msgs.msg import posestamped from rclpy.duration import duration import rclpy from nav2_simple_commander.robot_navigator import basicnavigator, navigationresult def main(): rclpy.init() navigator = basicnavigator() # inspection route, probably read in from a file for a real application # from either a map or drive and repeat. inspection_route = [ # simulation points [5.0, 0.0], [-5.0, -5.0], [-5.0, 5.0]] # set our demo's initial pose # initial_pose = posestamped() # initial_pose.header.frame_id = 'map' # initial_pose.header.stamp = navigator.get_clock().now().to_msg() # initial_pose.pose.position.x = 3.45 # initial_pose.pose.position.y = 2.15 # initial_pose.pose.orientation.z = 1.0 # initial_pose.pose.orientation.w = 0.0 # navigator.setinitialpose(initial_pose) # wait for navigation to fully activate navigator.waituntilnav2active() while rclpy.ok(): # send our route inspection_points = [] inspection_pose = posestamped() inspection_pose.header.frame_id = 'map' inspection_pose.header.stamp = navigator.get_clock().now().to_msg() inspection_pose.pose.orientation.z = 1.0 inspection_pose.pose.orientation.w = 0.0 for pt in inspection_route: inspection_pose.pose.position.x = pt[0] inspection_pose.pose.position.y = pt[1] inspection_points.append(deepcopy(inspection_pose)) nav_start = navigator.get_clock().now() navigator.followwaypoints(inspection_points) # do something during our route (e.x. ai to analyze stock information or upload to the cloud) # simply print the current waypoint id for the demonstation i = 0 while not navigator.isnavcomplete(): i = i + 1 feedback = navigator.getfeedback() if feedback and i % 5 == 0: print('executing current waypoint: ' + str(feedback.current_waypoint + 1) + '/' + str(len(inspection_points))) result = navigator.getresult() if result == navigationresult.succeeded: print('inspection of shelves complete! returning to start...') elif result == navigationresult.canceled: print('inspection of shelving was canceled. returning to start...') exit(1) elif result == navigationresult.failed: print('inspection of shelving failed! returning to start...') # go back to start # initial_pose.header.stamp = navigator.get_clock().now().to_msg() # navigator.gotopose(initial_pose) while not navigator.isnavcomplete: pass if __name__ == '__main__': main() in addition to that follow_waypoints.py file, we also had to create the ~/ros2_ws/src/follow_waypoints/config/follow_waypoints.yaml and ~/ros2_ws/src/follow_waypoints/setup.py files. please check that files. if you want a deeper explanation  those files, please check the video available at the end of this post. alright, after having created that package and the required configuration files, the next was was compiling the package: cd ~/ros2_ws colcon build; source install/setup.bash then, to see the robot following the waypoints, we can run: cd ~/ros2_ws source install/setup.bash ros2 run follow_waypoints follow_waypoints_exe looking at the simulation and at rviz, you should be able to see the robot moving. congratulations. you just learned how to make a robot follow waypoints using nav2 (the official ros 2 navigation package) we hope this post was really helpful to you. if you want a live version of this post with more details , please check the video in the next section. youtube video so this is the post for today. remember that we have the live version of this post on youtube. if you liked the content, please consider subscribing to our youtube channel. we are publishing new content ~every day. keep pushing your ros learning. related courses & training if you want to learn more  ros and ros2, we recommend the following courses: ros2 basics in 5 days humble (python): https://app.theconstructsim.com/course/132 ros2 basics in 5 days humble (c++) : https://app.theconstructsim.com/course/133 open-rmf / fleet management training : https://www.theconstruct.ai/robot-fleet-management-ros2-open-rmf-training/ topics: nav2 | ros2 | waypoints check out these related posts how to become a robotics developer may 26, 2018 updated: july 26, 2023 robotics needs developers! robotics needs software engineers and software... read more 130. the open source robotics alliance apr 8, 2024 i would like to dedicate this episode to all the ros developers out there who are thinking and... read more 129. ros2ai jan 29, 2024 i would like to dedicate this episode to all the ros developers who believe that chatgpt or... read more  older entries 0 comments submit a comment cancel reply your email address will not be published. comment name email website save my name, email, and website in this browser for the next time i comment. submit comment δ this site uses akismet to reduce spam. learn how your comment data is processed . pin it on pinterest share this twitter linkedin reddit facebook gmail