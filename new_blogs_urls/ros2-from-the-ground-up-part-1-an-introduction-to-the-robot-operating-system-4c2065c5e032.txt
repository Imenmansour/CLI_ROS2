open in app sign up sign in write sign up sign in ros2 from the ground up: part 1  an introduction to the robot operating system jegathesan shanmugam  follow 9 min read  dec 22, 2022 -- 3 listen share robots on mars(ai generated image) how  a poem  ros2 to get things started?  ros2, the robots friend, a platform on which they depend, for communication, coordination, and control, it helps them achieve their goals. with dds at its core, ros2 helps robots explore, new worlds, new tasks, and new possibilities, its a platform that facilitates and facilitates ease. from turtles to drones, and everything in between, ros2 helps robots work, learn, and dream, its a powerful tool, a powerful ally, helping robots reach their highest potential, and never say goodbye. r os2 (robot operating system 2) is a collection of open-source software libraries and tools that provide a flexible framework for developing and running robotics applications . it is intended to be the primary development platform for robots that operate in complex, dynamic environments, and it is designed to be an open, scalable , and interoperable framework for building robot applications. ros2 is the successor to ros (robot operating system), which was created by willow garage, a robotics research institute, in 2007. ros was created to provide a common framework for developing robotics applications, and it has since grown in popularity as a platform for building robots in research and industry. ros2 expands on ross strengths while also introducing new features and capabilities to meet the evolving needs of the robotics community. some of the key differences between ros and ros2 are as follows: communications infrastructure: ros2 uses a new communications infrastructure based on data distribution service (dds) , which improves performance, scalability, and security over the ros1 infrastructure based on the tcp/udp protocol . modular architecture: in comparison to the monolithic architecture of ros1 , ros2 has a more modular architecture with a different layer of middleware, which makes it easier to customise and extend. operating system and language support: compared to ros1, ros2 supports a wide range of programming languages and operating systems, including windows, mac os, and real-time operating systems . testing, debugging, and deployment: its includes new features and tools for testing, debugging, and deploying robot applications, such a s improved support for continuous integration and deploymen t, and support for debugging and profiling tools. compatibility with ros1: its is designed to be backwards compatible with ros1, allowing existing ros1 applications to be easily migrated to ros2 via the ros1 bridge . however, some differences exist between ros1 and ros2, which may necessitate some changes to existing ros1 applications when they are migrated to ros2. ros community: the ros community is a large and active community of individuals and organizations from academia, industry, and government who are interested in building and using robots. the ros community is involved in the development and maintenance of ros. reference: https://www.openrobotics.org/ the ros community has a strong focus on collaboration and sharing, and there are many resources available for people to learn  and get involved in the project. there are also numerous conferences, workshops, and meetups organized by the community, which provide opportunities for people to connect with others and learn more  ros. the ros community has played a significant role in the success of ros and is widely praised for its contributions to the project.  architecture overview: robotics systems are becoming increasingly complex due to the need to handle a wide range of tasks and environments, as well as the increasing number of sensors, actuators, and other hardware components that are being used in robotics systems. as a result, there is a need for a flexible, scalable, and reliable communication infrastructure that can support the development of complex robotics applications. ros1 & 2 architecture comparison ros2 designed in an abstract way to focus more on functionality rather than reinventing the wheels. this means that ros2 provides a set of tools and libraries that are designed to be flexible and modular, allowing developers to build and deploy robot applications quickly and efficiently.. so, its has a various software layers, such as rclcpp, rcl, rmw, and dds, that provide the infrastructure for building and running robot applications. these parts are meant to work together to provide a high-level interface for building and running robot applications while hiding the complexity of the technologies underneath. dds (data distribution service) is a middleware technology that provides a high-performance, scalable, and secure way for nodes to exchange data and communicate with each other. dds is used as the communication layer for ros2. rmw (ros middleware) is a middleware layer that provides the underlying communication infrastructure for ros2 using dds. rmw abstracts the complexity of dds, which means that developers do not need to worry  the details of how dds works. rcl (ros client library) is a middleware layer that provides a high-level interface for building and running robot applications using rmw. rcl abstracts the complexity of rmw, which means that developers do not need to worry  the details of how rmw works. rclcpp is a c++ implementation of rcl that provides a set of c++ classes and functions for building and running robot applications using rcl. rclcpp makes it easier to develop robot applications using c++, and it provides a number of features and tools that make it easier to develop and debug robot applications. functional overview: computational graph: the ros graph is the most important part of any ros 2 system. the computational graph is a network of nodes that work together to solve problems and talk to each other. each node in the computational graph is a process that does some kind of computation, and the edges between the nodes are the ways that the nodes share data with each other. its important part of ros2 because it lets you organise and coordinate the different parts of an application for a robot. by connecting the nodes in a computational graph, you can make a distributed system in which each node does a specific task and talks to other nodes as needed. autoware detection graph node: nodes are the another important parts of a ros system. each node in the system has a specific job to do, and they talk to each other using a publish-subscribe or request-response messaging pattern. one node can send a message to a certain topic, and other nodes that are interested in that topic can subscribe to it and get the message. messages: topics are called buses, and nodes send messages to each other over them. messages are the bits of data that are sent from one node to another over a topic. they are written in the ros message description language (.msg) and are used to describe how the data being sent is structured. messages can contain many different types of data, from simple ones like integers and floats to more complicated ones like arrays and custom message types . in ros2, topics and messages work almost the same way as they did in ros1, but they are put together using the data distribution service (dds) middleware. the rosidl generator dds idl tool is used to transform msg files into dds idl files. this tool is part of the ros2 build system and is automatically run when a ros2 package with message definitions is built. publisher and subscriber: a node that sends messages to a certain topic is called a publisher . a node that receives messages from a certain topic is called a subscriber . in ros2, a node creates a publisher object and uses it to send a message to a topic. a node creates a subscriber object and tells it which topic it wants to subscribe to so it can receive messages. the subscriber will then get any messages that are posted to that topic. service: a service is a way for nodes to request specific computation or data from other nodes and receive a response. services are implemented using a request-response messaging pattern, where a node that wants to request a computation or data (the client ) sends a request message to another node (the server ), which performs the computation or retrieves the data and sends a response message back to the client. callbacks and timer: timer is a way to schedule a callback function to be executed at a specific time or at regular intervals. timers are implemented in the rclcpp lib , which provides a common timer reference for nodes in a distributed system. to use a timer in ros, a node creates a timer object and specifies the callback function that should be executed when the timer expires. the node can also specify the duration of the timer and whether it should be a one-time timer or a recurring timer. lifecycle management: a managed life cycle for nodes allows greater control over the state of ros system. it allows roslaunch to ensure that all components have been instantiated correctly before it allows any component to begin executing its behaviour . it provides a mechanism to define states in a node so that its life cycle of node can be better controlled. rclcpp_lifecycle interface provides implementing the lifecycle management specification. the lifecycle management specification defines a set of states and transitions that a node can go through during its life-cycle, as well as a set of actions that can be performed at specific points in the nodes life-cycle. ros2 design executor: many robotic applications need to be able to run in a predictable way within real-time limits . ros nodes need to be scheduled in a predictable way in order to receive and send communications data, update timers, or do logging operations. the executor concept in ros 2 handles these kinds of scheduling needs. an executor is a component that is responsible for managing the execution of nodes in a ros system . the executor is responsible for scheduling the execution of nodes and ensuring that they receive the necessary resources to perform their tasks. however, ros2 executor does not provide sufficient control over the execution management. for example, there are no mechanisms to enforce a certain execution order of callbacks within a node. the executor ignores the criticality of the task chains. this behavior will be an issue in a scenario where the robot needs to take an alternative path after the obstacles are detected. this is what we called it as priority inversion. means, it is a bug that occurs when a high priority task is indirectly preempted by a low priority task. so, we can conclude that ros2 scheduling is fair-share scheduling. in ros2, there is no general guideline  how to allocate resources and assign priority for these executors and map these executors to cpu cores like processor affinity. so, ros2 does have limitations especially in the real time perspective. we will talk  this issue in more depth in a later post. node discovery: the ros-dds abstraction layer offers a distributed directory service that makes it possible for nodes to find each other and talk to each other. nodes can use the dds service to find and talk to other nodes that are publishing or subscribing to certain topics. the nodes are found automatically behind the scenes. when a node fires up, it tells other nodes on the network that have the same ros domain (which you can set with the ros domain id environment variable) that it is there. nodes respond to this ad with information  themselves so that the right connections can be made and the nodes can talk to each other. in summary, ros2 is a powerful open-source robotics platform that provides a wide range of tools and features for building and deploying robot applications. it offers improved scalability, performance, and support for a wide range of platforms and languages compared to its predecessor, ros. if youre interested in learning more  ros2 and how it can help you build and deploy robots, there are a number of resources available online, including the ros2 documentation, tutorials, and community forums. thank you for following along with this ros2 introduction post. in this series of posts, we will be covering various programming topics related to ros2, including topics such as nodes, topics, services, actions, and more. in the next post, we will delve deeper into the ros2 programming. robotics computer vision robotics operating system ros2 follow written by jegathesan shanmugam 274 followers talks  #robotics, #computervision, and #embeddedsystems follow help status  careers press    text to speech teams