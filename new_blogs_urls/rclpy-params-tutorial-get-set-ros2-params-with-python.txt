skip to content in this rclpy params tutorial youll learn how to get and set ros2 params with rclpy, inside a python node. ros2 params allow you to provide configuration for a node at run time. all params specified for a node are specific to this node and only exist while the node is alive. its very useful, you can start your node with different settings each time, without having to change your python code. (for the same params tutorial with cpp, checkout the rclcpp params tutorial ) lets get started! table of contents toggle setup code and declare ros2 params with rclpy first things first: you have to declare every ros2 param youll use in your node . usually this is one of the first thing you do in the nodes constructor. you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. its important: if you dont declare a parameter in your nodes code, you will get an error when you try to get or set it (parameternotdeclaredexception exception). declaring a parameter does not mean you set a value, it just means that this parameter exists. declare params with rclpy heres a minimal ros2 python node which declares 3 parameters (with no default value, well see later how to do that): plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter import rclpy from rclpy.node import node class testparams ( node ) : def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) self. declare_parameter ( 'my_str' , rclpy.parameter.type.string ) self. declare_parameter ( 'my_int' , rclpy.parameter.type.integer ) self. declare_parameter ( 'my_double_array' , rclpy.parameter.type.double_array ) # the following is just to start the node def main ( args= none ) : rclpy. init ( args=args ) node = testparams () rclpy. spin ( node ) node. destroy_node () rclpy. shutdown () if __name__ == "__main__" : main () import rclpy from rclpy.node import node class testparams(node): def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) # the following is just to start the node def main(args=none): rclpy.init(args=args) node = testparams() rclpy.spin(node) node.destroy_node() rclpy.shutdown() if __name__ == "__main__": main() import rclpy from rclpy.node import node class testparams(node): def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) # the following is just to start the node def main(args=none): rclpy.init(args=args) node = testparams() rclpy.spin(node) node.destroy_node() rclpy.shutdown() if __name__ == "__main__": main() note: you also need to provide either a default value (more on that later), or the type for each parameter. if you have autocompletion, you can easily find the available types by writing first rclpy.parameter.type. you can also declare multiple parameters at once. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) self. declare_parameters ( namespace= '' , parameters= [ ( 'my_str' , rclpy.parameter.type.string ) , ( 'my_int' , rclpy.parameter.type.integer ) , ( 'my_double_array' , rclpy.parameter.type.double_array ) ] ) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameters( namespace='', parameters=[ ('my_str', rclpy.parameter.type.string), ('my_int', rclpy.parameter.type.integer), ('my_double_array', rclpy.parameter.type.double_array) ] ) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameters( namespace='', parameters=[ ('my_str', rclpy.parameter.type.string), ('my_int', rclpy.parameter.type.integer), ('my_double_array', rclpy.parameter.type.double_array) ] ) and, if you ever need to, at any moment you can also undeclare a parameter: self. undeclare_parameter ( 'my_str' ) self.undeclare_parameter('my_str') . run your node without params lets see what happens when you simply run this node without setting any parameter value: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy  ros2 run ros2_tutorials test_params_rclpy  ros2 run ros2_tutorials test_params_rclpy in another terminal, run: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time as you can see the node test_params_rclpy now contains 3 ros2 params  in addition to the use_sim_time param, automatically created for each node. those parameters are just declared, they are not set yet. if you try to get one from the terminal  with ros2 param get, youll get an exception like this in your node: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter rclpy.exceptions.parameteruninitializedexception: the parameter 'my_str' is not initialized rclpy.exceptions.parameteruninitializedexception: the parameter 'my_str' is not initialized rclpy.exceptions.parameteruninitializedexception: the parameter 'my_str' is not initialized this can be avoided if you set some default values (see more on that later), or if you specify the params values when you run the node. run your node with params lets add parameters when we start the node with ros2 run ros2 run : plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:= "hello world" -p my_int:= 5 -p my_double_array:= "[4.4, 5.5, 6.6]"  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:="hello world" -p my_int:=5 -p my_double_array:="[4.4, 5.5, 6.6]"  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:="hello world" -p my_int:=5 -p my_double_array:="[4.4, 5.5, 6.6]" the names of params must be identical to the ones we declared in the nodes code. you can also use a ros2 launch file instead of adding all your params manually in the terminal (additional improvement: you can also set all your params in a yaml config file ). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from launch import launchdescription from launch_ros.actions import node def generate_launch_description () : return launchdescription ([ node ( package= 'ros2_tutorials' , executable= 'test_params_rclpy' , parameters= [ { 'my_str' : 'hello world' } , { 'my_int' : 5 } , { 'my_double_array' : [ 4.4 , 5.5 , 6.6 ]} ] , output= 'screen' , emulate_tty= true ) ]) from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): return launchdescription([ node( package='ros2_tutorials', executable='test_params_rclpy', parameters=[ {'my_str': 'hello world'}, {'my_int': 5}, {'my_double_array': [4.4, 5.5, 6.6]} ], output='screen', emulate_tty=true ) ]) from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): return launchdescription([ node( package='ros2_tutorials', executable='test_params_rclpy', parameters=[ {'my_str': 'hello world'}, {'my_int': 5}, {'my_double_array': [4.4, 5.5, 6.6]} ], output='screen', emulate_tty=true ) ]) and heres the result you should get after starting the node: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 param get /test_params_rclpy my_str string value is: hello world  ros2 param get /test_params_rclpy my_str string value is: hello world  ros2 param get /test_params_rclpy my_str string value is: hello world so, what happened? the node starts and declares a parameter named my_str in its constructor. when launching the node, you also give a value for the my_str parameter. as the parameter is declared, the value is set. to insist on the importance of declaring your ros2 params, lets run the node with a parameter which was not declared before. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_other_str:= "guess it won't work"  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_other_str:="guess it won't work"  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_other_str:="guess it won't work" in another terminal: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time  ros2 param get /test_params_rclpy my_other_str parameter not set.  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time  ros2 param get /test_params_rclpy my_other_str parameter not set.  ros2 param list /test_params_rclpy: my_double_array my_int my_str use_sim_time  ros2 param get /test_params_rclpy my_other_str parameter not set. the my_other_str param does not appear in the list! if youve already started to experiment with ros2 parameters and wondered why your parameters dont appear, well this is probably because you didnt declare them. get params with rclpy now that youve declared parameters in your code, lets retrieve them in the nodes code! get params one by one plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) self. declare_parameter ( 'my_str' , rclpy.parameter.type.string ) self. declare_parameter ( 'my_int' , rclpy.parameter.type.integer ) self. declare_parameter ( 'my_double_array' , rclpy.parameter.type.double_array ) param_str = self. get_parameter ( 'my_str' ) param_int = self. get_parameter ( 'my_int' ) param_double_array = self. get_parameter ( 'my_double_array' ) self. get_logger () . info ( "str: %s, int: %s, double[]: %s" % ( str ( param_str.value ) , str ( param_int.value ) , str ( param_double_array.value ) , )) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) param_str = self.get_parameter('my_str') param_int = self.get_parameter('my_int') param_double_array = self.get_parameter('my_double_array') self.get_logger().info("str: %s, int: %s, double[]: %s" % (str(param_str.value), str(param_int.value), str(param_double_array.value),)) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) param_str = self.get_parameter('my_str') param_int = self.get_parameter('my_int') param_double_array = self.get_parameter('my_double_array') self.get_logger().info("str: %s, int: %s, double[]: %s" % (str(param_str.value), str(param_int.value), str(param_double_array.value),)) use the get_parameter ( name ) get_parameter(name) method to get the value for one declared parameter. in fact, this method wont return the value, it will return a parameter object. the value is stored in the value attribute of the parameter, as you can see when we print the params with the rclpy logger. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:= "hello world" -p my_int:= 5 -p my_double_array:= "[4.4, 5.5, 6.6]" [info] [test_params_rclpy]: str: hello world, int: 5 , double[]: [4. 4 , 5. 5 , 6. 6 ]  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:="hello world" -p my_int:=5 -p my_double_array:="[4.4, 5.5, 6.6]" [info] [test_params_rclpy]: str: hello world, int: 5, double[]: [4.4, 5.5, 6.6]  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_str:="hello world" -p my_int:=5 -p my_double_array:="[4.4, 5.5, 6.6]" [info] [test_params_rclpy]: str: hello world, int: 5, double[]: [4.4, 5.5, 6.6] get multiple params at once you can also get all your parameters with get_parameters ( list [ name ]) get_parameters(list[name]) . plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... ( param_str, param_int, param_double_array ) = self. get_parameters ( [ 'my_str' , 'my_int' , 'my_double_array' ]) ... ... (param_str, param_int, param_double_array) = self.get_parameters( ['my_str', 'my_int', 'my_double_array']) ... ... (param_str, param_int, param_double_array) = self.get_parameters( ['my_str', 'my_int', 'my_double_array']) ... set default values you may want to set default values for parameters which were not set when you start your node. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... self. declare_parameter ( 'my_str' , 'default value' ) self. declare_parameter ( 'my_int' , 7 ) self. declare_parameter ( 'my_double_array' , [ 1.1 , 2.2 ]) ... ... self.declare_parameter('my_str', 'default value') self.declare_parameter('my_int', 7) self.declare_parameter('my_double_array', [1.1, 2.2]) ... ... self.declare_parameter('my_str', 'default value') self.declare_parameter('my_int', 7) self.declare_parameter('my_double_array', [1.1, 2.2]) ... or all at once: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... self. declare_parameters ( namespace= '' , parameters= [ ( 'my_str' , "default value" ) , ( 'my_int' , 7 ) , ( 'my_double_array' , [ 1.1 , 2.2 ]) ] ) ... ... self.declare_parameters( namespace='', parameters=[ ('my_str', "default value"), ('my_int', 7), ('my_double_array', [1.1, 2.2]) ] ) ... ... self.declare_parameters( namespace='', parameters=[ ('my_str', "default value"), ('my_int', 7), ('my_double_array', [1.1, 2.2]) ] ) ... when you start your node: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_int:= 5 [info] [test_params_rclpy]: str: default value, int: 5 , double[]: [1. 1 , 2. 2 ]  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_int:=5 [info] [test_params_rclpy]: str: default value, int: 5, double[]: [1.1, 2.2]  ros2 run ros2_tutorials test_params_rclpy --ros-args -p my_int:=5 [info] [test_params_rclpy]: str: default value, int: 5, double[]: [1.1, 2.2] here we only set the my_int parameter to 5. the default value (7) is not used. for the 2 other parameters (my_str and my_double_array), as we did not specify any value, then they take the default value. again, if you forget to declare a parameter lets say you forgot to declare the my_str parameter and then try to access it (for reading or writing). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) # self.declare_parameter('my_str') --> not declared! param_str = self. get_parameter ( 'my_str' ) def __init__(self): super().__init__('test_params_rclpy') # self.declare_parameter('my_str') --> not declared! param_str = self.get_parameter('my_str') def __init__(self): super().__init__('test_params_rclpy') # self.declare_parameter('my_str') --> not declared! param_str = self.get_parameter('my_str') as soon as you start your node  even if you specify a parameter value for my_str, youll get an parameternotdeclaredexception error. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  start node ... raise parameternotdeclaredexception(name) rclpy.exceptions.parameternotdeclaredexception: ( 'invalid access to undeclared parameter(s)' , 'my_str' )  start node ... raise parameternotdeclaredexception(name) rclpy.exceptions.parameternotdeclaredexception: ('invalid access to undeclared parameter(s)', 'my_str')  start node ... raise parameternotdeclaredexception(name) rclpy.exceptions.parameternotdeclaredexception: ('invalid access to undeclared parameter(s)', 'my_str') so: any parameter not declared within a node wont appear in the parameter list, and wont be available. any time you try to access a parameter in your code without declaring it first, youll get an error. set params with rclpy if you just want to set a parameters value in case it is not specified when you start the node, then prefer using a default value (as you saw before in this tutorial). however, if you want to impose a parameters value from your code, you can use the set_parameters ( list [ parameters ]) set_parameters(list[parameters]) method. if the parameters value was already set before, it will be overridden. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from rclpy.parameter import parameter ... def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) self. declare_parameter ( 'my_str' , rclpy.parameter.type.string ) self. declare_parameter ( 'my_int' , rclpy.parameter.type.integer ) self. declare_parameter ( 'my_double_array' , rclpy.parameter.type.double_array ) param_str = parameter ( 'my_str' , parameter.type.string, 'set from code' ) param_int = parameter ( 'my_int' , parameter.type.integer, 12 ) param_double_array = parameter ( 'my_double_array' , parameter.type.double_array, [ 1.1 , 2.2 ]) self. set_parameters ([ param_str, param_int, param_double_array ]) from rclpy.parameter import parameter ... def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) param_str = parameter('my_str', parameter.type.string, 'set from code') param_int = parameter('my_int', parameter.type.integer, 12) param_double_array = parameter('my_double_array', parameter.type.double_array, [1.1, 2.2]) self.set_parameters([param_str, param_int, param_double_array]) from rclpy.parameter import parameter ... def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', rclpy.parameter.type.string) self.declare_parameter('my_int', rclpy.parameter.type.integer) self.declare_parameter('my_double_array', rclpy.parameter.type.double_array) param_str = parameter('my_str', parameter.type.string, 'set from code') param_int = parameter('my_int', parameter.type.integer, 12) param_double_array = parameter('my_double_array', parameter.type.double_array, [1.1, 2.2]) self.set_parameters([param_str, param_int, param_double_array]) a parameter object takes 3 arguments: name, type, and value. dont forget to add the dependency for the parameter class. if you start this node, and get each parameter in another window with ros2 param get ros2 param get , youll see the values set in the code. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 param get /test_params_rclpy my_str string value is: set from code  ros2 param get /test_params_rclpy my_str string value is: set from code  ros2 param get /test_params_rclpy my_str string value is: set from code heres what happens with the my_str parameter: first it is declared in the code, so it can be set. when you start the node, either you provide a value for my_str, or the default value will be used. but, then my_str is set from the code, and the new value replaces any previous value. allow undeclared params with rclpy well, well, well. after everything i told you  the errors due to undeclared parameters, im now  to tell you how to allow them. the default way to work with parameters is to first declare them, then use them. however, there is one case where this could lead to a problem: if, for some reasons, your node is not aware of all parameters it should have when it is started. heres how to do. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' , allow_undeclared_parameters= true , automatically_declare_parameters_from_overrides= true ) param_str = self. get_parameter_or ( 'my_str' , parameter ( 'str' , parameter.type.string, 'is there anybody out there?' )) param_int = self. get_parameter_or ( 'my_int' , parameter ( 'abc' , parameter.type.integer, 8 )) param_double_array = self. get_parameter_or ( 'my_double_array' , parameter ( 'def' , parameter.type.double_array, [ 1.1 , 2.2 ])) self. get_logger () . info ( "params: %s, %s, %s" % ( str ( param_int.value ) , str ( param_str.value ) , str ( param_double_array.value ) , )) def __init__(self): super().__init__('test_params_rclpy', allow_undeclared_parameters=true, automatically_declare_parameters_from_overrides=true) param_str = self.get_parameter_or( 'my_str', parameter('str', parameter.type.string, 'is there anybody out there?')) param_int = self.get_parameter_or( 'my_int', parameter('abc', parameter.type.integer, 8)) param_double_array = self.get_parameter_or( 'my_double_array', parameter('def', parameter.type.double_array, [1.1, 2.2])) self.get_logger().info("params: %s, %s, %s" % (str(param_int.value), str(param_str.value), str(param_double_array.value),)) def __init__(self): super().__init__('test_params_rclpy', allow_undeclared_parameters=true, automatically_declare_parameters_from_overrides=true) param_str = self.get_parameter_or( 'my_str', parameter('str', parameter.type.string, 'is there anybody out there?')) param_int = self.get_parameter_or( 'my_int', parameter('abc', parameter.type.integer, 8)) param_double_array = self.get_parameter_or( 'my_double_array', parameter('def', parameter.type.double_array, [1.1, 2.2])) self.get_logger().info("params: %s, %s, %s" % (str(param_int.value), str(param_str.value), str(param_double_array.value),)) you have to add 2 arguments to the node youre creating: allow_undeclared_parameters. automatically_declare_parameters_from_overrides. basically, when you set a parameter from outside the node, the parameter will be declared for this node, even if you didnt declare it within the node. then you can use the get_parameter_or ( name, parameter ) get_parameter_or(name, parameter) method. this method will check if the parameter is declared. if yes, the parameter is retrieved. if not, you can specify a default parameter. its probably a best practice to always set default parameters when doing this. lets run this node with a non declared parameter: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials test_params_rclpy --ros-args -p this_is_a_non_declared_param:= "this will work" [info] [test_params_rclpy]: params: 8 , is there anybody out there?, [1. 1 , 2. 2 ] # in another terminal:  ros2 param list /test_params_rclpy: this_is_a_non_declared_param use_sim_time  ros2 param get /test_params_rclpy this_is_a_non_declared_param string value is: this will work  ros2 run ros2_tutorials test_params_rclpy --ros-args -p this_is_a_non_declared_param:="this will work" [info] [test_params_rclpy]: params: 8, is there anybody out there?, [1.1, 2.2] # in another terminal:  ros2 param list /test_params_rclpy: this_is_a_non_declared_param use_sim_time  ros2 param get /test_params_rclpy this_is_a_non_declared_param string value is: this will work  ros2 run ros2_tutorials test_params_rclpy --ros-args -p this_is_a_non_declared_param:="this will work" [info] [test_params_rclpy]: params: 8, is there anybody out there?, [1.1, 2.2] # in another terminal:  ros2 param list /test_params_rclpy: this_is_a_non_declared_param use_sim_time  ros2 param get /test_params_rclpy this_is_a_non_declared_param string value is: this will work 2 things here: the new parameter we set from command line appears in the list, which means it has been automatically declared. also its value is set. the 3 parameters were trying to get from the code are not declared anywhere (from within our outside the node), so we get the default value. to conclude on that: as a general rule, always declare your parameters first, and follow the ros2 way of doing things. only allow undeclared parameters for a good reason. rclpy parameter callback a great thing  ros2 params, is that you can modify them at any time. and there is a simple way to notify your node when a param is modified. you can add a callback with add_on_set_parameters_callback ( function ) add_on_set_parameters_callback(function) that will be called every time a parameters value has been changed from the outside. (for ros1 users, this is the same mechanism as dynamic_reconfigure in ros1, but here its directly implemented inside nodes, and much simpler to setup) plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter import rclpy from rclpy.node import node from rclpy.parameter import parameter from rcl_interfaces.msg import setparametersresult class testparams ( node ) : def parameter_callback ( self, params ) : for param in params: if param.name == 'my_str' and param.type_ == parameter.type.string: self.my_str = param.value return setparametersresult ( successful= true ) def __init__ ( self ) : super () . __init__ ( 'test_params_rclpy' ) self. declare_parameter ( 'my_str' , 'default value' ) self.my_str = self. get_parameter ( 'my_str' ) .value self. get_logger () . info ( "new value set: %s" % self.my_str ) self. add_on_set_parameters_callback ( self.parameter_callback ) import rclpy from rclpy.node import node from rclpy.parameter import parameter from rcl_interfaces.msg import setparametersresult class testparams(node): def parameter_callback(self, params): for param in params: if param.name == 'my_str' and param.type_ == parameter.type.string: self.my_str = param.value return setparametersresult(successful=true) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', 'default value') self.my_str = self.get_parameter('my_str').value self.get_logger().info("new value set: %s" % self.my_str) self.add_on_set_parameters_callback(self.parameter_callback) import rclpy from rclpy.node import node from rclpy.parameter import parameter from rcl_interfaces.msg import setparametersresult class testparams(node): def parameter_callback(self, params): for param in params: if param.name == 'my_str' and param.type_ == parameter.type.string: self.my_str = param.value return setparametersresult(successful=true) def __init__(self): super().__init__('test_params_rclpy') self.declare_parameter('my_str', 'default value') self.my_str = self.get_parameter('my_str').value self.get_logger().info("new value set: %s" % self.my_str) self.add_on_set_parameters_callback(self.parameter_callback) what you do inside the callback is up to you and depends on your application (to go further on this, check out this more complete rclpy parameter callback tutorial ). you may wish to store the new parameters value, change a behavior in your node, or simply ignore all changes. going further with ros2 params in this tutorial you have learned how to get and set parameters from a python node, using rclpy. you saw the importance of declaring parameters. now, if you want to go further with ros2 params: learn how to handle params with cpp and rclcpp . learn how to set all your parameters in yaml config files (very useful to scale your application properly). also, one thing you could wish to do, is to have some parameters globally available to all nodes. as you know, ros2 parameters are specific to a node and only exist with this node. if you want to set a parameter shared by multiple nodes, one way you could achieve that is to create a dedicated node only for global params . youd launch this node first, and always keep it alive so other nodes can retrieve parameters (and get notified) from it. want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here