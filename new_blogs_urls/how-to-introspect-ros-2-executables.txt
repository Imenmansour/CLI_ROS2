how to introspect ros 2 executables written by bayode aderinola  ros2 q&a | ros2 tutorials  14/12/2022 in this post, you will learn how to introspect ros 2 executables by identifying publishers and subscribers in the executables. this answers this question posted on ros answers. step 1: copy sample packages containing ros 2 executables hey, do i have to install ros2 first? absolutely not! we will be using the construct to get access to virtual machines pre-installed with ros. click here to copy the ros2 turtlebot3 sandbox packages. once copied, click the red run button to launch the packages in a virtual machine. please be patient while the environment loads. ps: you will need to login or create an account to copy the packages. you might also want to try this on a local pc if you have ros2 and some executables installed. however, please note that we cannot support local pcs and you will have to fix any errors you run into on your own. the rest of the instruction assumes that you are working on the construct; please adapt them to your local pc and ros2 installation. step 2: explore the source code of an ament_python package you can know what topics are being used by an executable (that is, introspect it) without running it by checking its source code, looking for publishers and subscribers. now head over to the code editor to make to explore the source code of the packages you just copied. open the code editor first, we look at the turtlebot3_teleop package. turtlebot3_teleop package lets look for the executable file for this package. we can find that in the setup.py file. turtlebot3_teleop/setup.py from setuptools import find_packages from setuptools import setup package_name = 'turtlebot3_teleop' setup( name=package_name, version='2.1.2', packages=find_packages(exclude=[]), data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ], install_requires=[ 'setuptools', ], zip_safe=true, author='darby lim', author_email='thlim@robotis.com', maintainer='will son', maintainer_email='willson@robotis.com', keywords=['ros'], classifiers=[ 'intended audience :: developers', 'license :: osi approved :: apache software license', 'programming language :: python', 'topic :: software development', ], description=( 'teleoperation node using keyboard for turtlebot3.' ), license='apache license, version 2.0', tests_require=['pytest'], entry_points={ 'console_scripts': [ 'teleop_keyboard = turtlebot3_teleop.script.teleop_keyboard:main' ], }, ) looking at the entry_points part of the file, and then the console_scripts , we find the executable file is in the turtlebot3_teleop/script/teleop_keyboard.py file. lets find the publishers and/subscribers for this executable. turtlebot3_teleop/script/teleop_keyboard.py def main(): settings = none if os.name != 'nt': settings = termios.tcgetattr(sys.stdin) rclpy.init() qos = qosprofile(depth=10) node = rclpy.create_node('teleop_keyboard') pub = node.create_publisher(twist, 'cmd_vel', qos) status = 0 target_linear_velocity = 0.0 target_angular_velocity = 0.0 control_linear_velocity = 0.0 control_angular_velocity = 0.0 try: print(msg) while(1): key = get_key(settings) if key == 'w': target_linear_velocity =\ check_linear_limit_velocity(target_linear_velocity + lin_vel_step_size) status = status + 1 print_vels(target_linear_velocity, target_angular_velocity) elif key == 'x': target_linear_velocity =\ check_linear_limit_velocity(target_linear_velocity - lin_vel_step_size) status = status + 1 print_vels(target_linear_velocity, target_angular_velocity) elif key == 'a': target_angular_velocity =\ check_angular_limit_velocity(target_angular_velocity + ang_vel_step_size) status = status + 1 print_vels(target_linear_velocity, target_angular_velocity) elif key == 'd': target_angular_velocity =\ check_angular_limit_velocity(target_angular_velocity - ang_vel_step_size) status = status + 1 print_vels(target_linear_velocity, target_angular_velocity) elif key == ' ' or key == 's': target_linear_velocity = 0.0 control_linear_velocity = 0.0 target_angular_velocity = 0.0 control_angular_velocity = 0.0 print_vels(target_linear_velocity, target_angular_velocity) else: if (key == '\x03'): break if status == 20: print(msg) status = 0 twist = twist() control_linear_velocity = make_simple_profile( control_linear_velocity, target_linear_velocity, (lin_vel_step_size / 2.0)) twist.linear.x = control_linear_velocity twist.linear.y = 0.0 twist.linear.z = 0.0 control_angular_velocity = make_simple_profile( control_angular_velocity, target_angular_velocity, (ang_vel_step_size / 2.0)) twist.angular.x = 0.0 twist.angular.y = 0.0 twist.angular.z = control_angular_velocity pub.publish(twist) except exception as e: print(e) finally: twist = twist() twist.linear.x = 0.0 twist.linear.y = 0.0 twist.linear.z = 0.0 twist.angular.x = 0.0 twist.angular.y = 0.0 twist.angular.z = 0.0 pub.publish(twist) if os.name != 'nt': termios.tcsetattr(sys.stdin, termios.tcsadrain, settings) if __name__ == '__main__': main() success! on line 148 we can find that the executable creates a publisher to the /cmd_vel topic, so we know this is a topic used by the executable. are there other topics used by this executable? find out! step 3: explore the source code of an ament_cmake package let explore the turtlebot3_node package. turtlebot3_node package we can find the main executable in the cmakelists.txt file in the add_executable line (line 75). turtlebot3_node/cmakelists.txt ################################################################################ # set minimum required version of cmake, project name and compile options ################################################################################ cmake_minimum_required(version 3.5) project(turtlebot3_node) if(not cmake_cxx_standard) set(cmake_cxx_standard 14) endif() if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() ################################################################################ # find ament packages and libraries for ament and system dependencies ################################################################################ find_package(ament_cmake required) find_package(dynamixel_sdk required) find_package(geometry_msgs required) find_package(message_filters required) find_package(nav_msgs required) find_package(rclcpp required) find_package(rcutils required) find_package(sensor_msgs required) find_package(std_msgs required) find_package(std_srvs required) find_package(tf2 required) find_package(tf2_ros required) find_package(turtlebot3_msgs required) ################################################################################ # build ################################################################################ include_directories( include ) add_library({project_name}_lib "src/devices/motor_power.cpp" "src/devices/sound.cpp" "src/devices/reset.cpp" "src/diff_drive_controller.cpp" "src/dynamixel_sdk_wrapper.cpp" "src/odometry.cpp" "src/turtlebot3.cpp" "src/sensors/battery_state.cpp" "src/sensors/imu.cpp" "src/sensors/joint_state.cpp" "src/sensors/sensor_state.cpp" ) set(dependencies "dynamixel_sdk" "geometry_msgs" "message_filters" "nav_msgs" "rclcpp" "rcutils" "sensor_msgs" "std_msgs" "std_srvs" "tf2" "tf2_ros" "turtlebot3_msgs" ) target_link_libraries({project_name}_lib) ament_target_dependencies({project_name}_lib {dependencies}) set(executable_name "turtlebot3_ros") add_executable({executable_name} src/node_main.cpp) target_link_libraries({executable_name} {project_name}_lib) ament_target_dependencies({executable_name} {dependencies}) ################################################################################ # install ################################################################################ install(directory param destination share/{project_name} ) install(targets {executable_name} destination lib/{project_name} ) ################################################################################ # macro for ament package ################################################################################ ament_export_include_directories(include) ament_package() so we see that the main executable is src/node_main.cpp . lets examine it. turtlebot3_node/src/node_main.cpp //  2019 robotis co., ltd. // // licensed under the apache license, version 2.0 (the "license"); // you may not use this file except in compliance with the license. // you may obtain a copy of the license at // // http://www.apache.org/licenses/license-2.0 // // unless required by applicable law or agreed to in writing, software // distributed under the license is distributed on an "as is" basis, // without warranties or conditions of any kind, either express or implied. // see the license for the specific language governing permissions and // limitations under the license. // // author: darby lim #include <rcutils/cmdline_parser.h> #include <rclcpp/rclcpp.hpp> #include <chrono> #include <memory> #include <string> #include "turtlebot3_node/diff_drive_controller.hpp" #include "turtlebot3_node/turtlebot3.hpp" void help_print() { printf("for turtlebot3 node : \n"); printf("turtlebot3_node [-i usb_port] [-h]\n"); printf("options:\n"); printf("-h : print this help function.\n"); printf("-i usb_port: connected usb port with opencr."); } int main(int argc, char * argv[]) { setvbuf(stdout, null, _ionbf, bufsiz); if (rcutils_cli_option_exist(argv, argv + argc, "-h")) { help_print(); return 0; } rclcpp::init(argc, argv); std::string usb_port = "/dev/ttyacm0"; char * cli_options; cli_options = rcutils_cli_get_option(argv, argv + argc, "-i"); if (nullptr != cli_options) { usb_port = std::string(cli_options); } rclcpp::executors::singlethreadedexecutor executor; auto turtlebot3 = std::make_shared<robotis::turtlebot3::turtlebot3>(usb_port); auto diff_drive_controller = std::make_shared<robotis::turtlebot3::diffdrivecontroller>( turtlebot3->get_wheels()->separation, turtlebot3->get_wheels()->radius); executor.add_node(turtlebot3); executor.add_node(diff_drive_controller); executor.spin(); rclcpp::shutdown(); return 0; } theres no reference to a publisher or subscriber in this file, but it references some other files. lets look at the turtlebot3_node/turtlebot3.cpp file referenced on line 25 . turtlebot3_node/src/turtlebot3.cpp void turtlebot3::cmd_vel_callback() { auto qos = rclcpp::qos(rclcpp::keeplast(10)); cmd_vel_sub_ = this->create_subscription<geometry_msgs::msg::twist>( "cmd_vel", qos, [this](const geometry_msgs::msg::twist::sharedptr msg) -> void { std::string sdk_msg; union data { int32_t dword[6]; uint8_t byte[4 * 6]; } data; data.dword[0] = static_cast<int32_t>(msg->linear.x * 100); data.dword[1] = 0; data.dword[2] = 0; data.dword[3] = 0; data.dword[4] = 0; data.dword[5] = static_cast<int32_t>(msg->angular.z * 100); uint16_t start_addr = extern_control_table.cmd_velocity_linear_x.addr; uint16_t addr_length = (extern_control_table.cmd_velocity_angular_z.addr - extern_control_table.cmd_velocity_linear_x.addr) + extern_control_table.cmd_velocity_angular_z.length; uint8_t * p_data = &amp;data.byte[0]; dxl_sdk_wrapper_->set_data_to_device(start_addr, addr_length, p_data, &amp;sdk_msg); rclcpp_debug( this->get_logger(), "lin_vel: %f ang_vel: %f msg : %s", msg->linear.x, msg->angular.z, sdk_msg.c_str()); } ); } success! we see the /cmd_vel is also referenced on line 313 . can you find other files linked to the main file and its linked files, where other topics are referenced? step 4: check your learning do you understand how to introspect ros 2 executables? if you dont know it yet, please go over the post again, more carefully this time. (extra) step 5: watch the video to understand how to introspect ros 2 executables here you go: feedback did you like this post? do you have any questions  how to introspect ros 2 executables ? please leave a comment in the comments section below, so we can interact and learn from each other. if you want to learn  other ros2 topics, please let us know in the comments area and we will do a video or post  it. topics: binaries | ros2 | ros2 binaries | ros2 packages | ros2 pkg check out these related posts how to become a robotics developer may 26, 2018 updated: july 26, 2023 robotics needs developers! robotics needs software engineers and software... read more 130. the open source robotics alliance apr 8, 2024 i would like to dedicate this episode to all the ros developers out there who are thinking and... read more 129. ros2ai jan 29, 2024 i would like to dedicate this episode to all the ros developers who believe that chatgpt or... read more  older entries 0 comments submit a comment cancel reply your email address will not be published. comment name email website save my name, email, and website in this browser for the next time i comment. submit comment Î´ this site uses akismet to reduce spam. learn how your comment data is processed . pin it on pinterest share this twitter linkedin reddit facebook gmail