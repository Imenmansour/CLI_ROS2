skip to content in this tutorial you will learn how to run ros2 on multiple machines, including a raspberry pi 4 board. as youll see, things will be quite easy and there is almost no configuration to do. if youre using a raspberry pi with ros2 as one of the machines, make sure you have correctly installed ros2 on your pi . then, as youll see, no extra setup is required. for this tutorial i will personally use a laptop running ubuntu on a virtual machine (with a bridged adapter), and a raspberry pi with ros2 on ubuntu server. >> watch this video as an additional resource to this article: after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. table of contents toggle network configuration for ros2 multi-machines before starting, obviously make sure you have installed ros2 on each machine, preferably the same distribution. then, make sure you dont have a firewall blocking your communications on the network. if you have a firewall, allow udp multicasting, or disable the firewall at least during your first tests. connect all your machines in the same network. this is very important, otherwise they simply wont be able to find each other. now, you can easily check if the machines can reach out to each other. first, get the ip address of each machine inside the network by running hostname -i hostname -i . example: machine 1: hostname -i hostname -i returns 192.168.43.138 172.17.0.1 machine 2: hostname -i hostname -i returns 192.168.43.56 you may have multiple ip addresses on each machine, depending on what youve previously configured (ex: on machine 1 i have docker, this is why you see 172.17.0.1). just find the ip addresses that are on the same network, here those who start with 192.168.43.xx. if you can ping the machines from each other then the network configuration is done. machine 1: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ping 192.168 . 43 . 56 ping 192.168 . 43 . 56 ( 192.168 . 43 . 56 ) 56 ( 84 ) bytes of data. 64 bytes from 192.168 . 43 . 56 : icmp_seq= 1 ttl= 64 time= 128 ms 64 bytes from 192.168 . 43 . 56 : icmp_seq= 2 ttl= 64 time= 136 ms ^c  ping 192.168.43.56 ping 192.168.43.56 (192.168.43.56) 56(84) bytes of data. 64 bytes from 192.168.43.56: icmp_seq=1 ttl=64 time=128 ms 64 bytes from 192.168.43.56: icmp_seq=2 ttl=64 time=136 ms ^c  ping 192.168.43.56 ping 192.168.43.56 (192.168.43.56) 56(84) bytes of data. 64 bytes from 192.168.43.56: icmp_seq=1 ttl=64 time=128 ms 64 bytes from 192.168.43.56: icmp_seq=2 ttl=64 time=136 ms ^c machine 2: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ping 192.168 . 43 . 138 ping 192.168 . 43 . 138 ( 192.168 . 43 . 138 ) 56 ( 84 ) bytes of data. 64 bytes from 192.168 . 43 . 138 : icmp_seq= 1 ttl= 64 time= 8.75 ms 64 bytes from 192.168 . 43 . 138 : icmp_seq= 2 ttl= 64 time= 132 ms ^c  ping 192.168.43.138 ping 192.168.43.138 (192.168.43.138) 56(84) bytes of data. 64 bytes from 192.168.43.138: icmp_seq=1 ttl=64 time=8.75 ms 64 bytes from 192.168.43.138: icmp_seq=2 ttl=64 time=132 ms ^c  ping 192.168.43.138 ping 192.168.43.138 (192.168.43.138) 56(84) bytes of data. 64 bytes from 192.168.43.138: icmp_seq=1 ttl=64 time=8.75 ms 64 bytes from 192.168.43.138: icmp_seq=2 ttl=64 time=132 ms ^c run ros2 on 2 machines now its very simple. all you have to do is to start some nodes in machine 1, some other nodes in machine 2, and they will all be able to communicate through topics, services and actions. just like they were all in the same machine. machine 1: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  source /opt/ros/your_ros2_distribution/setup. bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp talker  source /opt/ros/your_ros2_distribution/setup.bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp talker  source /opt/ros/your_ros2_distribution/setup.bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp talker machine 2: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  source /opt/ros/your_ros2_distribution/setup. bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp listener  source /opt/ros/your_ros2_distribution/setup.bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp listener  source /opt/ros/your_ros2_distribution/setup.bash # you can put that line into your ~/.bashrc  ros2 run demo_nodes_cpp listener and you should see logs on both machines! if you want to communicate with a third/fourth/ machine, simply follow the network configuration steps again, and youll be all set. use ros_domain_id to run multiple (separate) ros2 applications on the same network so, after youve configured the machines to be in the same network, they are all part of the same ros2 application. this can be a problem: what if you want to run 2 different ros2 applications on the same network and on multiple machines? here you might want to completely separate the applications from each other. well, thats possible, you just need to set one environment variable before you start your nodes. before you start any node in one session (= one terminal), you need to export a new environment variable, named ros_domain_id, using a number for the value (preferably a low number, between 1 and 232). then, only the nodes started in sessions with the same ros_domain_id will be able to communicate with each other. example: machine 1  session (terminal) a: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  export ros_domain_id= 5  source /opt/ros/your_ros2_distribution/setup. bash  ros2 run demo_nodes_cpp talker  export ros_domain_id=5  source /opt/ros/your_ros2_distribution/setup.bash  ros2 run demo_nodes_cpp talker  export ros_domain_id=5  source /opt/ros/your_ros2_distribution/setup.bash  ros2 run demo_nodes_cpp talker machine 2  session (terminal) b: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  export ros_domain_id= 5  source /opt/ros/your_ros2_distribution/setup. bash  ros2 run demo_nodes_cpp listener  export ros_domain_id=5  source /opt/ros/your_ros2_distribution/setup.bash  ros2 run demo_nodes_cpp listener  export ros_domain_id=5  source /opt/ros/your_ros2_distribution/setup.bash  ros2 run demo_nodes_cpp listener try to set a different ros_domain_id (or dont set one at all) on machine 2  session b, and youll see that the communication wont work. now, you can have any number of configuration: here you have 4 different machines, each starting one session. this is a classic example of what you can setup in real life. in the future, make sure you dont forget the ros_domain_id. if you know that all your sessions inside one machine will be used for the same application, you can add export ros_domain_id=xx export ros_domain_id=xx to your ~/.bashrc. but you can also run multiple ros2 applications on just 2 machines! whats important is to understand that the ros_domain_id configuration is working at the session level, not the machine level  because its an environment variable. ros2 multi-machine with raspberry pi running ros2 across multiple machines is especially useful when you have a robot powered by a raspberry pi board, or any kind of embedded computer suitable for ros2 (ex: jetson nano). setting up your pi for multi-machines communication is the same as setting up any other computer/laptop. so, here is just an additional tip/best practice to keep in mind whenever you need to work with a robot powered by a raspberry pi. if you want to make some experiments, or work with the robot simulation on the side, or do some heavy computing, etc., here is what you can do: on your raspberry pi, just install the core packages, and run only the core nodes of your applications, which are responsible for talking to the hardware. then, on your other (remote) computer, start any simulation tool such as rviz, gazebo. start your heavy nodes such as motion planning, etc. this is a great way to minimize the cpu and ram use on your pi, and also to speed up your development time. all in all, multiple machine communication is a really powerful ros2 functionality. with ros2 you can build a complete distributed system, not only on the software side, but also on the hardware side. want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here