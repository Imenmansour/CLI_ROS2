building ros 2 snaps with colcon by kyle fazzari on 28 february 2019 please note that this  post has out technical information that may no longer be correct. for latest updated documentation  robotics in canonical please visit https://ubuntu.com/robotics/docs . the snapcraft cli has supported building ros1 snaps for a while via the catkin plugin. we supported the ros2 betas via the ament plugin, but that was before open robotics had a ros2 package repository setup, which meant that the ament plugin built the ros2 underlay from source, and it was predictably dreadfully slow. however, the stable releases of ros2 introduced a new build system called colcon , and also had their own package repositories setup. version 3.2 of the snapcraft cli (just released today) sees the addition of a colcon plugin to support those new releases, and id like to give you a quick run-through of its capabilities. prerequisites in order to follow along, make sure you have at least v3.2 of the snapcraft cli. the best way to do that is to install the snap:  sudo snap install --classic snapcraft some previous experience building a snap will also be helpful. lets get started create the snapcraft.yaml first of all, create a new directory and initialize it with a snapcraft.yaml : ~ mkdir ros2-snap ~ cd ros2-snap/ ~/ros2-snap snapcraft init created snap/snapcraft.yaml. go to https://docs.snapcraft.io/the-snapcraft-format/8337 for more information  the snapcraft.yaml format. open that snap/snapcraft.yaml file, and make it look like this: name: ros2-talker-listener version: "0.1" summary: ros2 talker/listener example description: | this example launches a ros2 talker and listener. grade: devel confinement: strict base: core18 parts: ros-demos: plugin: colcon source: https://github.com/ros2/demos.git source-branch: crystal colcon-rosdistro: crystal colcon-source-space: demo_nodes_cpp build-packages: [make, gcc, g++] stage-packages: [ros-crystal-ros2launch] apps: run: command: opt/ros/crystal/bin/ros2 launch demo_nodes_cpp talker_listener.launch.py plugs: [network, network-bind] lets break that down and go through it by section. name: ros2-talker-listener version: "0.1" summary: ros2 talker/listener example description: | this example launches a ros2 talker and listener. this is the basic metadata required by all snaps. these fields are fairly self-explanatory, but note that the name must be globally unique among all snaps. you might consider appending your developer name to the end of the snap name, for example. grade: devel confinement: strict base: core18 grade can be either stable or devel . if its devel , the store will prevent you from releasing into one of the two stable channels ( stable and candidate , specifically). if its stable , you can release it anywhere. confinement can be strict , devmode , or classic . strict enforces confinement, whereas devmode allows all accesses, even those that would be disallowed under strict confinement, and logs access that would be disallowed. classic is even less confined than devmode in that it doesnt even get private namespaces anymore (among other things). there is more extensive documentation on confinement available. as ive said in the past, i typically use strict confinement unless i know for sure that the thing im snapping wont run successfully under confinement, in which case ill use devmode. i typically avoid classic unless i never intend for the snap to run confined (e.g. youll notice the snapcraft cli is a classic snap, since it needs more access to the host than confinement would allow). finally, the base keyword specifies a special kind of snap that provides a minimal set of libraries common to most applications (e.g. libc). it will be the root filesystem for this snap. in this case, were using core18 which is a minimal rootfs based upon ubuntu bionic (18.04). parts: ros-demos: plugin: colcon source: https://github.com/ros2/demos.git source-branch: crystal colcon-rosdistro: crystal colcon-source-space: demo_nodes_cpp build-packages: [make, gcc, g++] stage-packages: [ros-crystal-ros2launch] the snapcraft cli is responsible for taking many disparate parts and orchestrating them all into one cohesive snap. you tell it the parts that make up your snap, and it takes care of the rest. here, were saying that we have a single part called ros-demos . we specify that it builds using the colcon plugin, and we point it to the ros2 demos github repository (this could just as easily be a directory on disk). we also specify that were using the newest ros2 release as of this writing: crystal. we point the colcon plugin at the c++ demo nodes specifically. we also provide a list of packages that need to be installed in order to build ( build-packages ), and also ask that ros-crystal-ros2launch gets staged into the snap alongside the rest of the part to be used at runtime (specifically, well use it in the app, below). to view all the options supported by the colcon plugin, run the command snapcraft help colcon . apps: run: command: opt/ros/crystal/bin/ros2 launch demo_nodes_cpp talker_listener.launch.py plugs: [network, network-bind] this part is interesting. when we build this snap, it will include a complete ros2 system: rclcpp, the demo_nodes_cpp workspace, etc. it could contain the entire system necessary for a robot in one installable blob. its a standalone unit: were in total control of how we want our users to interact with it. we exercise that control via the apps keyword, where we expose specific commands to the user. here we specify that this snap has a single app called run . the command that this app actually runs within the snap uses the ros-crystal-ros2launch that we staged to fire up the demo nodes talker/listener launch file. finally, we use plugs to specify that this app requires network access ( read more  interfaces ). build the snap now that weve defined the snapcraft.yaml , its time to build the snap. make sure youre in the directory we created earlier (the one that contained the snap/ directory), and run snapcraft : ~ cd ros2-snap/ ~/ros2-snap snapcraft <snip> snapped ros2-talker-listener_0.1_amd64.snap note that depending on your host and whether or not youve built snaps in the past, the snapcraft cli may prompt you to install multipass, a tool used by the snapcraft cli to manage vms for building snaps. the build process will take a few minutes. youll see the snapcraft cli fetch rosdep , which is then used to determine the dependencies of the packages in the colcon workspace. it then pulls those down and unpacks them into the snap, and finally builds the packages in the workspace and installs them into the snap as well. at the end, youll have your snap. test the snap lets install the snap we just built: ~/ros2-snap sudo snap install --dangerous ros2-talker-listener_0.1_amd64.snap ros2-talker-listener 0.1 installed note the use of the dangerous flag. thats required because were installing a snap from disk instead of using the store, and snapd (the daemon with which were communicating using the snap command) only trusts snaps that it can cryptographically verify as being from the store unless we tell it otherwise with this flag. finally, lets run the app we defined in the snapcraft.yaml :  ros2-talker-listener.run [info] [launch]: process[talker-1]: started with pid [26273] [info] [launch]: process[listener-2]: started with pid [26274] [info] [talker]: publishing: 'hello world: 1' [info] [listener]: i heard: [hello world: 1] [info] [talker]: publishing: 'hello world: 2' [info] [listener]: i heard: [hello world: 2] as you can see, it works great. you could hand this snap to anyone with a snap-capable system, even if they dont have ros installed, and it would work exactly the same way for them. i hope this gives you a decent overview of the capabilities of the colcon plugin, and i look forward to seeing what you do with it! please feel free to ask any questions here, on the snapcraft forums , or on the ros forums . id love to hear any feedback you have. this article originally appeared on kyle fazzaris  . newsletter  email:* i agree to receive information  canonicals products and services. in submitting this form, i confirm that i have read and agree to canonical's  policy subscribe now related posts managing software in complex network environments: the snap store proxy as enterprises grapple with the evolving landscape of security threats, the need to safeguard internal networks from the broader internet is increasingly important. in environments with restricted internet access, it can be difficult to manage software updates in an easy, reliable way. when managing devices in the field, change management [] improving snap maintenance with automation co-written with sergio costas rodr√≠guez. as the number of snaps increases, the need for automation grows. any automation to help us maintain a group of snaps is welcome and necessary for us to be able to scale. the solution detailed in this article has two main benefits: any users of snaps that have adopted this [] snapcraft 8.0 and the respectable end of core18 es not pinin! es passed on! this base is no more! he has ceased to be! es expired and gone to meet is maker! es a stiff! bereft of life, e rests in peace! if you hadnt nailed im to the perch ed be pushing up the daisies! is software processes are now istory! es []