introduction to ros2 humble and gazebo fortress 2023-12-17 1869 words 9 minutes ros gazebo simulation english marie floissac--duforez ros 2 humble is the eighth release of ros 2, which is a set of software libraries and tools for building robot applications. ros, in its various iterations or distributions, is regularly released, with multiple distros supported at the same time, although they do not all have the same lifetimes. fun fact, those new distributions are generally released on world turtle day , since their symbols are always turtles or tortoises. as for gazebo, it is a 3d simulator that can be used to simulate robots and their environments. it is a powerful tool that can be used to test and debug robot software, as well as to train robots. it has been developed with the desire to support ros instructions, in order to properly test features before using expensive material. in this tutorial, ill explain the basics needed to be able to discuss back and forth between gazebo and ros node. at the time of the creation of this article, the only 2 non-deprecated versions of ros2 are humble, which comes with long term support (lts) and will be supported up to may 2027, and iron, set to be deprecated in november 2024. to keep this article relevant for as long as possible, this article will only be focusing on ros2 humble. prerequites the target audience of this article is curious beginners at ros that would like a simple introduction to the workings of gazebo ! the only basis needed in order to understand this tutorial is to have a basic understanding of ros nodes and topic/subscribers, as well as basic coding vocabulary. ill explain as much as i deem necessary, however if anything still seems too abstract, i recommend turning towards the documentation . no previous experience with gazebo is needed. this tutorial was tested on ubuntu 22.04, since this is one of the os supported by humble. please check the following link to verify which installation method matches your os. here are the links towards the download of both ros2 humble and gazebo fortress used in this tutorial. warning installing ros humble on an os that precedes 22.04 could take several hours, so please plan accordingly if you dont already have it installed. main tutorial first steps gazebo uses the sdformat to describe what scenes and robots are supposed to look like. since this tutorial focuses on the use of ros to discuss with the simulation, we will not be discussing how to create a new project from scratch. instead, we will use a preexisting one, included with the installation of ign_gazebo: 1 ign gazebo visualize_lidar.sdf in another terminal, you can now check which topics have been provided with the command 1 ign topic -l you should have something along the lines of : /clock /gazebo/resource_paths /gui/camera/pose /lidar /lidar/points /lidar2 /lidar2/points /model/vehicle_blue/odometry /model/vehicle_blue/tf /sensors/marker /stats /world/visualize_lidar_world/clock /world/visualize_lidar_world/dynamic_pose/info /world/visualize_lidar_world/pose/info /world/visualize_lidar_world/scene/deletion /world/visualize_lidar_world/scene/info /world/visualize_lidar_world/state /world/visualize_lidar_world/stats now, lets try and create a bridge between gazebo and ros ! open a discussion the first well do is to establish a discussion between gazebo and ros, by checking if you can catch events happening in the simulation. to do that, well need ros_ign_bridge , which is a bridge that enables messages to go between the two. here is the pattern : ros2 run ros_ign_bridge parameter_bridge /topic@ros_msg@ign_msg the ros2 run ros_ign_bridge parameter_bridge command is used to execute the parameter_bridge code provided by the ros_ign_bridge package. when using this command, the /topic parameter specifies the target topic for message exchange. the @ symbol is employed to separate the topic name from the message types. after the first @ symbol, youll find the ros message type. the ros message type is then followed by either @ (indicating a bidirectional bridge), [ (indicating a bridge from ignition to ros), ] (indicating a bridge from ros to ignition). these symbols denote the direction of message transfer between ros and ignition. %%{init: {'theme':'dark'}}%% graph tb subgraph gazebo a[[ign gazebo]] --> b([ign topics]) end subgraph bridge c[[ros_ign_bridge]] -.- d{{parameter_bridge}} end subgraph ros2 f[[humble]] --> g([ros2 topics]) end b <-- gazebo_type --> d g <-- ros_type --> d a ~~~ c f ~~~ c tip youll have to open different terminals to be able to run commands simultaneously, so if you arent already doing it, dont forget to source ros ! i made myself an alias in my .bashrc file in order to make this cleaner (if you want to use it as well, change the path beforehand as it may differ on your machine): alias ros_setup=source /opt/ros/humble/setup.bash now lets try to catch the camera movements ! this should do the trick : 1 ros2 run ros_gz_bridge parameter_bridge /gui/camera/pose@geometry_msgs/msg/pose [ ignition.msgs.pose to dissect it a little bit, you can see that well publish on the topic /gui/camera/pose . the position type is referred to as geometry_msgs/msg/pose for ros, and ignition.msgs.pose for gazebo. just to make sure that everything went well, we should check that the topic exists ! in a new terminal, write the following to see all current topics (dont forget to source :p): > ros2 topic list /gui/camera/pose /parameter_events /rosout there it is ! now, in order to catch those messages, lets open up the topic : 1 ros2 topic echo /gui/camera/pose move around a bit, and congrats ! you can see the messages  what you are doing :) you will receive a lot of them, so you can just ctrl-c both terminals, since youll be running more commands in the following paragraph. simple movement now that you have an example of a gazebo -> ros discussion, lets do it the other way around ! in the simulation you launched, there is a little blue car (it might look a bit grey on certain computers). lets try and make it move a bit. you can use the same terminals as the previous part : 1 ros2 run ros_gz_bridge parameter_bridge /model/vehicle_blue/cmd_vel@geometry_msgs/msg/twist ] ignition.msgs.twist to dissect it again, here is what is happening. the topic is now /model/vehicle_blue/cmd_vel , with the message type being twist for both ros and gazebo. a twist is a geometry message that represents a movement in a 3d free space. it has two components : linear velocity: a 3d vector that represents the velocity of the object in the x, y, and z directions. angular velocity: a 3d vector that represents the angular velocity of the object around the x, y, and z axes and now, lets make that little car move ! in your ros terminal, write : 1 ros2 topic pub /model/vehicle_blue/cmd_vel geometry_msgs/twist "linear: { x: 0.1 }" instead of echoing the messages on the topic, what well do here is publish ( pub ) a message. we just want it to go forward, so increasing the x value of the linear velocity is perfect ! this should send it forward ! note the provided robot is restrained in its movements, and is not able to move up and down or left to right, however it is able to rotate sideways ;) angular: { x: 0, y: 0, z: 0.1 } debug examples lets end this article with a few tips on how to debug (or simply understand a little bit more) what is going on in your simulation ! the main advice i would give you would be to launch your work with the -v flag: 1 ign gazebo -v 4 -r visualize_lidar.sdf note the -v option is used to set the verbosity level of the gazebo simulator. the verbosity level determines how much information is printed to the console. the possible verbosity levels are: 0: fatal errors only 1: errors and warnings (default verbosity) 2: information messages 3: debug messages 4: trace messages each verbosity level includes the messages of all its predecessors. the -r option is used to specify the world file to load. although if you want to get really into the inner workings of your work, there is another way of doing it : ign gazebo uses command line tools based on ruby. the easiest way to debug them would be to use gdb, which means running it against the ruby executable. tip some useful links in case you arent familiar (or a bit rusty) with gdb : https://www.tutorialspoint.com/gnu_debugger/gdb_commands.htm https://ftp.gnu.org/old-gnu/manuals/gdb-5.1.1/html_chapter/gdb_4.html https://visualgdb.com/gdbreference/commands/ there are two different types of debugging that you could do with gazebo: either server or gui . server debugging is the most useful of the two for your current level, as it is can be used to understand why your robot is not behaving the way you expected it, or where do the errors you see come from. gui debugging is a bit more complicated, as it can help understand why it is not responding to your input (for example, buttons may not be working or the viewport may not be updating). ill explain below how to do both of them. in both cases, the first step would be to find the ign executable : 1 which ign this resulted in usr/bin/ign for me, dont forget to change it if this differs on your machine. server debugging the first step is to run gdb with ruby : 1 gdb ruby then, you can just run the gazebo server as normal. just dont forget to use the -s argument. 1 ( gdb ) r /usr/bin/ign gazebo -s visualize_lidar.sdf note the -s argument specifies the simulation mode, it can be used 3 ways : -s headless, which runs the simulation without the gui -s gui, the default mode -s none, allowing you to load and inspect a world without running the simulation (our current situation) youll be able to use gdb as usual right after ! gui debugging similarly, the first step is to run gdb with ruby : 1 gdb ruby then run the gui : 1 ( gdb ) r /usr/bin/ign gazebo note you may want to add the -g option to set the default gravity in another terminal, you can just launch the server like before : 1 ign gazebo -s -v 4 -r visualize_lidar.sdf and you can just use gdb as usual ! to go further since this was simply an entry point to the world gazebo ignition and ros humble have to offer, there are a lot more things that can be done to improve your understanding ! for instance, no examples of ros nodes were made in this tutorial, we simply listened on the topic or published directly to it. try and make your own node to listen on the cameras position, or publish a command to the car ! as for gazebo, working in a premade world would be very limiting, especially if you want to try and make your own project. if you wish to deepen your understanding of gazebo, you can try following this tutorial on how to create your own server and robot ! conclusion i hope to have explained enough of the interactions between ros and gazebo for you to have a base to hold onto when you try your own project! these tools can prove to be very frustrating to work with, however they most definitely are very satisfying when you finally understand them! thank you for your time and good luck in your future endeavors ;) useful resources https://www.ros.org/ https://docs.ros.org/en/humble/how-to-guides.html https://docs.ros.org/en/humble/tutorials.html https://gazebosim.org/docs/fortress/getstarted https://www.allisonthackston.com/articles/ignition-vs-gazebo.html