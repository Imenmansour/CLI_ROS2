skip to content in this tutorial ill show you a ros2 python launch file example and well build it step by step. when you start to have a few nodes in your ros2 application, it quickly becomes not-so-practical to start each node  with its own configuration  manually in a different terminal. with a launch file you can write all the nodes with a complete configuration (remapping, parameters, etc.) in a single file, that you can launch with only one command line. first well start with a simple launch file to start 2 nodes. youll see the entire process to create, write, install, and start the launch file. and after that ill show you how you can add more levels of customization to your nodes. >> watch this video as an additional resource to this article: after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. table of contents toggle where to create your launch files? well, technically you could create a launch file anywhere, in any package you want. however well stick to a few rules here. if you want to create a launch file in an existing package (whether a python package or cpp package ), then create a launch/ folder at the root of this package. put all launch files in this new folder. this first technique makes sense when you release a package along with a launch file specific to that package, for example. but, if you want to create launch files for your entire application (with multiple packages), then a best practice is to create a new ros2 package dedicated to launching your app, and which will contain launch files, config files, etc. thats what well do here. go to your ros2 workspace and create a new package named my_robot_bringup, with no build type (default will be ament_cmake) and no dependency. of course replace the my_robot part with the name of your actual robot/hardware component. if you look as some existing ros2 stacks from other robots (on github for example), youll see that doing this has become quite a convention in the ros community. in this new package, remove the src/ and include/ folders. create a new launch/ folder, and create your first launch file inside. lets name it demo.launch.py. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter cd ~/ros2_ws/src ros2 pkg create my_robot_bringup cd my_robot_bringup/ rm -rf include/ rm -rf src/ mkdir launch touch launch/demo.launch.py cd ~/ros2_ws/src ros2 pkg create my_robot_bringup cd my_robot_bringup/ rm -rf include/ rm -rf src/ mkdir launch touch launch/demo.launch.py cd ~/ros2_ws/src ros2 pkg create my_robot_bringup cd my_robot_bringup/ rm -rf include/ rm -rf src/ mkdir launch touch launch/demo.launch.py write your first ros2 python launch file as you can see the launch file we created (demo.launch.py) is a python file. you can use xml (or even yaml) instead if you want to. here well simply start the talker/listener example from the official ros2 demos. the talker will publish on the /chatter topic, and the listener will subscribe to that topic. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from launch import launchdescription from launch_ros.actions import node def generate_launch_description () : ld = launchdescription () talker_node = node ( package= "demo_nodes_cpp" , executable= "talker" , ) listener_node = node ( package= "demo_nodes_py" , executable= "listener" ) ld. add_action ( talker_node ) ld. add_action ( listener_node ) return ld from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): ld = launchdescription() talker_node = node( package="demo_nodes_cpp", executable="talker", ) listener_node = node( package="demo_nodes_py", executable="listener" ) ld.add_action(talker_node) ld.add_action(listener_node) return ld from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): ld = launchdescription() talker_node = node( package="demo_nodes_cpp", executable="talker", ) listener_node = node( package="demo_nodes_py", executable="listener" ) ld.add_action(talker_node) ld.add_action(listener_node) return ld lets break this down line by line. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from launch import launchdescription from launch_ros.actions import node from launch import launchdescription from launch_ros.actions import node from launch import launchdescription from launch_ros.actions import node first you import what you need for this launch file, from the launch and launch_ros modules. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter def generate_launch_description () : ld = launchdescription () def generate_launch_description(): ld = launchdescription() def generate_launch_description(): ld = launchdescription() your launch file must contain this function: generate_launch_description(), and must return a launchdescription object. no main function here. you wont run this file directly, youll first install it. and when you install the launch file, colcon will expect to find generate_launch_description(). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter talker_node = node ( package= "demo_nodes_cpp" , executable= "talker" , ) listener_node = node ( package= "demo_nodes_py" , executable= "listener" ) talker_node = node( package="demo_nodes_cpp", executable="talker", ) listener_node = node( package="demo_nodes_py", executable="listener" ) talker_node = node( package="demo_nodes_cpp", executable="talker", ) listener_node = node( package="demo_nodes_py", executable="listener" ) inside the function you can now create your nodes. this is the bare minimum you have to write for a node: you specify the package name and executable name. well see later on this tutorial how you can add more customization to your nodes. as you can see here, were using nodes from 2 different packages. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ld. add_action ( talker_node ) ld. add_action ( listener_node ) ld.add_action(talker_node) ld.add_action(listener_node) ld.add_action(talker_node) ld.add_action(listener_node) once youve create launch_ros.actions.node object for each node you want to start, dont forget to add them to the launchdescription with the add_action() function. or else they wont be started. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter return ld return ld return ld finally, and this will be the last line of your launch file, return the launchdescription object, which now contains all nodes to launch. install the ros2 python launch file add dependencies in this example, we are starting nodes from demo_nodes_cpp and demo_nodes_py packages. as those are different packages than the one were using for the launch file, we need to add some dependencies. nothing complicated here, just go to the package.xml of the package where youve written your launch file, and add an exec_depend tag for each dependency. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... < exec _depend > demo_nodes_cpp</exec_depend> < exec _depend > demo_nodes_py</exec_depend> ... ... <exec_depend>demo_nodes_cpp</exec_depend> <exec_depend>demo_nodes_py</exec_depend> ... ... <exec_depend>demo_nodes_cpp</exec_depend> <exec_depend>demo_nodes_py</exec_depend> ... if, later on, you add new nodes from other packages in your launch file, dont forget to add the dependencies as well. install from a cpp package so, if you create your launch files into an existing cpp package, or into a dedicated package with default build type (here my_robot_bringup), the way to install launch files will be the same. go into the cmakelists.txt of your package, and after find_package(ament_cmake required) find_package(ament_cmake required) , add: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... install(directory launch destination share/{project_name} ) ... ... install(directory launch destination share/{project_name} ) ... ... install(directory launch destination share/{project_name} ) ... this will install all launch files from under the launch/ folder of your package. once its done once, you dont need to do anything else for other launch files you add. now, go back into your ros2 workspace and build the package with colcon build colcon build . install from a python package in the case where youve created your launch file inside a python package, well, things are a little bit different. you dont have a cmakelists.txt file, instead you have setup.py. open setup.py and add this: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from setuptools import setup import os from glob import glob ... data_files= [ ... ( os.path. join ( 'share' , package_name ) , glob ( 'launch/*.launch.py' )) ] , ... from setuptools import setup import os from glob import glob ... data_files=[ ... (os.path.join('share', package_name), glob('launch/*.launch.py')) ], ... from setuptools import setup import os from glob import glob ... data_files=[ ... (os.path.join('share', package_name), glob('launch/*.launch.py')) ], ... this will do the same thing as for the previous instruction with a cpp package: install the launch files from the launch/ folder. here weve added one more condition: only files ending with .launch.py will be installed. save, and go back to your ros2 workspace to build with colcon build colcon build . run the ros2 python launch file now that you have written and installed your launch file, its now ready to be launched! and to do that, youll use the ros2 launch ros2 launch command line tool. this command will take 2 arguments: name of the package + name of the launch file. first, go into another terminal and source your ros2 workspace. then: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 launch ros2_tutorials_py demo.launch.py [info] [launch]: all log files can be found below /home/ed/.ros/log/ 2020 - 07 - 03 - 08 - 51 - 07 - 071225 -ed-vm- 10382 [info] [launch]: default logging verbosity is set to info [info] [talker- 1 ]: process started with pid [ 10384 ] [info] [listener- 2 ]: process started with pid [ 10386 ] [talker- 1 ] [info] [1593759068. 181805900 ] [talker]: publishing: 'hello world: 1' [listener- 2 ] [info] [1593759068. 198144751 ] [listener]: i heard: [hello world: 1 ] [talker- 1 ] [info] [1593759069. 181186103 ] [talker]: publishing: 'hello world: 2' [listener- 2 ] [info] [1593759069. 185819615 ] [listener]: i heard: [hello world: 2 ]  ros2 launch ros2_tutorials_py demo.launch.py [info] [launch]: all log files can be found below /home/ed/.ros/log/2020-07-03-08-51-07-071225-ed-vm-10382 [info] [launch]: default logging verbosity is set to info [info] [talker-1]: process started with pid [10384] [info] [listener-2]: process started with pid [10386] [talker-1] [info] [1593759068.181805900] [talker]: publishing: 'hello world: 1' [listener-2] [info] [1593759068.198144751] [listener]: i heard: [hello world: 1] [talker-1] [info] [1593759069.181186103] [talker]: publishing: 'hello world: 2' [listener-2] [info] [1593759069.185819615] [listener]: i heard: [hello world: 2]  ros2 launch ros2_tutorials_py demo.launch.py [info] [launch]: all log files can be found below /home/ed/.ros/log/2020-07-03-08-51-07-071225-ed-vm-10382 [info] [launch]: default logging verbosity is set to info [info] [talker-1]: process started with pid [10384] [info] [listener-2]: process started with pid [10386] [talker-1] [info] [1593759068.181805900] [talker]: publishing: 'hello world: 1' [listener-2] [info] [1593759068.198144751] [listener]: i heard: [hello world: 1] [talker-1] [info] [1593759069.181186103] [talker]: publishing: 'hello world: 2' [listener-2] [info] [1593759069.185819615] [listener]: i heard: [hello world: 2] each executable will get a unique name (talker-1 for node talker, listener-2 for node listener), and you can also see their pid. then, all the logs from all nodes will be printed in this terminal. if you have many nodes this may result in a total log mess, so you may have to optimize which log to print or not to make your app easier to debug. and, well, thats it: all the nodes youve added in your launch file are running, until you press ctrl+c. now, lets see how we can customize those nodes inside the launch file. customize your nodes in ros2 python launch files there are many things you can do, here ill focus on some of the most common ones. rename node you may want to rename your node, for example if you want to start 2 different nodes from the same executable. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... talker_node = node ( package= "demo_nodes_cpp" , executable= "talker" , name= "my_talker" ) ... ... talker_node = node( package="demo_nodes_cpp", executable="talker", name="my_talker" ) ... ... talker_node = node( package="demo_nodes_cpp", executable="talker", name="my_talker" ) ... topic/service remapping to remap a topic/service inside a node, add a remappings[] array inside the node object, and add a tuple: first value is the current name, second value is the new name. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... talker_node = node ( package= "demo_nodes_cpp" , executable= "talker" , name= "my_talker" , remappings= [ ( "chatter" , "my_chatter" ) ] ) listener_node = node ( package= "demo_nodes_py" , executable= "listener" , remappings= [ ( "chatter" , "my_chatter" ) ] ) ... ... talker_node = node( package="demo_nodes_cpp", executable="talker", name="my_talker", remappings=[ ("chatter", "my_chatter") ] ) listener_node = node( package="demo_nodes_py", executable="listener", remappings=[ ("chatter", "my_chatter") ] ) ... ... talker_node = node( package="demo_nodes_cpp", executable="talker", name="my_talker", remappings=[ ("chatter", "my_chatter") ] ) listener_node = node( package="demo_nodes_py", executable="listener", remappings=[ ("chatter", "my_chatter") ] ) ... in this case, as we want the talker and listener nodes to be able to communicate, of course we have to rename the topic on both sides. to add more remappings, simply add other tuples inside the remappings[] array. parameters here well launch the turtlesim node from the turtlesim package (if you dont have it: sudo apt install ros-<distro>-turtlesim sudo apt install ros-<distro>-turtlesim ) what we want is simply to start the turtlesim node, but with a different background color (light grey instead of blue). so well need to set some parameters values. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter from launch import launchdescription from launch_ros.actions import node def generate_launch_description () : ld = launchdescription () turtlesim_node = node ( package= "turtlesim" , executable= "turtlesim_node" , parameters= [ { "background_b" : 200 } , { "background_g" : 200 } , { "background_r" : 200 } ] ) ld. add_action ( turtlesim_node ) return ld from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): ld = launchdescription() turtlesim_node = node( package="turtlesim", executable="turtlesim_node", parameters=[ {"background_b": 200}, {"background_g": 200}, {"background_r": 200} ] ) ld.add_action(turtlesim_node) return ld from launch import launchdescription from launch_ros.actions import node def generate_launch_description(): ld = launchdescription() turtlesim_node = node( package="turtlesim", executable="turtlesim_node", parameters=[ {"background_b": 200}, {"background_g": 200}, {"background_r": 200} ] ) ld.add_action(turtlesim_node) return ld to add parameters, create a parameters[] array inside the node. for each parameter you want to set, add a new dictionary: key is the parameters name, value is the parameters value. note: with this launch file youll have to add a new line to your package.xml: <exec_depend>turtlesim</exec_depend> <exec_depend>turtlesim</exec_depend> . to set parameters in a launch file you can either set them directly like we did here, or load them from a yaml config file , which may be more scalable when you start to have many parameters. conclusion in this tutorial youve seen how to create, write, install, and start a ros2 python launch file. each node you start from a launch file can be fully customized. launch files will make your application much more scalable. you will be able to write each node as a module, and then combine everything together, with any configuration you want, inside only one file. want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here