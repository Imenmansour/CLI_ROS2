how to use ros 2 parameters configure your ros nodes at startup to customize their behavior josé l. millán  12 min read published september 26, 2022 in our previous posts, we've talked  how ros 2 nodes can leverage different ways of communicating with each other. they can use topics to publish continuous communication streams, or use services and actions to make individual requests. ros 2 parameters are slightly different from these concepts  rather than being a way for nodes to communicate, they are a way to configure your nodes so that they can have slightly different behaviors when they launch in different contexts. in this tutorial, we will cover when and why you would use ros 2 parameters  as well as how you can read and set parameter values using both yaml configuration files and cli commands. how ros 2 parameters work ros 2 nodes first declare the parameters they can accept (1), then read the parameter values passed to them during startup  via the command line interface (2) or a yaml configuration file (3)  to determine their behavior. parameters can be integers, floating point numbers, booleans, string, or arrays of the previous types. by setting different parameter values in different contexts, a node can modify its behavior to work in various scenarios. for example, a node that controls a robot's speed can be configured with different speed limits, depending on whether the robot will be deployed. when to use ros 2 parameters lets suppose you have two identical robots in two different warehouses. while their general responsibilities are the same  i.e. locating, loading, and moving inventory  these robots will have different names, move at different speeds, and navigate through different sets of waypoints. by using ros 2 parameters, you can modify each robots internal variables to differentiate their behavior based on their home warehouse. for this tutorial, lets assume robota will be in warehouse a and go back and forth in a corridor at a max speed of 1.4 m/s. robotb will be in warehouse b and navigate a more complicated set of waypoints at a max speed of 5.6 m/s. to differentiate how our robots behave, we will define three parameters for them to read at startup  robot_name , max_speed and waypoints . creating a node with ros 2 parameters lets create our node, define its parameters, and read the parameters' values from the command line interface. start by creating a new package in your ros 2 workspace:  cd ros2_ws/src  ros2 pkg create params_pkg --dependencies rclcpp in the src/ folder of your package, create a new robot_node.cpp file with the following dependencies: // standard c++ api for interacting with ros 2 # include <rclcpp/rclcpp.hpp> // useful namespace for durations using namespace std :: chrono_literals ; declare a new robotnode class that inherits from node and contains our parameter values as its private attributes: class robotnode : public rclcpp :: node { private : // declare the node's private attributes std :: string robot_name_ ; float max_speed_ ; std :: vector < std :: string > waypoints_ ; next, add a constructor that defines your robot_name , max_speed and waypoints parameters: public : // initialize class robotnode ( const std :: string & name ) : node ( name ) { // declare parameters declare_parameter ( "robot_name" , "" ) ; // defaults to "" declare_parameter ( "max_speed" , 0.0 ) ; // defaults to 0.0 declare_parameter ( "waypoints" ) ; // no default value once the node declares the parameters, it is ready to read them: // now, we can read the parameters get_parameter ( "robot_name" , robot_name_ ) ; get_parameter ( "max_speed" , max_speed_ ) ; get_parameter ( "waypoints" , waypoints_ ) ; now that weve gotten the parameters and stored them in the class attributes, we can now check the values passed: // show the robot's attributes loaded with parameters rclcpp_info ( get_logger ( ) , "hi! i'm '%s'" , robot_name_ . c_str ( ) ) ; rclcpp_info ( get_logger ( ) , "my max speed is %.1f" , max_speed_ ) ; rclcpp_info ( get_logger ( ) , "i will follow the waypoints: " ) ; for ( unsigned int i = 0 ; i < waypoints_ . size ( ) ; i ++ ) { rclcpp_info ( get_logger ( ) , "%d) %s" , i + 1 , waypoints_ [ i ] . c_str ( ) ) ; } add a class destructor to avoid compilation problems: // destructor of the node ~ robotnode ( ) { rclcpp_info ( get_logger ( ) , "'%s' says bye!" , robot_name_ . c_str ( ) ) ; } } ; finally, create the main function to execute your node. int main ( int argc , char const * argv [ ] ) { rclcpp :: init ( argc , argv ) ; auto robot_node = std :: make_shared < robotnode > ( "robot_node" ) ; return 0 ; } modify your cmakelists.txt file to include your executable and install it in the projects lib folder: add_executable(robot_node src/robot_node.cpp) ament_target_dependencies(robot_node rclcpp) install(targets robot_node destination lib/{project_name}) compile the package with  colcon build and source your workspace. running your executable should give you the following output:  ros2 run params_pkg robot_node [ info ] [ 1662052019.811200279 ] [ robot_node ] : hi ! i 'm ' ' [ info ] [ 1662052019.811248058 ] [ robot_node ] : my max speed is 0.0 [ info ] [ 1662052019.811256235 ] [ robot_node ] : i will follow the waypoints: [ info ] [ 1662052019.811264074 ] [ robot_node ] : '' says bye ! to pass the parameters to the node during startup, we have to add them with the argument --ros-args -p <param>:=<value> . you can pass as many parameters as you like:  ros2 run params_pkg robot_node --ros-args -p robot_name: = robota -p max_speed: = 1.0 -p waypoints: = [ "home" ] [ info ] [ 1662052355.934808595 ] [ robot_node ] : hi ! i 'm ' robota ' [info] [1662052355.934874889] [robot_node]: my max speed is 1.0 [info] [1662052355.934885245] [robot_node]: i will follow the waypoints: [info] [1662052355.934889172] [robot_node]: 1) home [info] [1662052355.934895189] [robot_node]: ' robota' says bye ! we have successfully configured our node with three parameters! setting multiple parameter values with a yaml file now let's imagine that we want to pass many more parameters to our node. it may get tiresome passing these values one by one via the cli. to streamline this process, we can leverage yaml configuration files. a yaml configuration file contains the parameters and their values in an easy-to-read and -write format. a single yaml file can be used to configure multiple nodes, each with their parameters. lets create a warehousea.yaml file for our first robot: /robot_node : ros__parameters : robot_name : "robota" max_speed : 1.4 waypoints : [ "home" , "corridor" , "home" ] and a warehouseb.yaml file for our second robot: /robot_node : ros__parameters : robot_name : "robotb" max_speed : 5.6 waypoints : [ "home" , "room 1" , "room 2" , "corridor" , "home" ] store these yaml files in a newly created params/ folder in your package. lets try running our node with our new warehousea.yaml file:  ros2 run params_pkg robot_node --ros-args --params-file src/ros2_tutorials/params_pkg/params/warehousea.yaml [ info ] [ 1662053436.492847422 ] [ robot_node ] : hi ! i 'm ' robota ' [info] [1662053436.492900840] [robot_node]: my max speed is 1.4 [info] [1662053436.492913840] [robot_node]: i will follow the waypoints: [info] [1662053436.492919919] [robot_node]: 1) home [info] [1662053436.492926436] [robot_node]: 2) corridor [info] [1662053436.492935137] [robot_node]: 3) home [info] [1662053436.492944130] [robot_node]: ' robota' says bye ! running it with warehouseb.yaml should give you a slightly different output:  ros2 run params_pkg robot_node --ros-args --params-file src/ros2_tutorials/params_pkg/params/warehouseb.yaml [ info ] [ 1662053563.992857830 ] [ robot_node ] : hi ! i 'm ' robotb ' [info] [1662053563.992925219] [robot_node]: my max speed is 5.6 [info] [1662053563.992933833] [robot_node]: i will follow the waypoints: [info] [1662053563.992938301] [robot_node]: 1) home [info] [1662053563.992943552] [robot_node]: 2) room 1 [info] [1662053563.992947848] [robot_node]: 3) room 2 [info] [1662053563.992951743] [robot_node]: 4) corridor [info] [1662053563.992955688] [robot_node]: 5) home [info] [1662053563.992960346] [robot_node]: ' robotb' says bye ! we have successfully passed different parameters to the same node using yaml files! these configuration files make parameters much easier to modify and read. using cli commands ros 2 includes useful cli commands to manage parameters once the nodes have been started. lets see some of these commands in action. start by opening two terminals. in the first terminal, run our robot_node like before:  ros2 run params_pkg robot_node --ros-args --params-file src/ros2_tutorials/params_pkg/params/warehousea.yaml in the second terminal, get a list of declared parameters:  ros2 param list /robot_node: max_speed robot_name use_sim_time waypoints now that we know the parameter names, lets get the values:  ros2 param get /robot_node robot_name string value is: robota get all the parameters and store their values directly in a yaml file:  ros2 param dump /robot_node to change a parameter in a node that is already running, add a timer to your node that checks periodically for a new max_speed parameter value: class robotnode : public rclcpp :: node { private : . . . // define a timer for periodic check rclcpp :: timerbase :: sharedptr timer_ ; then create the timer in the constructor: // initializer of the class robotnode ( const std :: string & name ) : node ( name ) { . . . // create a periodic timer of 1 second timer_ = create_wall_timer ( 1 s , std :: bind ( & robotnode :: timercallback , this ) ) ; } finally, define a timercallback to check the parameter and print its new values: // timer function to show the changes in max_speed void timercallback ( ) { // store current max speed last_max_speed_ = max_speed_ ; // get the speed parameter again to check for changes get_parameter ( "max_speed" , max_speed_ ) ; // print new max speed if ( max_speed_ != last_max_speed_ ) { rclcpp_info ( get_logger ( ) , "my new max speed is %.1f" , max_speed_ ) ; } } dont forget to spin your node: int main ( int argc , char const * argv [ ] ) { . . . rclcpp :: spin ( robot_node ) ; // add this line return 0 ; } compile your code, and execute the node:  ros2 run params_pkg robot_node --ros-args --params-file src/ros2_tutorials/params_pkg/params/warehousea.yaml in another terminal, change the robot's max_speed to 2.0 :  ros2 param set /robot_node max_speed 2.0 youll see that your robot_node will receive the new max_speed and print it in the terminal. l: running robot_node with the original parameters. r: setting a new max_speed with ros2 param . summary ros 2 parameters make the same node work in different situations, making it possible to reuse your code to add capabilities. we hope this tutorial helped you better understand how you might use parameters in the larger scheme of your robots architecture. for a reference to all the code covered in this post, check out our foxglove/tutorials github repo . as always, feel free to reach out to the foxglove team in our discord community to ask questions, give us feedback, and request a topic for the next tutorial! share on twitter share on linkedin read more: tutorial ros how to use ros 1 parameters configure your ros nodes at startup to customize their behavior josé l. millán josé l. millán october 3, 2022  12 min read tutorial visualization building a custom react panel with foxglove extensions create project-specific visualization tools for your robotics team esther weon esther weon september 1, 2022  12 min read all  posts get  posts sent directly to your inbox. email address subscribe ready to try foxglove? get started for free