skip to main content on this page there are a few follow-up points regarding ros2_control for our differential drive robot that are worth sorting out before we move ahead with the rest of the tutorial series. i've kept these out of the main video to avoid further detracting from the core explanation of how to get ros2_control up and running. update urdf to match robot structure  the first step is to update your urdf to match your physical robot (if you have one). in my case i did the following: set up xacro parameters for all the key dimensions and set them accordingly changed my gazebo and rviz colours to match the real robot fixed up the controller yaml to have the correct wheel separation and radius added an extra xacro file for a smiley face on the front, like my real one currently has (it will eventually have a screen) you can check out the differences here . problem 1 - gazebo clock rate  at the end of the previous tutorial i mentioned that there are a few problems with the simulation. the first of these is that you'll notice the robot motion in rviz is quite "choppy" while driving the robot around. thats because the gazebo-ros clock is only running at 10hz, so the rest of ros gets locked to that slow speed. we need to tell gazebo to publish the clock faster. this isnt only a visual thing, its actually causing our odometry to drift quite badly (but dont check that now because there are other problems affecting it too which well fix soon). fixing the clock rate is a bit annoying. first we need to create another parameter file, a good name is gazebo_params.yaml . in it well put the following code, which is telling gazebo to publish the clock at 400hz instead of 10hz (if your computer is slow you may need to reduce this). gazebo : ros__parameters : publish_rate : 400.0 we now need gazebo to see these parameters when it starts up. in our launch_sim.launch.py we are "including" the ros-provided gazebo launch. this launch file has an argument called extra_gazebo_args which lets us just send whatever we want down to the gazebo it runs. in this case, we'll create a variable to store the path of our params file (similar to how we handled the urdf), and then combine that path into a string telling gazebo to read it. gazebo_params_path = os . path . join ( get_package_share_directory ( package_name ) , 'config' , 'gazebo_params.yaml' ) gazebo = includelaunchdescription ( pythonlaunchdescriptionsource ( [ os . path . join ( get_package_share_directory ( 'gazebo_ros' ) , 'launch' , 'gazebo.launch.py' ) ] ) , launch_arguments = { 'extra_gazebo_args' : '--ros-args --params-file ' + gazebo_params_path } . items ( ) ) note that future versions should let us pass the params file in directly as a launch argument, simplifying this process ever so slightly. if we rerun gazebo now well see that rviz is much smoother. on my computer i also get an error printed in the gazebo terminal which is a bit annoying, i think the gazebo command line parser is treating the file as an extra sdf to load and failing. we can just ignore it, but if youve got a fix then let me know! problem 2 - wheel drift  the next problem we have is wheel drift. the easiest way to spot this is to do a fresh start on gazebo/rviz, and do a full revolution of the robot. we should see that when we come back to the initial angle in gazebo, rviz is no longer in sync. there could be a few factors affecting this, but an easy one to tackle is that the wheel collision is a cylinder, which means there will be subtle skidding effects occuring due to the ground connection being a line. we could somewhat alleviate this by reducing the thickness of the wheel collision cylinder, but better is to reduce it infinitely, by replacing the cylinder with a sphere. now the  with the ground will be a single point per wheel. all we need to do is in our left/right wheel links of our urdf, in the collision geometry (not visual!) replace cylinder with sphere and remove the length parameter. to check this we can enable collision view in gazebo to see the collision sphere and the visual cylinder. there may be better methods than this - if you have one please let me know! additionally, if you are still having issues with wheels skidding and drifting oddly, try experimenting with the friction parameters like we did for the caster. if we relaunch it we should see that a full rotation places us back where we started. for what its worth, the reason this wasnt a problem with the old plugin is that it actually cheats to provide the odom transform perfectly rather than calculating it based on the simulated wheel spin. problem 3 - sensor synchronisation issue  now its time for problem number 3, which i currently dont have a fix for, and if someone can figure out whats going on, ill be very grateful. i have a whole github repo and separate video for reproducing it. it's difficult to describe in text (just watch the video) but essentially, when using ros2_control with gazebo the sensor output appears to be out of sync with the published transforms. i don't think it's a friction issue, as i have tried to eliminate that. it seems more like a timing issue, but the odd thing is that the laser data moves in the direction of rotation, not away from it, suggesting that the transforms are being published earlier than the sensor data rather than later (so it's not just be a delay in ros2_control). it could be to do with acceleration limits, i have tried to experiment with this too with no success. keeping accelerations and velocities low reduces the effect, which may be useful in testing. swapping between control methods  given that we have these issues, we might sometimes want to swap back to the old control method. it generally tends to work a bit more "perfectly" which is not always what we want but can be handy. taking the steps below will let us easily swap between the gazebo diff drive plugin and the ros2_control one. add xacro argument & condition  using xacro to build our urdf gives us the ability to pass in an argument at runtime to change the result. this could be anything like the length of an arm, the colour of a wheel, but in this case we want to pass in a boolean to tell it whether to use ros2_control or not. well start by adding an argument declaration at the start of our robot.urdf.xacro , and default it to true (we generally do want to use ros2_control). < xacro: arg name = " use_ros2_control " default = " true " /> now we need to add a conditional to change which bit of the urdf is used. xacro doesnt have an if-else construct that we may be familiar with, instead it has if and unless which will trigger depending on whether the condition is true, or untrue. so down where we have our gazebo_control.xacro commented out, we instead want to add the following blocks: < xacro: if value = " (arg use_ros2_control) " > < xacro: include filename = " ros2_control.xacro " /> </ xacro: if > < xacro: unless value = " (arg use_ros2_control) " > < xacro: include filename = " gazebo_control.xacro " /> </ xacro: unless > so, if use_ros2_control is true, include the ros2_control.xacro file, and unless use_ros2_control is true, include gazebo_control.xacro . pass in the xacro argument  now we need to pass the xacro argument in when we process the file, which is in our robot state publisher launch file ( rsp.launch.py ). this should be straightforward but actually isnt. right now this file is using the xacro python module to process the file, which is all well and good, and it has the option ( dont type this! ) to set arguments by specifying the mappings like so: xacro . process_file ( xacro_file , mappings = { 'use_ros2_control' : 'true' } ) this is fine, and works as is, but ideally we want to be able to set it at the level above this, to pass it in as a launch argument and because of how launch files are processed, dropping a launchconfiguration variable in here like we did with use_sim_time just wont work. the workaround is a little hacky but its not too bad, especially considering launch scripts arent designed to be super python-heavy anyway. instead of using the xacro python module were going to call the xacro process using the launch command substitution. well go ahead and make the launch argument anyway, right under our use_sim_time one. use_sim_time = launchconfiguration ( 'use_sim_time' ) use_ros2_control = launchconfiguration ( 'use_ros2_control' ) next, to make things smoother in case we ever want to go back to the old one, we'll move the toxml() up to the process call. hopefully you can see that that wont really change anything except that robot_description_config will now be the final string (rather than some xacro object), which makes more sense anyway. ## was robot_description_config = xacro . process_file ( xacro_file ) params = { 'robot_description' : robot_description_config . toxml ( ) , 'use_sim_time' : use_sim_time } ## now robot_description_config = xacro . process_file ( xacro_file ) . toxml ( ) params = { 'robot_description' : robot_description_config , 'use_sim_time' : use_sim_time } so the params is now taking in a string. but because it is a part of the clever ros launch system, instead of a string it can also take a substitution . so we'll take advantage of the command substitution, and replace the robot_description_config assignment to a call out to the xacro process rather than the python module. make sure you also add the appropriate import at the top. # at the top from launch . substitutions import command # down where we were #robot_description_config = xacro.process_file(xacro_file).toxml() robot_description_config = command ( [ 'xacro ' , xacro_file , ' use_ros2_control:=' , use_ros2_control ] ) this line is just constructing a command that could be typed into a terminal, but instead its going to run it inside the launch script and use the output. we can see that use_ros2_control (a launchconfiguration argument) is used in this call, so at runtime it will substitute that for whatever is passed in, then substitute the result of the whole command into the robot_description_config variable as a string. pass in the launch argument  then in launch_sim.launch.py where we were including our robot state publisher launch, we can set it to whatever we want by updating the launch_arguments line when including rsp.launch.py : . . . launch_arguments = { 'use_sim_time' : 'true' , 'use_ros2_control' : 'true' } . items ( ) . . . this is what i demonstrated in the video, however it would be nice to be able to toggle it at runtime, i.e. by running: ros2 launch my_package launch_sim.launch.py use_ros2_control:=false there are actually two ways to achieve this. the first is to...do nothing. if we undo the previous step where we passed down the launch argument, we'll find that we are able to set it at the command line and it will automatically find its way down to where it needs to be. alternatively, we can create another launch argument, this time in launch_sim.launch.py (probably with the same name), and pass it down like use_ros2_control = launchconfiguration ( 'use_ros2_control' ) . . . launch_arguments = { 'use_sim_time' : 'true' , 'use_ros2_control' : use_ros2_control } . items ( ) . . . these will have the same effect, but the latter is a bit more explicit. we should also remember to add an appropriate declarelaunchargument entry. this has probably all been a bit confusing, so check out the final files below. rsp.launch.py: click to show code launch_sim.launch.py: click to show code rviz config  one last thing i did was to set up rviz the way i liked it and saved the configuration to the config directory so that it can be loaded back up again in future with rviz2 -d . conclusion  now that we've got those things tidied up a bit, we can move forward with ros2_control on our robot, and then start to run some algorithms! update urdf to match robot structure problem 1 - gazebo clock rate problem 2 - wheel drift problem 3 - sensor synchronisation issue swapping between control methods add xacro argument & condition pass in the xacro argument pass in the launch argument rviz config conclusion