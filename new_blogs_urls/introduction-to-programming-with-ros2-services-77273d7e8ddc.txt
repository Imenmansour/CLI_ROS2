open in app sign up sign in write sign up sign in introduction to programming with ros2-services daniel jeswin  follow 8 min read  aug 9, 2019 -- 1 listen share this post is the second of a three part series introducing basic concepts of message passing and communication in ros2. in my previous post , i introduced topics and in this one i will introduce services in ros2. as in the previous post, i use ros2 crystal to demonstrate the concepts below. the next post on actions will be available soon. services ros2 services provide a client-server based model of communication between ros2 nodes. as in the case of topics, ros2 services are very similar to their ros1 counterparts from the practical perspective. in this post we will create a very simple service that allows the client to send two numbers to the server. the server sums them up and returns the result to the client. we will create 3 packages, similar to what we did for ros2 topics-a custom srv package, a server in c++ and a client in python. the client libraries for c++ and python are the only ones maintained by ros2 core team. however, one of the great things with ros2 being open source is that people have also developed client libraries for other languages like java, go, etc, making it possible to implement nodes in these languages as well. unlike my previous post, i will only go through the process of building packages briefly here. so in case of doubts during the build process please refer to my previous post . creating a srv package first let us create a ros2 workspace. we can also reuse the workspace we used to create ros2 topics. we shall then create a package for our custom srv. similar to ros1, both messages and services have the same dependencies. mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src ros2 pkg create my_services --dependencies builtin_interfaces rosidl_default_generators --build-type ament_cmake add an srv folder to store the services and create a new .srv file for our new service. the structure of srv files in ros2 are similar to those of ros1. for our case of creating a service for adding two numbers one simple way to create the srv file would be as follows. float64 a float64 b --- float64 sum next we need to build this package. this process is exactly the same as the one we followed to build our msg package previously. so go ahead and try to make the necessary modifications to the package.xml and cmakelists.txt files and come back here if you get stuck along the way. the code to be added to the cmakelists.txt file is as follows. set( srv_files "srv/add.srv") rosidl_generate_interfaces( {project_name} {srv_files} dependencies builtin_interfaces) ament_export_dependencies(rosidl_default_runtime) the code to be added to the package.xml file is as follows. remember to change the format for the package.xml to 3. <build_depend>builtin_interfaces</build_depend> <buildtool_depend>rosidl_default_generators</buildtool_depend> <exec_depend>rosidl_default_runtime</exec_depend> <member_of_group>rosidl_interface_packages</member_of_group> finally we can build the package from the workspace using colcon build. once the packages is built, source the required files and then check if our service has been installed correctly using the ros2 srv command cd ~/ros2_ws colcon build --symlink-install --packages-select my_services ros2 srv list | grep my_services the ros2 srv command should display my_services/add.srv. this confirms that the service has been installed correctly and that we can move on to the server. server we shall implement our server in c++. first let us create the new package. ros2 pkg create server --dependencies my_services rclcpp --build-type ament_cmake commands like the one above should be familiar by now. a great resource of the available cli tools with ros2 is available here . next, let us create our server.cpp file inside the src folder of the package. first let us include the necessary header files. #include "my_service/srv/add.hpp" #include "rclcpp/rclcpp.hpp" #include <iostream> #include <memory> then we shall create a server class that inherits the rclcpp node class as this is the recommended way of implementing nodes in ros2 and is also the most clean way of doing so. class server : public rclcpp::node { public: server() : node("my_server") { auto handle_add = [this]( const std::shared_ptr<rmw_request_id_t> request_header, const std::shared_ptr<my_service::srv::add::request> request, std::shared_ptr<my_service::srv::add::response> response) -> void { (void)request_header; response->sum = request->a + request->b; rclcpp_info(this->get_logger(), "incoming request %f %f. response is %f", request->a, request->b, response->sum); }; srv_ = this->create_service<my_service::srv::add>("add_floats", handle_add); } private: rclcpp::service<my_service::srv::add>::sharedptr srv_; }; the create_service method of the node class is used to create a server, that listens for requests on the add_floats service. the second argument of this method is the request handler. here, requests are handled using a lambda expression that takes the request_header, request and response as input. the expression simply fills up the sum field of the response. rclcpp_info is a mechanism for logging information to the standard output. it is ros2 equivalent of the ros_info() function in ros1. we then create an instance of the server class in the main function and allow it to spin forever. int main(int argc, char *argv[]) { rclcpp::init(argc, argv); auto node = std::make_shared<server>(); rclcpp::spin(node); return 0; } with the code for our server ready, we can now move on to building the package. once again try to modify the cmakelists.txt and package.xml files and come back here if you get stuck somewhere along the way. add_executable(server src/server.cpp) ament_target_dependencies(server rclcpp my_service) install( targets server destination lib/{project_name}) this is the additions to the cmakelists.txt file and the additions to the package.xml file are as follows. <build_depend>rclcpp</build_depend> <build_depend>my_service</build_depend> <exec_depend>my_service</exec_depend> <exec_depend>rclcpp</exec_depend> we then follow procedures that should be familiar by now- build the package, source the setup file and test if the package has been built correctly by running it. cd ~/ros2_ws colcon build --symlink-install --packages-select server source install/setup.bash ros2 run server server we can check if the service is running by using the ros2 service command. using the list option along with this command lists all the running services and the service add_floats must be one among the services that are currently up and running. we can also use the call option along with this command to call the server from the command line ros2 service list ros2 service call /add_floats my_services/add.srv "{a: 2, b: 3}" the second command calls the server and gives you the result i.e. 5. now, that the server is working we can move on to implementing the client. client we shall implement the client in python. currently, python packages are a little more trickier to develop than c++ packages due to the lack of cli support. we cannot use the build-type argument with the parameter ament_python. this forces us to add the files required to build a python package manually. first let us create a new package for the client. once the package is created we need to remove the cmakelists.txt file since this is a python package. ros2 pkg create client --dependencies my_services rclpy next we create two folders inside the package. one folder has the same name as the package name. this folder represents a normal python package and therefore, it must have an __init__.py file. for our purposes, this file can be left empty. we then create a resource folder containing an empty file. cd src/client mkdir client mkdir resources cd resources touch client cd ../client touch __init__.py next we can create our python module client.py within the client folder. first we need to import required packages and modules import rclpy from rclpy.node import node from my_service.srv import add import random next we create a client class inheriting the rclpy.node.node class class client(node): def __init__(self): super().__init__('client') self.client = self.create_client(add, 'add_floats') self.request = add.request() while not self.client.wait_for_service(timeout_sec = 10.0): self.get_logger().info('waiting for service') def send_request(self): self.request.a = random.uniform(2043, 343294) self.request.b = random.uniform(3234, 45849054) wait = self.client.call_async(self.request) rclpy.spin_until_future_complete(self, wait) if wait.result() is not none: self.get_logger().info("request was '%f' '%f'. response is '%f'" %(self.request.a, self.request.b, wait.result().sum)) else: self.get_logger().info("request failed") in the class we initialize the node client. then we create a service client using the create_client() method. in the next line we create a request object for the add service. we then wait for the service to be started by the server. the send_request function is called whenever a request is to be sent to the server. here, we have implemented a synchronous method of sending calls to the server. however, asynchronous implementations can also be done and i have included links to github repositories containing such examples in the references. the send_request fills the request object and calls the server. it then waits until a reply arrives from the server and does some sanity checks to ensure that the call is successful before printing the output to the standard output. next, we implement the main function. def main(args = none): rclpy.init(args = args) node = client() while rclpy.ok(): node.send_request() rclpy.spin_once(node) node.destroy_node() rclpy.shutdown() if __name__ == "__main__": main() in the main method we first initialize the python module and create an instance of the client class. the while loop that follows executes as long as the node is up and running. during each iteration of this loop we send a request to server and wait for the response before proceeding to the next iteration. the last two lines are necessary to ensure clean termination. now we can move on to building the package. this process is slightly tricky and since i had explained when i created the subscriber for ros2 topics, i will go over it briefly here. first we create the setup.py and setup.cfg files. from setuptools import setup package_name = 'client' setup( name=package_name, version='0.0.0', packages=[package_name], data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ('share/' + package_name, ['launch/client.launch.py']),], install_requires=['setuptools'], zip_safe=true, author='daniel jeswin', author_email='danieljeswin@gmail.com', maintainer='daniel jeswin' maintainer_email='danieljeswin@gmail.com', keywords=['ros'], classifiers=[ 'intended audience :: developers', 'license :: osi approved :: apache software license', 'programming language :: python', 'topic :: software development', ], description=' examples of service client using rclpy.', license='apache license, version 2.0', tests_require=['pytest'], entry_points={'console_scripts': ['client = client.client:main',],},) this template can be used for any other python package. the main parameters to be changed are the package name, version, data_files and entry_points. the setup.cfg file is as follows. [develop] script-dir=base/lib/client [install] install-scripts=base/lib/client finally we edit the package.xml file. the buildtool and export dependencies on ament_cmake need to be removed first and the following code has to be added. <exec_depend>rclpy</exec_depend> <exec_depend>my_msgs</exec_depend> <export> <build_type>ament_python</build_type> </export> the complete implementation of everything in this post is available in my github repository . now we can build the package using colcon build and then run both the client and the server. cd ~/ros2_ws colcon build --symlink-install --packages-select client source install/setup.bash ros2 run server server ros2 run client client now both the client and server are up and running and the output can be seen on the terminal. we have now reached the end of this introduction to services with ros2. while we start the client and server separately using ros2 run commands, they can also be started with a single launch file. i will explain launch files in ros2 in a separate post . goodbye for now! references https://github.com/ros2/examples/tree/master/rclpy/services/minimal_client/examples_rclpy_minimal_client github repo https://index.ros.org/doc/ros2/tutorials/rosidl-tutorial/ follow written by daniel jeswin 14 followers follow help status  careers press    text to speech teams