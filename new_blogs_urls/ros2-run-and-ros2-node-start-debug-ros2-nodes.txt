skip to content in this tutorial youll learn more  ros2 command line tools to start and introspect your nodes: ros2 run and ros2 node. i will try to remove some confusions you may have when you start, and give you practical tips you can use to improve your efficiency when developing with ros2. lets get to it! table of contents toggle the code well use heres a very minimal code for a ros2 node (in python), written in a file named my_program.py, inside a ros2_tutorials_py package. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter #!/usr/bin/env python3 import rclpy from rclpy.node import node class mynode ( node ) : def __init__ ( self ) : super () . __init__ ( "my_node" ) self. get_logger () . info ( "node has been started." ) def main ( args= none ) : rclpy. init ( args=args ) node = mynode () rclpy. spin ( node ) rclpy. shutdown () if __name__ == "__main__" : main () #!/usr/bin/env python3 import rclpy from rclpy.node import node class mynode(node): def __init__(self): super().__init__("my_node") self.get_logger().info("node has been started.") def main(args=none): rclpy.init(args=args) node = mynode() rclpy.spin(node) rclpy.shutdown() if __name__ == "__main__": main() #!/usr/bin/env python3 import rclpy from rclpy.node import node class mynode(node): def __init__(self): super().__init__("my_node") self.get_logger().info("node has been started.") def main(args=none): rclpy.init(args=args) node = mynode() rclpy.spin(node) rclpy.shutdown() if __name__ == "__main__": main() this will just start a node named my_node and print a log on the screen. thats all we need to practice on command line tools for ros2 nodes. so, first install this node by adding one line into the setup.py file of your python package: you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... entry_points= { 'console_scripts' : [ "minimal_node = ros2_tutorials_py.my_program:main" ] , ... ... entry_points={ 'console_scripts': [ "minimal_node = ros2_tutorials_py.my_program:main" ], ... ... entry_points={ 'console_scripts': [ "minimal_node = ros2_tutorials_py.my_program:main" ], ... note: if you were using cpp code, you would use the cmakelists.txt. if youre completely new to ros2 nodes, check out how to write a minimal node: python | cpp . compile your package with colcon build colcon build , source your ros2 workspace, and youre all set for the following. ros2 run  start your node from the terminal you might have already used ros2 run ros2 run before, but maybe not everything is clear for you. so, ros2 comes with a lot of useful command line tools. among them, the run run command allows you to start a node from any installed package (from your global ros2 installation, and from your own ros2 workspace). to start a ros2 program from the terminal, you will use: ros2 + run + name of the package + name of the executable. between each step you can press tab twice to see all available options. and there is often a confusion  the executable name. in the example were using, we are using 3 different names for: file: my_program.py node: my_node executable: minimal_node you can choose to use a different name for the file, node, and executable. you can also choose to use the same name for the 3 of them. but make sure you know the difference between them. so, here, if you want to start the node my_node from the my_program.py file, youll have to use the executable name minimal_node with ros2 run. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials_py minimal_node [info] [1593588614. 171412010 ] [my_node]: node has been started.  ros2 run ros2_tutorials_py minimal_node [info] [1593588614.171412010] [my_node]: node has been started.  ros2 run ros2_tutorials_py minimal_node [info] [1593588614.171412010] [my_node]: node has been started. the same applies for cpp code: lets say the name of the node is also my_node, the name of the file is my_program.cpp, the package name is ros2_tutorials_cpp, and the executable name is minimal_node. then youll execute ros2 run ros2_tutorials_cpp minimal_node ros2 run ros2_tutorials_cpp minimal_node . and to kill the node, simply press ctrl+c on the terminal where you executed ros2 run ros2 run . change the name of a node with ros2 run  at run time you can add many arguments to the ros2 run ros2 run command. among them there is one allowing you to directly change the nodes name at run time, without having to re-write/re-compile anything. the first thing to add is --ros-args --ros-args . use --ros-args --ros-args only once, and put all arguments after it. to change the nodes name from my_node to another_node, use -r __node:=... -r __node:=... : plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=another_node [info] [1593588911. 947569209 ] [another_node]: node has been started.  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=another_node [info] [1593588911.947569209] [another_node]: node has been started.  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=another_node [info] [1593588911.947569209] [another_node]: node has been started. you can see on the log line: the name of the node has been changed! this feature will be very useful when you want to launch multiple nodes with different names. for example if you have a single_wheel_controller node, you can create a right_wheel_controller and a left_wheel_controller node, using the same code and executable. and this is important: you cant start 2 nodes with the same name , or else expect to see some weird behavior. ros2 node list  list all nodes in your graph lets start 2 nodes, using the same executable, but different names. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_1 [info] [1593589221. 422757460 ] [node_1]: node has been started. --> in another terminal  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_2 [info] [1593589224. 588230634 ] [node_2]: node has been started.  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_1 [info] [1593589221.422757460] [node_1]: node has been started. --> in another terminal  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_2 [info] [1593589224.588230634] [node_2]: node has been started.  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_1 [info] [1593589221.422757460] [node_1]: node has been started. --> in another terminal  ros2 run ros2_tutorials_py minimal_node --ros-args -r __node:=node_2 [info] [1593589224.588230634] [node_2]: node has been started. so, you can start a node and modify its name. but now it could be nice to be able to see whats going on in the ros2 graph. ros2 node list ros2 node list will give you the list of all the nodes youve launched in the same graph/network. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 node list /node_1 /node_2  ros2 node list /node_1 /node_2  ros2 node list /node_1 /node_2 great, we can see the 2 nodes weve just started. ros2 node info  get more details  a node now that you know the name of nodes in your graph, you can use ros2 node info ros2 node info on a given node to get more details. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 node info /node_1 /node_1 subscribers: publishers: /parameter_events: rcl_interfaces/msg/parameterevent /rosout: rcl_interfaces/msg/log service servers: /node_1/describe_parameters: rcl_interfaces/srv/describeparameters /node_1/get_parameter_types: rcl_interfaces/srv/getparametertypes /node_1/get_parameters: rcl_interfaces/srv/getparameters /node_1/list_parameters: rcl_interfaces/srv/listparameters /node_1/set_parameters: rcl_interfaces/srv/setparameters /node_1/set_parameters_atomically: rcl_interfaces/srv/setparametersatomically service clients: action servers: action clients:  ros2 node info /node_1 /node_1 subscribers: publishers: /parameter_events: rcl_interfaces/msg/parameterevent /rosout: rcl_interfaces/msg/log service servers: /node_1/describe_parameters: rcl_interfaces/srv/describeparameters /node_1/get_parameter_types: rcl_interfaces/srv/getparametertypes /node_1/get_parameters: rcl_interfaces/srv/getparameters /node_1/list_parameters: rcl_interfaces/srv/listparameters /node_1/set_parameters: rcl_interfaces/srv/setparameters /node_1/set_parameters_atomically: rcl_interfaces/srv/setparametersatomically service clients: action servers: action clients:  ros2 node info /node_1 /node_1 subscribers: publishers: /parameter_events: rcl_interfaces/msg/parameterevent /rosout: rcl_interfaces/msg/log service servers: /node_1/describe_parameters: rcl_interfaces/srv/describeparameters /node_1/get_parameter_types: rcl_interfaces/srv/getparametertypes /node_1/get_parameters: rcl_interfaces/srv/getparameters /node_1/list_parameters: rcl_interfaces/srv/listparameters /node_1/set_parameters: rcl_interfaces/srv/setparameters /node_1/set_parameters_atomically: rcl_interfaces/srv/setparametersatomically service clients: action servers: action clients: here youll see 6 different categories, each listing a different kind of ros2 communication feature: subscribers and publishers (topic). service servers and service clients. action servers and action clients. for each existing communication on the node, youll get the name of the interface (topic name, service name, or action name), and the type to use. as you can see with this node, we already have some publishers and service servers, even if we didnt start anything from the code we wrote. those communications will be automatically started for every node you start: one publisher to the /rosout topic. nodes send their log to this topic, so all your logs from your application are centralized into one place, and then can be written into a file. one publisher and 6 service servers to handle the parameters of the node. going further with ros2 run and ros2 node at anytime, if you need help with a specific command, you can add -h to see a help message: ros2 run -h ros2 run -h , ros2 node -h ros2 node -h , ros2 node list -h ros2 node list -h , etc. when developing with ros2, you will use those 2 command line tools all the time. with this tutorial you already have a good overview of what to expect from them, and what info you can get to efficiently debug your application. as you saw here, ros2 node info ros2 node info gives you the list of topics, services, and actions for one node. well, you will also be able to introspect those communication features from the terminal. keep ros2 first, and then add the name of the communication: ros2 topic ros2 service ros2 action want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here