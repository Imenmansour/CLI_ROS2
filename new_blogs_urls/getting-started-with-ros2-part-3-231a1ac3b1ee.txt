open in app sign up sign in write sign up sign in getting started with ros2  part 3 sharad maheshwari  follow published in schmiedeone  6 min read  jan 12, 2022 -- 2 listen share note: third part of this series! check out part 2 , or the complete series starting with part 1 . (ros1 working knowledge assumed) so, we meet again!  if you read part 2 of the series, were good to continue! aim  understanding parameters, followed by actions creation in ros2. step 1  talk  ros2 parameters (and compare them with ros1) step 2  create an action service-client package step 1  ros2 parameters since we know what parameters are in ros1, well keep this short. inros1, roscore had a central parameter server to keep a log of all parameters. since there is no rosmaster and roscore in ros2, each node is responsible to keep a tab on its own set of parameters. that is the only difference. well use parameters in our next series on ros2. step 2  creating action service-client package for generating a fibonacci series actions have the exact same concept in ros2 as ros1, except they are a part of ros2 core library. in ros1, actions were implemented in a separate library called actionlib. so lets start coding! notes: please always source the terminal when startinga terminal source /opt/ros/galactic/setup.bash please always run . install/setup.bash after building the project not doing these often cause unnecessary debugging when the project doesnt run. well write an action server node that receives a number and gives back a fibonacci series of that length (order). next, we write an action client node to request a fibonacci series of a particular length (order). in addition to the final fibonacci series, the action server also publishes the current list as it calculates. do you remember how we always begin? creating a workspace  create our workspace called ros2_ws mkdir -p ~/ros2_ws/src 2. build the workspace cd ros2_ws colcon build at this point, you will see 0 packages finished in the terminal (because there are no packages yet). additionally, you will now have build, install and logs folders in the ros2_ws. note: ros2 does not support writing custom topic, service or action definitions in a python package. since we write action server and client nodes in python, we make a separate package fibonacci for generating our action definition. next, we make another python package fibonacci_action with our action server and client. 3. create a new fibonacci package cd ros2_ws/src ros2 pkg create fibonacci we do not use ament_python because making custom topics, service and actions require cmake. 4. setup actions file create actions directory  cd ros2_ws/src/fibonacci mkdir action create actions definition  cd action gedit fibonacci.action add the following definition  int32 order --- int32[] sequence --- int32[] partial_sequence before we can use the new fibonacci action type in our code, we must pass the definition to the rosidl code generation pipeline (using cmakelists and package.xml) add the following to cmakelists.txt before ament_package()  find_package(rosidl_default_generators required) rosidl_generate_interfaces({project_name} "action/fibonacci.action" ) add the following to package.xml <buildtool_depend> rosidl_default_generators </buildtool_depend> <depend> action_msgs </depend> <member_of_group> rosidl_interface_packages </member_of_group> build the package  cd ~/ros2_ws colcon build if everything is correct, our build will be successful. we can now check if our custom action is visible in ros2  . install/setup.bash ros2 interface show fibonacci/action/fibonacci you should see the fibonacci action definition printed on the screen  we created fibonacci package to have our custom action definition exposed in ros2. unlike ros1, we cannot create custom definitions inside a python package. so, we now create another python package with our action service and client nodes and use our custom fibonacci action here. 5. create a new fibonacci_action package for our nodes (python) cd ros2_ws/src ros2 pkg create --build-type ament_python fibonacci_action --dependencies rclpy we use dependencies which automatically updates package.xml with rclpy. 6. write action server cd ros2_ws/src/fibonacci_action/fibonacci_action gedit fibonacci_action_server_node.py add the following code to the file  lets talk  how action server works here  line 19  execute_callback method is called if any action client sends a request to th server. goal_handle is updated with feedback values and success status when the task is complete. it also has the input value order we defined input as int32 order in fibonacci.action. goal_handle.request will have this member variable line 22  feedback_message is updated with intermediate calculated values. we defined feedback as int32[] partial_sequence in fibonacci.action. hence, feedback_message will have this member variable line 35 result is updated with the final calculated value. we defined the result as int32[] sequence in fibonacci.action. hence, the result will have this member variable. the callback updates goal_handle with feedback (intermediate fibonacci list) at each step. after the required list of length order is obtained, the status is set to success and the final sequence is returned as result 7. add an entry point open setup.py and add the following lines within the console_scripts bracket of the entry_points field: 8. build and run check for missing dependencies rosdep install -i --from-path src --rosdistro galactic -y build the workspace (from ros2_ws)  colcon build source the terminal(from ros2_ws)  . install/setup.bash run the node  ros2 run fibonacci_action fibonacci_server to check if the server works well, send an action request using another command-line terminal  . install/setup.bash (to source the terminal first, as usual) ros2 action send_goal --feedback fibonacci fibonacci/action/fibonacci {order: 5} we expect a fibonacci series of length 5 along with feedback at each step. this is how the result will look. woot woot! our action server is alive and kickin!  now that we have an action server, lets create an action client instead of using the command line to send an action request. 9. write action client cd ros2_ws/src/fibonacci_action/fibonacci_action gedit fibonacci_action_client_node.py lets talk  how action client works here  line 15  send_goal method waits for the action server to be available, then sends a goal to the server. line 21  actionclient.send_goal_async() method returns a future to a goal handle (stored as _send_goal_future ) and registers a callback for feedback feedback_callback line 24  add_done_callback registers a callback for when the future is complete (using _send_goal_future handle). note that the future is completed when an action server accepts or rejects the goal request. line 26  goal_response_callback is called when action server accepts or reject the goal. if rejected, the code returns early. if accepted, we can request the result with the method get_result_async . line 34 goal_handle.get_result_async() method returns a future handle that will complete when the result is ready (stored as _get_result_future ) line 35 add_done_callback here registers a callback for when the future above is complete (the result is ready) line 37  get_result_callback logs the result sequence and shuts down ros 2 for a clean exit line 42  feedback_callback is called and processes partial_sequence feedback everytime action server publishes it these points should make the code more understandable! 10. add an entry point open setup.py and add the following lines within the console_scripts bracket of the entry_points field: 8. build and run check for missing dependencies rosdep install -i --from-path src --rosdistro galactic -y build the workspace (from ros2_ws)  colcon build source the terminal(from ros2_ws)  . install/setup.bash run the nodes in two different terminals  fibonacci action server  ros2 run fibonacci_action fibonacci_server fibonacci action client  ros2 run fibonacci_action fibonacci_client if everything was done properly, this will be the output  fibonacci action server terminal  fibonacci action client terminal  aaaaand that's all folks! to sum it up, we had a brief chat  parameters and then saw actions in action  whats next, you ask? we gradually go deeper into ros2-based robotics projects. next up, we have a series  setting up a quality robotics project. heres the agenda 1. getting started with a new ros project  demonstration using two custom packages for cute a little robot 2. improving ros codebase  launch files, and ros parameters 3. improving project with tests  adding ros test infrastructure 4. from hobbyist to quality project  adding docker for ci/cd on github robotics ros2 robotoperatingsystem startups iot follow written by sharad maheshwari 662 followers  editor for schmiedeone building robots follow help status  careers press    text to speech teams