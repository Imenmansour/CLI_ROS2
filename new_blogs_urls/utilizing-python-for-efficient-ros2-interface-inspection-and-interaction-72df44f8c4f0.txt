open in app sign up sign in write sign up sign in utilizing python for efficient ros2 interface inspection and interaction arshad mehmood  follow 4 min read  may 15, 2023 -- listen share in the realm of ros2 (robot operating system 2), being able to identify which nodes are associated with a specific topic is crucial. the command-line interface (cli) offers some functionality for this, such as the ros2 topic info command, which offers a count of publishers and subscribers for a particular topic. however, a limitation to this approach is its inability to identify the specific node names involved. ros2 node info shows interface info for that node but in order to get an overall picture, we have run node info on every node separately which is time consuming and not feasible. rqt does provide a node graph but often times gets complex and gui. users may want to have console based equivalent of that. besides that having a python script will give the opportunity to tune or modify according to the needs and use in automation. this anonymity arises from the data distribution service (dds) that ros2 employs for communication. although we can discern the topics being published and their types, the specific identities of the publishers and subscribers remain concealed. despite this, it is possible to employ certain workarounds to extract this information. one method is to inspect each node individually and check whether the topic of interest appears in its list of publishing topics. this process can be performed either via a bash script or a ros2 node written in python or c++. however, when dealing with a large number of nodes in a ros2 system, this process could be resource-intensive. a bash version of this functionality published earlier. this article explores a python script that identifies nodes associated with a particular topic, service or action in ros2. this python script, like its bash counterpart, accepts a keyword as an input, which could be a fully qualified interface name or merely a partial name. it sequentially examines all active nodes to identify any connections to the keyword. once the inspection is complete, the script outputs any pertinent information it has gathered. the script is tested on ros2 foxy. usage : command: find_node.py <keyword|topic|service|action> tested with ros2 foxy examples: check which nodes are related to /map  python find_node.py /map topics_publishers node: /map_server /map : nav_msgs/msg/occupancygrid topic subscribers node: /global_costmap/global_costmap /map : nav_msgs/msg/occupancygrid service servers node: /map_server /map_server/load_map : nav2_msgs/srv/loadmap /map_server/map : nav_msgs/srv/getmap above examples shows that /map_server node is publishing /map topic and global_costmap node is subscribing to it. a similar name is used to create a map service by map_server node. now running again the same but with map keyword (without /) gives out  python find_node.py map topics_publishers node: /local_costmap/local_costmap /local_costmap/clearing_endpoints : sensor_msgs/msg/pointcloud /local_costmap/costmap : nav_msgs/msg/occupancygrid /local_costmap/costmap_raw : nav2_msgs/msg/costmap /local_costmap/costmap_updates : map_msgs/msg/occupancygridupdate /local_costmap/published_footprint : geometry_msgs/msg/polygonstamped /local_costmap/voxel_grid : nav2_msgs/msg/voxelgrid node: /map_server /map : nav_msgs/msg/occupancygrid node: /global_costmap/global_costmap /global_costmap/costmap : nav_msgs/msg/occupancygrid /global_costmap/costmap_raw : nav2_msgs/msg/costmap /global_costmap/costmap_updates : map_msgs/msg/occupancygridupdate /global_costmap/published_footprint : geometry_msgs/msg/polygonstamped topic subscribers node: /recoveries_server /local_costmap/costmap_raw : nav2_msgs/msg/costmap /local_costmap/published_footprint : geometry_msgs/msg/polygonstamped node: /local_costmap/local_costmap /local_costmap/footprint : geometry_msgs/msg/polygon node: /global_costmap/global_costmap /global_costmap/footprint : geometry_msgs/msg/polygon /map : nav_msgs/msg/occupancygrid service servers node: /local_costmap/local_costmap /local_costmap/clear_around_local_costmap : nav2_msgs/srv/clearcostmaparoundrobot /local_costmap/clear_entirely_local_costmap : nav2_msgs/srv/clearentirecostmap /local_costmap/clear_except_local_costmap : nav2_msgs/srv/clearcostmapexceptregion /local_costmap/get_costmap : nav2_msgs/srv/getcostmap node: /map_server /map_server/load_map : nav2_msgs/srv/loadmap /map_server/map : nav_msgs/srv/getmap node: /global_costmap/global_costmap /global_costmap/clear_around_global_costmap : nav2_msgs/srv/clearcostmaparoundrobot /global_costmap/clear_entirely_global_costmap : nav2_msgs/srv/clearentirecostmap /global_costmap/clear_except_global_costmap : nav2_msgs/srv/clearcostmapexceptregion /global_costmap/get_costmap : nav2_msgs/srv/getcostmap service clients node: /bt_navigator_rclcpp_node /global_costmap/clear_entirely_global_costmap : nav2_msgs/srv/clearentirecostmap /local_costmap/clear_entirely_local_costmap : nav2_msgs/srv/clearentirecostmap here all interfaces with the word map in their names are listed along with the nodes that created them. this python script begins by obtaining a list of all active nodes in a ros2 system. it then proceeds to iterate over each node, checking if the node is publishing or subscribing to the target topic. if the node is associated with a topic, service, or action, that info is collected and presented in a consolidated output upon the scripts completion. while the bash script version was simple to use, it had several drawbacks. for instance, a node with over 1000 publishers or subscribers may not work as expected due to the limitations of grep. moreover, the time consumed to loop through all nodes could be substantial. however, this python script is not only faster, but also offers cross-platform compatibility, making it applicable for both linux and windows systems. this script can be an efficient tool for understanding the communication dynamics within a ros2 system. source code: #!/usr/bin/python # usage: # find_nodes.py <keyword|topic|service|action> # #  find_nodes.py /follow_path # searching: 37/37 nodes # service servers # =============== # node: /controller_server_rclcpp_node # /follow_path [action] : nav2_msgs/action/followpath # # service clients # =============== # node: /bt_navigator_rclcpp_node # /follow_path [action] : nav2_msgs/action/followpath # # author: arshad mehmood (arshadm78@yahoo.com) import sys import rclpy from rclpy.node import node class infonode(node): def __init__(self): super().__init__('info_node') def print_info(self, pattern): # dictionaries to hold searched informations publishers = {} subscribers = {} servers = {} # services and actions are combined clients = {} # services and actions are combined # get list of nodes in the system node_names = self.get_node_names_and_namespaces() for name, namespace in node_names: # create fully qualified name if namespace is given full_name = namespace + "/" + name if namespace != "/" else name # get list of topics created by this node publishers.update( self.get_list( full_name, pattern, self.get_publisher_names_and_types_by_node(name, namespace) ) ) # get list of topics subscribed by this node subscribers.update( self.get_list( full_name, pattern, self.get_subscriber_names_and_types_by_node(name, namespace) ) ) # get list of services and actions created by this node servers.update( self.get_list( full_name, pattern, self.get_service_names_and_types_by_node(name, namespace) ) ) # get list of services actions utilized by this node clients.update( self.get_list( full_name, pattern, self.get_client_names_and_types_by_node(name, namespace) ) ) # print gathered info self.print_results("topics_publishers", publishers) self.print_results("topic subscribers", subscribers) self.print_results("service servers", servers) self.print_results("service clients", clients) def print_results(self, header, lst): if not lst: return print (header) for node, value in lst.items(): print(f"\tnode: {node}") for intr, type in value: print(f"\t\t {intr} : {type[0]}") print("") def get_list(self, name, pattern, interface_list): exclude_string = ['/transition_event', '/set_parameters_atomically', '/set_parameters', '/list_parameters', '/get_transition_graph', '/get_parameters', '/get_state', '/get_parameter_types', '/change_state', '/describe_parameters','/get_available_states', '/cancel_goal', '/get_result','/feedback', '/status', '/get_available_transitions', '/rosout', 'parameter_event'] result = {} for tup in interface_list: if pattern in tup[0]: if not any(s in tup[0] for s in exclude_string): if '_action' in tup[0]: tup_new = (tup[0].replace("/_action/send_goal", " [action]"),[tup[1][0].replace("_sendgoal","")]) else: tup_new = tup if name in result: result[name].append(tup_new) else: result[name] = [tup_new] return result def main(args=none): rclpy.init(args=args) info_node = infonode() info_node.print_info(pattern=sys.argv[1]) rclpy.shutdown() if __name__ == '__main__': main() source code resides at (for future updates): https://github.com/arshadlab/ros2_tools/blob/main/find_nodes.py the script is tested with ros2 foxy. ros2 python rclpy interface follow written by arshad mehmood 106 followers as the technical lead at intel corporation, my work orbits around the intriguing world of robotics and artificial intelligence. follow help status  careers press    text to speech teams