skip to content in this tutorial you will learn how to create your own ros2 custom message (msg). i will also cover how to create custom services (srv), as the configuration and the process are the same. in ros2 the word message  when talking  the concept  has been replaced by interface. so, to create your own ros2 custom interface (for messages, services, etc.), you will first need to configure a few things, and then you will be able to create as many interfaces as you want, very quickly. >> watch this video as an additional resource to this article: after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. table of contents toggle using existing messages/interfaces first, do you really need to create a custom interface? before you try to reinvent the wheel, check if there is not already an existing message you can use. in the ros2 common interfaces page on github you can find a collection of messages you can reuse in your application. a good example is the sensor_msgs/msg/image.msg, which already contains all the info you need to send an image from a camera between nodes. first of all, you wont need to re-create it yourself, and second, this interface is already used by many ros2 plug-ins. so, if you manage to use this interface, then its all plug and play. however, sometimes youll find that there is no available interface directly matching your needs. you may find interfaces that partly correspond to what you want. a bad practice here would be to use those existing messages in a way that was not intended. this might work but it will make your application less readable and more prone to errors in the future. sometimes, youll find the right message for your application, but the name doesnt make much sense when you look at what youre trying to achieve. in that case a ros2 custom message would be appropriate. also, if youre tempted to use messages such as int64, string, etc., from the example_interfaces package (previously std_msgs), then as a best practice, dont. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 interface show example_interfaces/msg/int64 # this is an example message of using a primitive datatype, int64. # if you want to test with this that's fine, but if you are deploying # it into a system you should create a semantically meaningful message type. # if you want to embed it in another message, use the primitive data type instead. int64 data  ros2 interface show example_interfaces/msg/int64 # this is an example message of using a primitive datatype, int64. # if you want to test with this that's fine, but if you are deploying # it into a system you should create a semantically meaningful message type. # if you want to embed it in another message, use the primitive data type instead. int64 data  ros2 interface show example_interfaces/msg/int64 # this is an example message of using a primitive datatype, int64. # if you want to test with this that's fine, but if you are deploying # it into a system you should create a semantically meaningful message type. # if you want to embed it in another message, use the primitive data type instead. int64 data as you can see this package is only recommended to make tests. its also very handy when learning ros2 from scratch, since you can first learn how to use topics/services before creating your custom interfaces. but for real application purposes, dont use it. so, as a general rule, if you dont find an exact fit for your need in the available common interfaces, dont hesitate too much and create your own. create a package dedicated to ros2 custom messages best practices  naming in theory you could create custom messages in any package you want, but this could lead to many problems. for example, if you create the message in package a and you need this message in package b, youll have to add a dependency to package a. this will quickly result in a dependency mess with unneeded and cycling dependencies. so, the best practice here is to create a package dedicated to ros2 custom messages, and only that. then youll be able to add a dependency to this package, from any package requiring your custom interfaces. how to name the package? well, a best practice is to: start with the name of your robot/device/application. if your robot is named d4qp, then start with d4qp. end with _interfaces so its clear the package is an interface package. youll often see packages ending with _msgs, but this is the old convention. create the package go to your ros2 workspace and create a new package. ill simply use my_robot for the name of the robot/device/etc. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/  ros2 pkg create my_robot_interfaces  cd ~/ros2_ws/src/  ros2 pkg create my_robot_interfaces  cd ~/ros2_ws/src/  ros2 pkg create my_robot_interfaces this will create a new c++ ros2 package (default when you create a package, same as if you added the build-type ament_cmake option). and now well need to modify it to be able to build interfaces. configure the package for ros2 custom messages navigate inside the package, and: remove the include/ and src/ folders. add msg/ folder (also srv/ if you want to create services). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/my_robot_interfaces/  rm -rf include/  rm -rf src/  mkdir msg  mkdir srv  cd ~/ros2_ws/src/my_robot_interfaces/  rm -rf include/  rm -rf src/  mkdir msg  mkdir srv  cd ~/ros2_ws/src/my_robot_interfaces/  rm -rf include/  rm -rf src/  mkdir msg  mkdir srv youll need to modify package.xml by adding 3 lines. heres the file, new lines are highlighted (lines 12-14). plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> < package format = "3" > < name > my_robot_interfaces </ name > < version > 0.0.0 </ version > < description > todo: package description </ description > < maintainer email = "user@todo.todo" > user </ maintainer > < license > todo: license declaration </ license > < buildtool _depend > ament_cmake</buildtool_depend> < buildtool _depend > rosidl_default_generators</buildtool_depend> < exec _depend > rosidl_default_runtime</exec_depend> < member _of_group > rosidl_interface_packages</member_of_group> < test _depend > ament_lint_auto</test_depend> < test _depend > ament_lint_common</test_depend> < export > < build _type > ament_cmake</build_type> </ export > </ package > <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> <package format="3"> <name>my_robot_interfaces</name> <version>0.0.0</version> <description>todo: package description</description> <maintainer email="user@todo.todo">user</maintainer> <license>todo: license declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>rosidl_default_generators</buildtool_depend> <exec_depend>rosidl_default_runtime</exec_depend> <member_of_group>rosidl_interface_packages</member_of_group> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> <?xml version="1.0"?> <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/xmlschema"?> <package format="3"> <name>my_robot_interfaces</name> <version>0.0.0</version> <description>todo: package description</description> <maintainer email="user@todo.todo">user</maintainer> <license>todo: license declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <buildtool_depend>rosidl_default_generators</buildtool_depend> <exec_depend>rosidl_default_runtime</exec_depend> <member_of_group>rosidl_interface_packages</member_of_group> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> youll also need to modify cmakelists.txt. i have simplified the default cmakelists.txt, and also highlighted the extra lines you need to add. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter cmake_minimum_required(version 3. 5 ) project(my_robot_interfaces) # default to c++14 if (not cmake_cxx_standard) set(cmake_cxx_standard 14 ) endif() if (cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang" ) add_compile_options(-wall -wextra -wpedantic) endif() find_package(ament_cmake required) find_package(rosidl_default_generators required) rosidl_generate_interfaces({project_name} "your custom interfaces will be here" "one per line" "no comma for separating lines" ) ament_export_dependencies(rosidl_default_runtime) ament_package() cmake_minimum_required(version 3.5) project(my_robot_interfaces) # default to c++14 if(not cmake_cxx_standard) set(cmake_cxx_standard 14) endif() if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() find_package(ament_cmake required) find_package(rosidl_default_generators required) rosidl_generate_interfaces({project_name} "your custom interfaces will be here" "one per line" "no comma for separating lines" ) ament_export_dependencies(rosidl_default_runtime) ament_package() cmake_minimum_required(version 3.5) project(my_robot_interfaces) # default to c++14 if(not cmake_cxx_standard) set(cmake_cxx_standard 14) endif() if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() find_package(ament_cmake required) find_package(rosidl_default_generators required) rosidl_generate_interfaces({project_name} "your custom interfaces will be here" "one per line" "no comma for separating lines" ) ament_export_dependencies(rosidl_default_runtime) ament_package() if you want to compile the empty package just now, comment the rosidl_generate_interfaces command as it doesnt contain any interface  otherwise youll get a compilation error with colcon. your package is now configured and ready! this step only needs to be done once. after that, you can add custom interfaces. create your own ros2 custom message (msg) create the message file in your newly created package, go inside the msg/ folder and create a new file there. the rules/conventions for message files: use camelcase for the name of the interface. ex: motortemperature. dont add msg or interface in the name, this will add redundancy. use the .msg extension. so, for example, lets say we want our robot to reach a certain point, which is defined by a name and some coordinates to reach. the file name can be targetcoordinates.msg. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/my_robot_interfaces/msg/  touch targetcoordinates.msg  cd ~/ros2_ws/src/my_robot_interfaces/msg/  touch targetcoordinates.msg  cd ~/ros2_ws/src/my_robot_interfaces/msg/  touch targetcoordinates.msg now, youll need to fill the message definition. write the message definition you can use any number of: ros2 primitive data types for messages ( list available here ). or already existing messages  that youve created, or from other packages. in this example, we need to use the primitive type string for the name of the target. and for the coordinates, well use the geometry_msgs/msg/point message which already contains what we need. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 interface show geometry_msgs/msg/point # this contains the position of a point in free space float64 x float64 y float64 z  ros2 interface show geometry_msgs/msg/point # this contains the position of a point in free space float64 x float64 y float64 z  ros2 interface show geometry_msgs/msg/point # this contains the position of a point in free space float64 x float64 y float64 z if you get an error when trying to see the message, then you need to install the corresponding package with sudo apt install ros-<your_distro>-geometry-msgs sudo apt install ros-<your_distro>-geometry-msgs . and this is important: if your custom interfaces package depends on another package, youll need to add this dependency in both package.xml and cmakelists.txt. for package.xml: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... < buildtool _depend > ament_cmake</buildtool_depend> < depend > geometry_msgs </ depend > < build _depend > rosidl_default_generators</build_depend> ... ... <buildtool_depend>ament_cmake</buildtool_depend> <depend>geometry_msgs</depend> <build_depend>rosidl_default_generators</build_depend> ... ... <buildtool_depend>ament_cmake</buildtool_depend> <depend>geometry_msgs</depend> <build_depend>rosidl_default_generators</build_depend> ... for cmakelists.txt: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... find_package(ament_cmake required) find_package(geometry_msgs required) find_package(rosidl_default_generators required) ... ... find_package(ament_cmake required) find_package(geometry_msgs required) find_package(rosidl_default_generators required) ... ... find_package(ament_cmake required) find_package(geometry_msgs required) find_package(rosidl_default_generators required) ... all right, and now lets write the content of targetcoordinates.msg: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter string name geometry_msgs/point coordinates string name geometry_msgs/point coordinates string name geometry_msgs/point coordinates add one field per line. first the data type, then the name. add the message in cmakelists.txt once youve created your message file, it wont build automatically. you need to add it inside the rosidl_generate_interfaces() function. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" ) ... ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" ) ... ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" ) ... all the interfaces you create (message, service, action, etc) will all be written here in rosidl_generate_interfaces(). and because the file is inside the msg/ folder and has the .msg extension, ros2 knows its a message, not something else. you can add as many custom interfaces as you want here. simply add one per line, and dont put any comma to separate the lines . build your custom message before being able to use a message, you need to build it. the ros2 build system will create python/c++/etc. source code for the message, so you can then import it directly in your code. to build your new interface: plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces starting >>> my_robot_interfaces finished <<< my_robot_interfaces [0.47s] summary: 1 package finished [0.56s]  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces starting >>> my_robot_interfaces finished <<< my_robot_interfaces [0.47s] summary: 1 package finished [0.56s]  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces starting >>> my_robot_interfaces finished <<< my_robot_interfaces [0.47s] summary: 1 package finished [0.56s] if you get any error at this point, go back to the beginning and make sure youve done all the steps correctly. use your ros2 custom message in your code  from another package now the message is built and ready to be used. before using it though make sure you have sourced your environment  or else you wont be able to find it! plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  source ~/ros2_ws/install/setup.bash  source ~/ros2_ws/install/setup.bash  source ~/ros2_ws/install/setup.bash now you can see your message with the ros2 interface command line tool. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  ros2 interface list | grep my_robot my_robot_interfaces/msg/targetcoordinates  ros2 interface show my_robot_interfaces/msg/targetcoordinates string name geometry_msgs/point coordinates  ros2 interface list | grep my_robot my_robot_interfaces/msg/targetcoordinates  ros2 interface show my_robot_interfaces/msg/targetcoordinates string name geometry_msgs/point coordinates  ros2 interface list | grep my_robot my_robot_interfaces/msg/targetcoordinates  ros2 interface show my_robot_interfaces/msg/targetcoordinates string name geometry_msgs/point coordinates to use your message in your code, the process is exactly the same as if you were using any other common ros2 message. so, lets say that in package my_robot_driver you need to use the targetcoordinates message from my_robot_interfaces package. note: the configuration to add now is inside the my_robot_driver package, not in the my_robot_interfaces package. if my_robot_driver is a python package: add < depend > my_robot_interfaces </ depend > <depend>my_robot_interfaces</depend> in package.xml. in your code, to import the message: from my_robot_interfaces.msg import targetcoordinates from my_robot_interfaces.msg import targetcoordinates . if my_robot_driver is a c++ package: add < depend > my_robot_interfaces </ depend > <depend>my_robot_interfaces</depend> in package.xml. add find_package(my_robot_interfaces required) find_package(my_robot_interfaces required) in cmakelists.txt. in your code, to import the message: #include "my_robot_interfaces/msg/targetcoordinates.hpp" #include "my_robot_interfaces/msg/targetcoordinates.hpp" (make sure to use .hpp). create/build/use your own ros2 custom service (srv) the steps to create a new custom service (srv) are the exact same as for custom messages (msg). here we wont start from the beginning, well use the already configured my_robot_interfaces package. lets say we want to create a service to set a color for an rgb led. we want to send the color as an hexadecimal stored in a string, and we want to know if the operation was successful or not (simple boolean answer). create a new file in the srv/ folder of the package (create srv/ if not already here). follow the same conventions as for message file names, but this time use the .srv extension instead of .msg. also, as a service reflects an action or computation to do, use a verb in the name. for example: set.., trigger.., activate.., compute.., turn.., and so on. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/src/my_robot_interfaces/srv/  touch setrgbled.srv  cd ~/ros2_ws/src/my_robot_interfaces/srv/  touch setrgbled.srv  cd ~/ros2_ws/src/my_robot_interfaces/srv/  touch setrgbled.srv here well only use primitive data types, so no new dependency to add. heres the content of the service file. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter string rgb_hex_color --- bool success string rgb_hex_color --- bool success string rgb_hex_color --- bool success note that the request fields and the response fields are separated by 3 -. you should have those 3 dashes in every service file you create. now that the file is created, lets add the new interface in the cmakelists.txt. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" "srv/setrgbled.srv" ) ... ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" "srv/setrgbled.srv" ) ... ... rosidl_generate_interfaces({project_name} "msg/targetcoordinates.msg" "srv/setrgbled.srv" ) ... lets build the package. plain text copy to clipboard open code in new window enlighterjs 3 syntax highlighter  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces  cd ~/ros2_ws/  colcon build --packages-select my_robot_interfaces and then, to use this new interface in your code (first dont forget to source the environment: source ~/ros2_ws/install/setup.bash source ~/ros2_ws/install/setup.bash ): from a python package: same configuration as for messages. to import the service: from my_robot_interfaces.srv import setrgbled from my_robot_interfaces.srv import setrgbled . from a c++ package: same configuration as for messages. to import the service: #include "my_robot_interfaces/srv/setrgbled.hpp" #include "my_robot_interfaces/srv/setrgbled.hpp" . and thats it! conclusion  create custom ros2 messages you are now able to create your own custom ros2 interfaces (messages and services). quick recap: if you find the perfect match in an already existing message (ex: from geometry_msgs, sensor_msgs, etc.), then use it instead of reinventing the wheel. otherwise, create your own ros2 custom message. after youve created a new package + initialized it, for each new interface youll need to: create a new file under the appropriate directory (msg/, srv/). write the interface inside the file. add the file in the cmakelists.txt of the interfaces packages. build the interfaces package. after youve created a few messages, youll see that it becomes quite simple and youll be able to create new messages in no time. want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here