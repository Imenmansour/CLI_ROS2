skip to content you may be wondering what are the differences between ros1 and ros2. and what does it change for you? ros1 vs ros2, lets begin! in this article ill give you a practical overview of what has changed, and whats new. ill try to be brief. not too many details, not too much theory, but a focus on what affects you, as a developer. if youre new to ros (ros1 or ros2) its still a good thing to read this, because it can help you understand some parts of the ros system. to be clear and not bring any confusion, i will use the term ros when talking  ros  aka robot operating system  in general: the ecosystem, the philosophy behind ros, the community, etc. i will use ros1 and ros2 when talking  the specific ros versions. after watching the video, subscribe to the robotics back-end youtube channel so you dont miss the next tutorials! you want to learn ros2 efficiently? check out ros2 for beginners and learn ros2 step by step, in 1 week. table of contents toggle why ros2 and not keep ros1 ros1, initially created in 2007 by willow garage, has become huge among the open source robotics community. the team behind ros1 has learned  with all those years of experience, what important features are missing, and what could be improved. unfortunately, adding all those modifications into ros1 would have required many breaking changes, and make ros1 quite unstable. so, ros2 was developed from scratch, and is a complete new ros. as for now ros is not very popular in the industry, and lacks some of the most important requirements, such as real-time, safety, certification, security. one of the goals for ros2 is to make it compatible with industrial applications. ros1 and ros2 distributions heres the situation with ros1: ros noetic (release date: 2020) is the last ros1 version. this final ros1 version mains goal is to provide python3 support for developers/organizations who need to continue working with ros1 for a while. ros noetics eol (end of life) is scheduled for 2025. after that, no more ros1! so, if you have a big code base in ros1 today, its totally ok, but dont wait until 2024 to start making changes. for ros2, from the lts (long term support) version foxy fitzroy (release date: 2020), a new ros2 version is released every year. same as what was previously done for ros1. you can already start working with ros2 which is pretty stable now  at least the core functionalities, some 3rd party plugins are still missing. now lets explore the differences. ive separated them into 3 main parts in order to have some sort of a structure, however feel free to jump to any point, they can all be read independently. ros1 vs ros2: writing your nodes the ros api  rclcpp, rclpy in ros1, for cpp you use roscpp, and for python, rospy. both libraries are completely independent and built from scratch. it means that the api is not necessarily the same between roscpp and rospy, and some features are developed for one, and not the other. ros2 has more layers. there is only one base library, named rcl, and implemented in c. this is the foundation which contains all of the ros2 core features. you wont use the rcl library directly in your programs. youll use another client library built on top of rcl. for example: rclcpp for cpp, rclpy for python. whats great  it? well any new functionality only needs to be implemented with rcl. then, the client libraries on top of rcl just need to provide the binding. for you, as a developer, it means that: the api between rclcpp and rclpy will be much more similar than the api between roscpp and rospy. it will be easier to create and use other language client libraries, for example rclnodejs, rcljava, etc. no need to reinvent the wheel, you just need to make a c binding with rcl. and all clients in all languages will have a similar api. when a new core feature is released, it will be available sooner in different languages, so you wont have to wait too much. python and cpp versions as you may know, python2 is not supported anymore. well in fact, to provide a smoother transition, its still supported for ubuntu 18 and ros1 melodic until their eol (2023). ros1 noetic targets python3, as well as all ros2 versions. now, for cpp, there is some great progress. ros1 was targeting cpp 98, and you could use cpp 11/14 in later ros1 versions, provided that it didnt break other dependencies. in ros2 you can now use cpp 11 and 14 by default. cpp 17 is also on the roadmap. thats great because new versions of cpp introduce many useful functionalities, making development easier, quicker, and safer. also, it makes cpp more fun, and maybe this will help democratize this powerful and great language (well it seems im biased). writing a node (with oop) in ros1 there is no specific structure telling you how you should write your node functionalities. you can decide to add callback functions anywhere in your program, or use oop if you wish to, but every ones implementation could be unique. in ros2 things are different. there is a convention  how to write your nodes. you have to create a class which inherits from the node object (for example: rclcpp::node in cpp, rclpy.node.node in python). in this class youll have all your ros2 functionalities. this is great because it will save everyone a lot of time. you already have a good, modular structure for writing your node. it will make your programs cleaner, and cooperation between developers on different projects will be easier. check out how to write a minimal ros2 python node , and a ros2 cpp node , with oop. using oop for your nodes in ros2 also allows you to convert them to components, which is a new feature in ros2. lets see that now. multiple nodes in the same executable  ros2 components in ros1 a node is tight to an executable. a new functionality, named nodelets, was added in ros1 to be able to write multiple nodes in the same executable, with intra-process communication. this is really great when you have limited hardware resources and/or you need to send a lot of messages between nodes. in ros2, nodelets are not called nodelets anymore. the functionality has been directly included in the ros2 core, and is now called components. so, with ros2, you can handle many nodes from the same executable, using components. a component is simply a slightly modified node class (were still using oop there). then, you can start your components from a launch file, the terminal, or from an executable. and you can activate intra-process communication to remove any ros2 communication overhead. building components is a good practice to create efficient ros2 applications. lifecycled nodes ros2 introduces the concept of lifecycled nodes. a lifecycled node has different states: unconfigured, inactive, active, finalized. this is very useful when you need a setup phase before actually running your nodes main functionalities. when you start such a node it is initially unconfigured. through the provided interface (ros2 services), you can ask for a transition to another state. when you do that a predefined callback will be triggered inside the node. lets say you have a node for a sensor. you first need to make sure the sensor is detected, and the communication has been successfully started. then you can start your reading loop and publish the data. with a lifecycled node you can clearly separate this: first you allocate memory for publishers, subscribers, and other instantiated objects. then, you initiate the communication with the sensor. and finally you run your reading loop to publish the data. writing launch files launch files allow you to start all your nodes from one file. you can start a standard node, a component, a lifecycled node. you can add arguments, parameters, and many other options. in ros1, youve been used to write launch files with xml. in ros2 you will now use python to write your launch files. there is an api allowing you to start nodes, retrieve config files, add parameters, etc. and it will allow you to customize your launch files much more than before. however, is writing a launch file in python really new? well in fact no. in ros1 there is also a python api. the problem is: no one is aware of it, and theres almost zero documentation  it. so, no one uses it. and it became quite the norm to write launch files in xml, which is great, but certainly not as modular as with the python api. and you can also write your ros2 launch files with xml if you want to. but prefer using python, as it brings more modularity, is more documented, and has become the ros2 convention for launch files. check out how to write a ros2 launch file . ros1 vs ros2: communication no more ros master one thing youve learned with ros1: always start a ros master before you run a node. the ros1 master will act as a dns server for your nodes, so they can retrieve each other. in ros2, no more ros master! this is no more a centralized system. each node has the capacity to discover other nodes. you can simply start a node without having to worry if you have a master running or not. this change is great because it allows you to create a fully distributed system. each node is independent and not tight to a global master. when creating a multi-machine ros2 application , you wont have to define one machine as the master. each machine will be independent and able to start on its own, connect and disconnect with each other, with less setup than in ros1. parameters so, in ros1, parameters are handled by the parameter server, which is itself handled by the ros master. in ros2, no more ros master = no more (global) parameter server. the concept of parameters has been completely changed. there is no global parameter anymore. each parameter is specific to a node. a node declares and manages its own parameters, and those parameters are destroyed when the node is killed. its like each node has its own parameter server. when you start a node a few ros2 services are created. those allow you to interact with its parameters from the terminal or from other nodes. in addition, you can easily modify a nodes parameters after theyve been created, using a parameter callback. if you were using the dynamic_reconfigure tool in ros1, well, good news, now this is part of the core functionalities. no more extra config, all you need is to bind a parameter callback to your node. check out how to handle parameters in your code: rclcpp params and rclpy params . and how to create parameter callbacks: rclpp parameter callback , and rclpy parameter callback . services in ros1, services are synchronous. when your service client asks a request to the server, it is stuck until the server responds (or fails). in ros2, services are asynchronous. when you call a service, you can add a callback function which will be triggered when the server responds. in the meantime your main thread is not stuck. and of course, if you want you can also use services synchronously. actions in ros1, actions were never in the core functionalities. it was an addition made after a few years, to solve the problem that services were not asynchronous, and did not have a feedback or cancelation mechanism. so, actions in ros1 are entirely built on top of ros1 topics. in ros2, actions are now part of the ros2 core. the api for cpp and python is quite similar as for ros1, so no problem with the code. underneath, actions still use topics for feedback and goal status, but also (asynchronous) services for setting a goal, canceling a goal, and requesting a result. and now, actions also have their own command line tool! as you would do with a service, you can now send an action goal to a server, directly from the terminal. messages, services, and action definitions the way to create definitions for messages , services, and actions is quite similar in ros1 vs ros2. you still put them into msg/, srv/, and action/ folders. but after you compile them, a namespace is added: message: msg/ services: srv/ actions: action/ for example, lets say you have a package named my_robot_msgs, and inside this package you have created a message named temperature, plus a service named activatebutton. in your nodes code youll have to import them using: my_robot_msgs/msg/temperature. my_robot_msgs/srv/activatebutton. this is great because it reduces the confusion, and makes the separation clearer between all 3 types of communications. qos ros2 introduces qos, or quality of service. with that feature you can choose how your nodes handle communication: do you want to make sure you receive all messages? or is it ok to lose a few messages, as long as the data is frequently updated? do you want to keep a queue of messages in case a node doesnt have the time to process them all, or do you want to drop any new message if a callback for a previous message is still running? well, if you have to ask such questions for your application, then youll need to tune qos for your nodes. by default, the qos for ros2 communication (topics, services, ) has been chosen so you can expect the same behavior as in ros1: any node subscribing to a topic wont receive previous messages, only messages published after subscribing. like tcp, messages are guaranteed to be delivered. you can set a queue size for delivered messages waiting to be processed. if you have to deal with a lossy wireless network, and/or a large message bandwidth, qos is a setting worth looking at. but if youre just getting started with ros, or have a very simple application, dont worry  qos. there are more important things to learn first, and you will come back to qos when you need it. ros1 vs ros2: packages, workspace and environment building your nodes the build system in ros1 is catkin. you use catkin_make or catkin build in order to build and install your packages. in ros2, no more catkin. ament is the new building system, and on top of that you get the colcon command line tool. to compile, youll use the command colcon build in your ros2 workspace. there is much more to say  ament and colcon, but with just this information youll be able to build your first nodes without any problem. command line tools most of the command line tools are similar between ros1 and ros2. the name of the tools, and some options are different, but otherwise there is no big difference when you use them. for example, to list all topics, in ros1 youd do rostopic list, and in ros2 ros2 topic list. rosservice becomes ros2 service , rosrun becomes ros2 run , rosbag becomes ros2 bag , etc. you just have to write ros2, followed by the name of the tool you want to use. cpp and python packages with ros1, you create a package and then you add any cpp/python file you want. ros2 makes the difference between a cpp and a python package. when creating the package from the command line, you have to specify one build type: ament_cmake or ament_python. depending on that argument, the package architecture wont be the same. for a cpp package , things are quite similar with ros1. you still have a cmakelists.txt. you just have to adapt your cmake instructions to use ament and not catkin. for a python package , things are different: you have some new files, such as setup.py and setup.cfg. the setup.py replaces the cmakelists.txt. you can of course directly run your python scripts, but if you want to start them from ros2 command line tools or a launch file, youll have to install them first (with colcon build). you can also, if you want to, create a ros2 package for both python and cpp, but this requires a little bit more setup. overall, setting packages up in ros2 is a little bit more complex than in ros1, but its also more complete, and better organized. sourcing workspace and overlays sourcing your ros environment is not so much different between ros1 and ros2. you first source your global ros installation, then your workspace, and you can use your custom code. ros2 brings the concept of overlays. you can have multiple workspaces on top of each other. first you source your global ros installation, then your first workspace (overlay), your second overlay, etc. if a package has the same name in a lower level overlay and a higher level overlay, then only the higher level one will be used. when you develop your application and already have a certain number of packages, you can create an overlay for just one package. this will allow you to quickly iterate on it, while keeping your code base unchanged for other projects. with this technique you can also override a package which is already installed from binaries. this is very practical so you can keep the package installed, while having your own version for a specific application. os support ros1s main target is ubuntu. great news for ros2: thanks to its new architecture, you can install and use it on ubuntu, macos, and windows 10 (+ other oses, but those are the 3 main ones). this will make ros2 more accessible and more embeddable in many applications. for example, you could have a mobile robot with raspberry pi and ubuntu, and another computer using windows for a 3d simulation tool and a driver node for a camera scanning the scene. and all of that running smoothly together. when to switch from ros1 to ros2? well, its not as simple as that, and many people will tell you different answers. ros1 is still strong, with many stable plugins, more documentation and 3rd party plugins. eventually it will end, but you still have a few years before that. if youre new to ros (whether ros1 or ros2), then you should probably learn ros2 fundamentals. but then it can also be interesting to get a taste of ros1 too. why? because you may understand some things in ros2 better if you also see how its done in ros1. and also, some tools/packages you want to use may not yet be ported to ros2, so youll have no choice but to use the ros1 version of the package. in this case the ros1_bridge package will be useful (see next section). if you already know ros and want to start a brand new project, then going the ros2 way is probably what you should do, so it means less transition work in the future. the core concepts between ros1 and ros2 are similar, so the more experienced you are with ros1, the less time youll take to learn ros2. you can also use ros1 and ros2, hand in hand with ros1_bridge, in order to use missing tools and plugins. if you already have a code base in ros1 for one or more of your robots, or for a complete organization with dozens of developers, switching to ros2 may represent a lot of work. the bigger the code base and the influence of ros on your project, the longer it will take, and the more complex it will be. you may choose to continue working with ros1 for legacy projects, and start working with ros2 for new projects. or you could start porting all your code to ros2 now, knowing that theres a lot of work involved (depending on how well your code is written). first, before you decide to make the complete switch, make sure that most of the ros features you need have been ported to ros2. again, ros1_bridge may help you during the transition. using ros1 and ros2 together with the ros1_bridge package if you need to work with an existing ros1 code base, but want to develop new features with ros2, then you are not necessarily stuck. you can use the ros2 package named ros1_bridge, which will make, as its name suggests, a bridge between ros1 and ros2 communications. even if the concepts are the same between ros1 and ros2, the communication underneath is not directly compatible, and some adaptation is required. the ros1_bridge package provides that. when doing a transition to ros2, you can start porting a few packages in ros2, and make those packages communicate with the rest of your ros1 application. then, you port more and more packages until there is nothing left written with ros1. during all the porting time, your application can still work as expected. ros1 vs ros2: conclusion in this article youve seen some of the major differences between ros1 and ros2. i tried to make the approach focused on the practical side, so you can get an overview of whats changing for you, when you develop a robotics application with ros. to stay informed, you can check the ros discourse forums , where youll see interesting discussions  new concepts, debates and announcements. now, the list presented here is certainly not exhaustive and some information is subject to change, because ros2 is still evolving a lot. but its a good starting point to see what you need to focus on, when you decide to learn ros2 . want to learn how to program with ros2? don't miss this opportunity: [new] ros 2 book or, learn with a video course want to learn ros2? [new] ros 2 book or, learn with a video course we use s on our website to give you the most relevant experience by remembering your preferences and repeat visits. by clicking accept all, you consent to the use of all the s. however, you may visit " settings" to provide a controlled consent.  settings accept all manage consent close  overview this website uses s to improve your experience while you navigate through the website. out of these, the s that are categorized as necessary are stored on your browser as they are essential for the working of basic functionalities of the ... necessary necessary always enabled necessary s are absolutely essential for the website to function properly. these s ensure basic functionalities and security features of the website, anonymously.  duration description lawinfo-checkbox-analytics 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "analytics". lawinfo-checkbox-functional 11 months the  is set by gdpr  consent to record the user consent for the s in the category "functional". lawinfo-checkbox-necessary 11 months this  is set by gdpr  consent plugin. the s is used to store the user consent for the s in the category "necessary". lawinfo-checkbox-others 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "other. lawinfo-checkbox-performance 11 months this  is set by gdpr  consent plugin. the  is used to store the user consent for the s in the category "performance". viewed__policy 11 months the  is set by the gdpr  consent plugin and is used to store whether or not user has consented to the use of s. it does not store any personal data. functional functional functional s help to perform certain functionalities like sharing the content of the website on social media platforms, collect feedbacks, and other third-party features. performance performance performance s are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors. analytics analytics analytical s are used to understand how visitors interact with the website. these s help provide information on metrics the number of visitors, bounce rate, traffic source, etc.    s are used to provide visitors with relevant ads and  campaigns. these s track visitors across websites and collect information to provide customized ads. others others other uncategorized s are those that are being analyzed and have not been classified into a category as yet. save & accept learn ros2 in a week check out the course here