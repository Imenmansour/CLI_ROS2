skip to content services in ros2 are another type of communication between different ros2 nodes. after you learned how to use topics , you might wonder, why you would need something else for communication, right? as explained in the overview , different communication types are used for different purposes. while topics are mainly used for continuous streams of data, services will be used for tasks where a constant data stream would be overkill, especially when the data exchange is less frequent. another use case would be when your program relies on receiving feedback from a sent information, for example when your robot finished a task. you can find more information  services in the official ros2 documentation . what are services? a service is a type of communication that adopts the idea of a handshake protocol as it is implemented by having a client application that will send a request to the server to perform a task. after the server has finished the task, it will send a message back to the client to notify it of the result. the client will patiently wait for a response before it will continue with other tasks. especially this last behaviour is one of the major drawbacks of using services as the client is basically unresponsive while waiting for the response . the advantage is that it provides a simple and elegant solution that receives a response rather than broadcasting into the unknown while producing a massive amount of unnecessary data traffic. if you would like to reproduce the same strategy with topics , you would need to have two publishers and two subscribers that constantly send the request and the answer to make sure the message has been sent and the result has been received. this would create unnecessary data traffic to obtain the same result. after all these explanations, lets have a look at a service message. as already mentioned, there is two-way communication which means the messages have two components. an example is the service message /turtle1/set_pen which is a message for the turtlesim program seen earlier . launch the turtlesim node with:  ros2 run turtlesim turtlesim_node now, you can have a look at the services that are available with the following command:  ros2 service list the following list will appear: ros2 service list with the turtlesim application running we can see there is a service called /turtle1/set_pen . we can have a closer look at this service with the following command:  ros2 service type /turtle1/set_pen this command will return the message type for this service. in this case, the service type is turtlesim/srv/setpen . /turtle1/set_pen message type to get more information  this service message type, use the interface command:  ros2 interface show turtlesim/srv/setpen this command will show you the service message description. turtlesim/srv/setpen interface description for the /turtle1/set_pen message, this message looks as follows: uint8 r uint8 g uint8 b uint8 width uint8 off --- in general, the service message has a request and a response part, with their respective data types (which can be any type such as int8, uint16, string, bool, ), that are separated by three dashes as seen below: requesttype request --- responsetype response note: the request can be composed of several components or it can be empty, like in the setpen interface. the same holds true for the response . in the above example, the values of the three base colours are given as part of the request while the response is an empty message. this means that there is a response, but it does not contain any data. pay attention that, even though the response is empty, it needs to be sent as otherwise, the client will keep waiting for a response forever. the message type of the /turtle1/set_pen message is a /turtlesim/srv/setpen message, a custom message for this application. there are only a few standard message types for services as they are often very specific for a task. it is fairly common to create a new service message for each service used, unlike topics that usually rely on standard message types. using services in terminal in case you only want to get some information  existing services or you just want to test the function of a service , there is no need to write a ros2 program to do that. instead, you can simply use the terminal to do the job. starting turtlesim if you have no turtlesim node running, you can start it with the following command:  ros2 run turtlesim turtlesim_node the first thing you need to know is, how to find which services are already available. this allows you to use the services that already exist. finding information  the services as seen above, you can show a list of the existing services , use the following command:  ros2 service list this command will list all the services that are already available. the services available with the turtesim node are the following: /clear /kill /reset /spawn /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/describe_parameters /turtlesim/get_parameter_types /turtlesim/get_parameters /turtlesim/list_parameters /turtlesim/set_parameters /turtlesim/set_parameters_atomically lets have a closer look at the /spawn service:  ros2 service type /spawn this service is of the type turtlesim/srv/spawn . lets have a look at its description: float32 x float32 y float32 theta string name # optional. a unique name will be created and returned if this is empty --- string name looks like this service requires 4 different fields to be called. calling the service you can call the service as follows:  ros2 service call /spawn turtlesim/srv/spawn "{x: 2, y: 2, theta: 0, name: 'foxy_turtle'}" when you execute this command, you will see the following response: waiting for service to become available... requester: making request: turtlesim.srv.spawn_request(x=2.0, y=2.0, theta=0.0, name='foxy_turtle') response: turtlesim.srv.spawn_response(name='foxy_turtle') and you will see that a second turtle has appeared in the turtlesim node : spawning a new turtle with the spawn service moreover, the new turtle has its own set of services. you can find them with the following command:  ros2 service list the following new services are available now: /foxy_turtle/set_pen /foxy_turtle/teleport_absolute /foxy_turtle/teleport_relative these new services use the name specified in the service call: /foxy_turtle . ros2 service list to see new services in the previous part  topics , you learned how to subscribe to topics and how to publish them. in this case, though a service also consists of two parts, you can only use one part in the terminal: the service client . the client sends a request (like you did through the terminal) to a service server . the server performs an algorithm with a return value that is returned back to the client . as the server part is usually more complex, it cannot be done in the terminal. as with the topics , using the terminal to interact with services is usually only done for testing or quickly checking if the services are running. using services in python the usual method of using services is through ros2 nodes. in the next parts, you will see how to use services with python. as mentioned earlier, there are two parts of the service : the client and the server . these two parts can be split up into two separate python nodes. service servers the server is the part of a service that is being called and performs an action as a result. when the action is finished, the server provides a response to the client that sent the request . first, go to the directory containing the python programs that you made earlier. cd ~/ros2_ws/src/my_turtlesim/my_turtlesim/ now, create a new empty file and open it with your text editor. gedit my_service_server.py before you can type the code for running your service server node, you want to decide which message type you will use for calling the service . there are some standard message types that you can use (see here ). lets say you want to create a service that will allow you to make the turtle move in a circle after the service call. the message will not contain any data except for the information on when to start but you do want to know if the message has been received correctly. therefore, the trigger service message seems ideal as there is no input data and you receive feedback. have a look at the trigger message description: ros2 interface show std_srvs/srv/trigger the trigger message contains the following information: --- bool success # indicate successful run of triggered service string message # informational, e.g. for error messages the idea is that the client can send a message to the server to request that the turtle starts moving. as soon as the service call is received the server will reply and make the turtle move in circles. the code for the service server will look as seen here below. note that the code also contains code to publish to a topic . import rclpy from rclpy.node import node from std_srvs.srv import trigger from geometry_msgs.msg import twist class myserviceserver(node): def __init__(self): super().__init__('my_service_server') self.my_service = self.create_service(trigger, 'draw_circle', self.draw_circle_callback) self.publisher_ = self.create_publisher(twist, 'turtle1/cmd_vel', 10) def draw_circle_callback(self, request, response): request # request must be specified even if it is not used self.get_logger().info('received request to draw a circle!') response.success = true response.message = "starting to draw a circle!" timer_period = 0.5 # seconds self.timer = self.create_timer(timer_period, self.publish_velocity_callback) self.i = 0 return response def publish_velocity_callback(self): my_velocity = twist() my_velocity.linear.x = 0.5 my_velocity.angular.z = 0.5 self.publisher_.publish(my_velocity) self.get_logger().info(f"publishing velocity: \ \n\t linear.x: {my_velocity.linear.x}; \ \n\t linear.z: {my_velocity.linear.x}") self.i += 1 def main(args=none): rclpy.init(args=args) my_service_server = myserviceserver() rclpy.spin(my_service_server) rclpy.shutdown() if __name__ == '__main__': main() in the first part, you only tell ros2 which modules you import. in this case, you need to import the service message of the type std_srvs/srv/trigger and also the geometry_msgs/msg/twist message for publishing the velocity in a topic. import rclpy from rclpy.node import node from std_srvs.srv import trigger from geometry_msgs.msg import twist next, you create a class that inherits from the node class. in its __init__() function, you define the node name, the publisher for the velocity commands and the service server. the service takes the message type, the service name and the callback function as arguments. class myserviceserver(node): def __init__(self): super().__init__('my_service_server') self.my_service = self.create_service(trigger, 'draw_circle', self.draw_circle_callback) self.publisher_ = self.create_publisher(twist, 'turtle1/cmd_vel', 10) the moment that a service call is received, it will trigger a callback function in the code. in this case, the function is responsible to make the turtlesim move in circles. this is done by creating a publisher and then sending messages to the topic /turtle1/cmd_vel . in this implementation, the topic is published repeatedly in a timer callback function. the function finishes by returning the service response . at this point, the turtle starts drawing circles. def draw_circle_callback(self, request, response): request # request must be specified even if it is not used self.get_logger().info('received request to draw a circle!') response.success = true response.message = "starting to draw a circle!" timer_period = 0.5 # seconds self.timer = self.create_timer(timer_period, self.publish_velocity_callback) self.i = 0 return response the callback function of the timer simply sets the velocity command to be published and prints the command message to the screen. def publish_velocity_callback(self): my_velocity = twist() my_velocity.linear.x = 0.5 my_velocity.angular.z = 0.5 self.publisher_.publish(my_velocity) self.get_logger().info(f"publishing velocity: \ \n\t linear.x: {my_velocity.linear.x}; \ \n\t linear.z: {my_velocity.linear.x}") self.i += 1 the main function initialises the ros2 communication and creates an instance of our myserviceserver class. then, it keeps the node alive until ctrl+c is pressed. def main(args=none): rclpy.init(args=args) my_service_server = myserviceserver() rclpy.spin(my_service_server) rclpy.shutdown() if __name__ == '__main__': main() save the code with your text editor and close it. dont forget to make your python program executable:  chmod +x my_service_server.py you need to add the new ros2 python script to the setup.py file. open it with:  gedit ~/ros2_ws/src/my_turtlesim/setup.py add an entry for your new python program in the entry_points so it should look as follows: entry_points={ 'console_scripts': [ 'my_first_node = my_turtlesim.my_first_program:main', 'my_simple_publisher = my_turtlesim.my_simple_publisher:main', 'my_simple_subscriber = my_turtlesim.my_simple_subscriber:main', 'my_service_server = my_turtlesim.my_service_server:main', ], }, now go to the root directory of your workspace and build the package:  cd ~/ros2_ws/  colcon build --packages-select my_turtlesim --symlink-install  source install/local_setup.bash the colcon build command should build the package without any issues. colcon build the my_turtlesim package if you want to run and test the new service server, you will need to have 3 terminals: one for the turtlesim node, one for the service server node and one to call the service . in the first terminal, start the turtlesim node:  ros2 run turtlesim turtlesim_node in the second terminal, start the service server :  ros2 run my_turtlesim my_service_server in the third terminal, call the service :  ros2 service call /draw_circle std_srvs/srv/trigger {} you will see that the turtle will start moving after you called the service : turtle making circles after calling the /draw_circle service after executing the command, you can see how the turtle starts moving in a circle. calling the service from the terminal is useful to test if the service s working properly. on a real robot, it is more likely that the service is called by another ros2 program. this is called a service client . service clients the client is the part that calls the service . this means it sends a request to the server and then waits for a response. one node can consist of several clients that call different services . to start, you can go to the package you already made earlier:  cd ~/ros2_ws/src/my_turtlesim/my_turtlesim/ now you can create a new file called my_service_client.py in which you will write the python code to create a service client node:  gedit my_service_client.py now, an empty text editor window will pop up where you can type down the following code: import rclpy from rclpy.node import node from std_srvs.srv import trigger class myserviceclient(node): def __init__(self): super().__init__('my_service_client') self.my_client = self.create_client(trigger, 'draw_circle') while not self.my_client.wait_for_service(timeout_sec=1.0): self.get_logger().info('waiting for service to become avilable...') self.req = trigger.request() def send_request(self): self.future = self.my_client.call_async(self.req) rclpy.spin_until_future_complete(self, self.future) return self.future.result() def main(args=none): rclpy.init(args=args) my_service_client = myserviceclient() response = my_service_client.send_request() my_service_client.get_logger().info( f'result for triggering "draw circle: \ \n\tsuccessful: {response.success} \ \n\tmessage: {response.message}') my_service_client.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() what this code does, is first import the rclpy library and the service message type trigger from the subfolder srv from the ros package called std_srvs . import rclpy from rclpy.node import node from std_srvs.srv import trigger the next part creates a class inherited from the node class. this class, called myserviceclient initiates the node with the node name my_service_client and creates a service client instance using the service message type and the name of the service . next, we create an empty service request message. class myserviceclient(node): def __init__(self): super().__init__('my_service_client') self.my_client = self.create_client(trigger, 'draw_circle') while not self.my_client.wait_for_service(timeout_sec=1.0): self.get_logger().info('waiting for service to become avilable...') self.req = trigger.request() the function send_request() defines a variable called self.future which receives the response from the service server . then, the program spins until the response has been received with the rclpy.spin_until_future_complete() function. in this function, you need to specify which variable contains the received response. the variable name self.future can be chosen freely, but for clarity, it contains the word future to specify it is the response that will be obtained in the near future after making the request. the function ends with returning the received answer. def send_request(self): self.future = self.my_client.call_async(self.req) rclpy.spin_until_future_complete(self, self.future) return self.future.result() the main function initialises the ros2 communication and then creates an instance of the node class. then, we added a log entry to display in the terminal that we created a service request for the service /draw_circle . we end the program by destroying the node and shutting down the program. def main(args=none): rclpy.init(args=args) my_service_client = myserviceclient() response = my_service_client.send_request() my_service_client.get_logger().info( f'result for triggering "draw circle: \ \n\tsuccessful: {response.success} \ \n\tmessage: {response.message}') my_service_client.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() save the code and then make the file executable with the following command:  chmod +x my_service_client.py now, add the new node to the setup.py file:  gedit ~/ros2_ws/src/my_turtlesim/setup.py and add a new entry: entry_points={ 'console_scripts': [ 'my_first_node = my_turtlesim.my_first_program:main', 'my_simple_publisher = my_turtlesim.my_simple_publisher:main', 'my_simple_subscriber = my_turtlesim.my_simple_subscriber:main', 'my_service_server = my_turtlesim.my_service_server:main', 'my_service_client = my_turtlesim.my_service_client:main', ], }, save the file and close it. now go to the root directory of your workspace, build the package and source the workspace:  cd ~/ros2_ws/  colcon build --packages-select my_turtlesim --symlink-install  source install/local_setup.bash now, you can test the service client . for this, you need 3 terminals: one for the turtlesim node, one for the service server node and one to call the service with your new node. in the first terminal, start the turtlesim node:  ros2 run turtlesim turtlesim_node in the second terminal, start the service server :  ros2 run my_turtlesim my_service_server in the third terminal, run the service client :  ros2 run my_turtlesim my_service_client you will see that the turtle will start moving after you run the service client node: run service client if everything went correctly, the turtle should start moving and a message should appear that the service call was successful. since the program is only spinning until the response has been received, the program will stop automatically. this also means that the program is not responsive until the response has been received. if the server is taking longer or is not responding at all, the client node can be stuck. this could disrupt the behaviour of the robot. therefore, services should only be used for tasks where the server will finish quickly such as taking a picture, saving a map or maybe closing or opening a gripper. for tasks that take longer, it is recommended to use ros2 actions. since ros2 actions are a bit more advanced, they will not be covered here.