how to integrate opencv with a ros2 c++ node written by bayode aderinola  ros2 q&a | ros2 tutorials  22/02/2023 in this post, you will learn how to integrate the opencv library with a ros2 c++ node. the example shown builds into a hello-world binary for ros2 integration with opencv that publishes an image to the ros network. after going through this post, you would be able to use opencv to do things related to image processing and computer vision and make the results available to other ros2 nodes. the example uses ros2 humble . step 1: fire up a system with ros2 installation hey, do i have to install ros2 first? absolutely not! just log in to the construct to get access to virtual machines pre-installed with ros. once logged in, click on my rosjects , then create a new rosject , supply the information as shown in the image below, and click create . then run the rosject. create a new rosject you might also want to try this on a local pc if you have ros2 installed. however, please note that we cannot support local pcs and you will have to fix any errors you run into on your own. the rest of the instruction assumes that you are working on the construct; please adapt them to your local pc and ros2 installation. step 2: verify that opencv is installed all ros installs include opencv, so verify whether opencv has been installed. open a web shell open a web shell and run the following command: pkg-config --modversion opencv4 you should get a version number similar to this: 4.5.4 if the above output is similar to what you see, you are set and ready, everything should work. otherwise, please install opencv using the following command: sudo apt install libopencv-dev python3-opencv step 3: create a ros2 c++ node integrating the opencv library first, we need to create a package. we need the following dependencies for the package: rclcpp  this is the ros2 c++ api well use to create the ros2 node std_msgs  needed for sending message header while sending the image sensor_msgs  needed for sending the image itself cv_bridge  converts from the opencv image format to the ros2 image format image_transport  compresses the image for transport within the ros2 network opencv  generates the image we want to send run the following command in the terminal you used in step 2, to create the package: cd ~/ros2_ws/src ros2 pkg create my_opencv_demo --dependencies rclcpp std_msgs sensor_msgs cv_bridge image_transport opencv now go to the src folder of the package you just created and create the c++ file that will define the node: cd ~/ros2_ws/src/my_opencv_demo/src touch minimal_opencv_ros2_node.cpp open the code editor, locate the c++ file you just created, and paste the code indicated below. explanations are given as comments within the code. open the code editor #include "rclcpp/rclcpp.hpp" #include "sensor_msgs/msg/image.hpp" #include "std_msgs/msg/header.hpp" #include <chrono> #include <cv_bridge/cv_bridge.h> // cv_bridge converts between ros 2 image messages and opencv image representations. #include <image_transport/image_transport.hpp> // using image_transport allows us to publish and subscribe to compressed image streams in ros2 #include <opencv2/opencv.hpp> // we include everything  opencv as we don't care much  compilation time at the moment. using namespace std::chrono_literals; class minimalimagepublisher : public rclcpp::node { public: minimalimagepublisher() : node("opencv_image_publisher"), count_(0) { publisher_ = this->create_publisher<sensor_msgs::msg::image>("random_image", 10); timer_ = this->create_wall_timer( 500ms, std::bind(&amp;minimalimagepublisher::timer_callback, this)); } private: void timer_callback() { // create a new 640x480 image cv::mat my_image(cv::size(640, 480), cv_8uc3); // generate an image where each pixel is a random color cv::randu(my_image, cv::scalar(0, 0, 0), cv::scalar(255, 255, 255)); // write message to be sent. member function toimagemsg() converts a cvimage // into a ros image message msg_ = cv_bridge::cvimage(std_msgs::msg::header(), "bgr8", my_image) .toimagemsg(); // publish the image to the topic defined in the publisher publisher_->publish(*msg_.get()); rclcpp_info(this->get_logger(), "image %ld published", count_); count_++; } rclcpp::timerbase::sharedptr timer_; sensor_msgs::msg::image::sharedptr msg_; rclcpp::publisher<sensor_msgs::msg::image>::sharedptr publisher_; size_t count_; }; int main(int argc, char *argv[]) { rclcpp::init(argc, argv); // create a ros2 node auto node = std::make_shared<minimalimagepublisher>(); // process ros2 callbacks until receiving a sigint (ctrl-c) rclcpp::spin(node); rclcpp::shutdown(); return 0; } finally, edit the packages cmakelists.txt ( ~/ros2_ws/src/my_opencv_demo/cmakelists.txt ) file to recognize the node. copy the lines of code shown below and paste them before the invocation of ament_package() : add_executable(minimal_opencv_ros2_node src/minimal_opencv_ros2_node.cpp) ament_target_dependencies(minimal_opencv_ros2_node rclcpp std_msgs sensor_msgs cv_bridge image_transport opencv)  install(targets minimal_opencv_ros2_node destination lib/{project_name} ) the cmakelists.txt file should now look like this: cmake_minimum_required(version 3.8) project(my_opencv_demo) if(cmake_compiler_is_gnucxx or cmake_cxx_compiler_id matches "clang") add_compile_options(-wall -wextra -wpedantic) endif() # find dependencies find_package(ament_cmake required) find_package(rclcpp required) find_package(std_msgs required) find_package(sensor_msgs required) find_package(cv_bridge required) find_package(image_transport required) find_package(opencv required) if(build_testing) find_package(ament_lint_auto required) # the following line skips the linter which checks for s # comment the line when a  and license is added to all source files set(ament_cmake__found true) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a  and license is added to all source files set(ament_cmake_cpplint_found true) ament_lint_auto_find_test_dependencies() endif() add_executable(minimal_opencv_ros2_node src/minimal_opencv_ros2_node.cpp) ament_target_dependencies(minimal_opencv_ros2_node rclcpp std_msgs sensor_msgs cv_bridge image_transport opencv) install(targets minimal_opencv_ros2_node destination lib/{project_name} ) ament_package() congratulations! you have created a ros2 c++ node integrating opencv. now, we need to see if it works! step 4: compile and test ros2 c++ node integrating the opencv library generate the ros2 executable by compiling and sourcing the package: cd ~/ros2_ws colcon build --packages-select my_opencv_demo source ~/ros2_ws/install/setup.bash if you got to this point, great! now we will run the node: ros2 run my_opencv_demo minimal_opencv_ros2_node you should see some output similar to this: [info] [1677071986.446315963] [opencv_image_publisher]: image 0 published [info] [1677071986.941745471] [opencv_image_publisher]: image 1 published [info] [1677071987.442009334] [opencv_image_publisher]: image 2 published [info] [1677071987.941677164] [opencv_image_publisher]: image 3 published [info] [1677071988.441115565] [opencv_image_publisher]: image 4 published [info] [1677071988.940492910] [opencv_image_publisher]: image 5 published [info] [1677071989.441007118] [opencv_image_publisher]: image 6 published now lets run ros2 topic list to confirm the existence of the image topic. leave the node running in the current terminal and run the following command in a new terminal: source ~/ros2_ws/install/setup.bash ros2 topic list the output should inclide the /random_image topic: /parameter_events /random_image /rosout finally lets us see what the image produced by opencv looks like. run the following in the same terminal where you ran ros2 topic list . if you get the error, (image_view:8839): gdk-error **: 13:30:34.498: the program 'image_view' received an x window system error , just run the command again. ros2 run image_view image_view --ros-args --remap image:=/random_image you should now see something like this pop up on your screen. yahoo! random image output from the opencv node great job! you have successfully created a ros2 c++ node integrating opencv! step 5: extra: add text to the image copy the lines of code shown below and paste them inside the timer callback function just before writing the message to be sent: // declare the text position cv::point text_position(15, 40); // declare the size and color of the font int font_size = 1; cv::scalar font_color(255, 255, 255); // declare the font weight int font_weight = 2; // put the text in the image cv::puttext(my_image, "ros2 + opencv", text_position, cv::font_hershey_complex, font_size, font_color, font_weight); stop the currently running node, recompile and source the package, and re-run the node. you should now see something like this: random image with text from the opencv node step 6: check your learning do you understand how to create a ros2 c++ node integrating opencv? if you dont know it yet, please go over the post again, more carefully this time. (extra) step 7: watch the video to understand how to integrate the opencv library with a ros2 c++ node here you go: feedback did you like this post? do you have any questions  how to integrate the opencv library with a ros2 c++ node ? please leave a comment in the comments section below, so we can interact and learn from each other. if you want to learn  other ros2 topics, please let us know in the comments area and we will do a video or post  it. get ros2 industrial ready- hands-on training by the construct cover.png topics: binaries | ros2 | ros2 binaries | ros2 packages | ros2 pkg check out these related posts how to become a robotics developer may 26, 2018 updated: july 26, 2023 robotics needs developers! robotics needs software engineers and software... read more 130. the open source robotics alliance apr 8, 2024 i would like to dedicate this episode to all the ros developers out there who are thinking and... read more 129. ros2ai jan 29, 2024 i would like to dedicate this episode to all the ros developers who believe that chatgpt or... read more  older entries 8 comments kae on 07/09/2023 at 8:42 am is image_transport being used in your code? i think its included but not used. reply jai on 28/12/2023 at 9:36 am  stderr: my_opencv_demo cmake error at cmakelists.txt:13 (find_package): by not providing findcv_bridge.cmake in cmake_module_path this project has asked cmake to find a package configuration file provided by cv_bridge, but cmake did not find one. could not find a package configuration file provided by cv_bridge with any of the following names: cv_bridgeconfig.cmake cv_bridge-config.cmake add the installation prefix of cv_bridge to cmake_prefix_path or set cv_bridge_dir to a directory containing one of the above files. if cv_bridge provides a separate development package or sdk, be sure it has been installed.  failed <<< my_opencv_demo [9.44s, exited with code 1] summary: 0 packages finished [15.2s] 1 package failed: my_opencv_demo 1 package had stderr output: my_opencv_demo pkg-config modversion opencv4 4.5.4 reply jai on 28/12/2023 at 9:37 am sudo apt-get install ros-humble-ros-base reply jai on 28/12/2023 at 10:22 am sudo apt-get install ros-{ros_distro}-cv-bridge sudo apt-get install ros-{ros_distro}-image-transport okay, should solve the issue reply jai on 28/12/2023 at 10:27 am what is & trying to do in line 19 of minimal_opencv_ros2_node.cpp? 500ms, std::bind(&minimalimagepublisher::timer_callback, this)); reply jai on 28/12/2023 at 10:27 am what is & trying to do in line 19 of minimal_opencv_ros2_node.cpp? 500ms, std::bind(&minimalimagepublisher::timer_callback, this)); reply jai on 28/12/2023 at 10:43 am conversion error when copying from the ui interface, it becomes & amp; source ~/ros2_ws/install/setup.bash ros2 run my_opencv_demo minimal_opencv_ros2_node package my_opencv_demo not found reply jai on 28/12/2023 at 11:20 am either source ~/ros2_ws/install/setup.bash does not work, must change to source ./install/setup.bash or missing source /opt/ros/{ros_distro}/setup.bash then can it can find my_opencv_demo package. i also need to sudo apt-get install ros-{ros_distro}-image-view reply submit a comment cancel reply your email address will not be published. comment name email website save my name, email, and website in this browser for the next time i comment. submit comment δ this site uses akismet to reduce spam. learn how your comment data is processed . pin it on pinterest share this twitter linkedin reddit facebook gmail